
# Note that the meta "::typesys::lang::struct" command
# is only used to define the new "struct" command,
# which follows the unfolding of the nested ("nest")
# calls dictated by "::typesys::lang::struct".
#
# ::typesys::lang::struct struct { ... }

struct struct {
    varchar nsp
    varchar name
    varchar pk
    bool is_final_if_no_scope
    set<typedecl> slots = {}
}

struct typedecl {
    varchar name
    varchar type
    varchar default
    bool optional_p = false
    varchar container_type
    varchar subtype
}

struct email -pk address {
    varchar name = ""
    varchar address
}

struct file {
    varchar name
    varchar mime_type
    int32 size
}

struct folder {
    varchar name
}

struct message -is_final_if_no_scope "1" {

    varchar device = "sms"

    int16 num_comments = 0

    varchar subject

    varchar body

    # example of an instance:
    # email -name "zena wow" -address "zena@example.com"
    #
    # example of slot definition:
    # email from
    #
    # slot from -type email
    email from

    # slot from -type email

    # embedded object mapping for slot email
    # struct -name from {
    #     varchar name = ""
    #     varchar email
    # }

    list<email> to
    list<email> cc = {}
    list<email> bcc = {}

    bool public_p = false

    set<category> categories
    set<folder> folders
    set<varchar> tags
    set<file> attachment = {}

    map<varchar,i32> wordcount

    #extends -ref content.Object
    #extends -ref content.Content
    #extends -ref auditing.Auditing -hi world

    #index -attr public_p -abc 123

}

# we can have an x-format attribute that specifies which format to 
# express in the body of the typeinst
#   typeinst message msg1 -x-format "tdom" { ... }
#   typeinst message msg1 -x-format "xml" { ... }
#   typeinst message msg1 -x-format "dict" { ... }
#   typeinst message msg1 -x-format "csv" { ... }
#   typeinst message msg1 -x-format "list" { ... }
#   typeinst message msg1 -x-format "object" { ... }

typeinst message msg1 {

    typeinst varchar subject = "hello"

    typeinst email from {
        typeinst varchar name = "zena wow"
        typeinst varchar address = "zena@example.com"
    }

    typeinst varchar body = "this is a test"

}

#email from -name "zena wow" -address "zena@example.com"
message msg2 {
    varchar subject = "hello"
    email from {
        varchar name = "zena wow"
        varchar address = "zena@example.com"
    }
    varchar body = "this is a test"
}

message msg3 {
    message.subject "hello"
    message.from {
        email.name "zena wow"
        email.address "zena@example.com"
    }
    message.body = "this is a test"
}

if {0} {
    message msg4 {
        subject "hello"
        from {
            name "zena wow"
            address "zena@example.com"
        }
        body "this is a test"
    }
}

message msg5 -subject "hello" -body "this is a test" {
    email from -name "zena wow" -address "zena@example.com"
}

#db_insert -scope {user} -what msg1
