/*---------------------------------------------------------------------------*
 *  calcul.h - Class definitions for calcul.cpp.                             *
 *  Generated by LIBERO 2.11 on 28 May, 1996, 22:16.                         *
 *  Schema file used: lrschema.cpp.                                          *
 *  Modify this code ONLY between the %START and %END markers                *
 *---------------------------------------------------------------------------*/

#ifndef _CALCUL_INCLUDED                //  Allow multiple inclusions
#define _CALCUL_INCLUDED

//  Definitions, classes, types that you need to export
//%START DEFINITIONS

#define INVALID_TOKEN       1           /*  calculate() feedbacks            */
#define TOKEN_EXPECTED      2
#define LEFT_PAR_EXPECTED   3
#define RIGHT_PAR_EXPECTED  4
#define QUOTES_EXPECTED     5
#define OPERAND_OVERFLOW    6
#define OPERATOR_OVERFLOW   7
#define NUMBER_EXPECTED     8
#define STRING_EXPECTED     9
#define UNKNOWN_FUNCTION    10

#define name_max            10          //  Max size of function names
#define string_max          256         //  Max size of string parameter
#define operator_max        20          //  Max size of operator stack
#define operand_max         20          //  Max size of operand stack

//- Structure declarations --------------------------------------------------

typedef struct {                        //  Item on operator stack:
    char token;                         //    Operator token
    char name [name_max];               //    Name of function
    int  priority;                      //    Relative priority
    } OPREQ;

typedef struct {                        //  Item on operand stack
    double number;                      //    Value for number
    char  *string;                      //    Value for string
    char   type;                        //    Type: 'N' or 'S'
    } OPVAL;

//- Definition of new types -------------------------------------------------

typedef double (*func_i) (int    param);
typedef double (*func_l) (long   param);
typedef double (*func_d) (double param);
typedef double (*func_s) (char * param);

//- Class definitions -------------------------------------------------------

class Ccalc_fct                         //  Def. of a calculate function
{
  public:
    union {                             //    Union of following:
        func_i i;                       //      function takes int
        func_l l;                       //      function takes long
        func_d d;                       //      function takes double
        func_s s;                       //      function takes string
        } fct;
    char
       *name;                           //    Name
    char
       type;                            //    Type: i, l, s, or d
    Ccalc_fct
       * next;                          //    Next function in list
  public:
    Ccalc_fct  ();
    ~Ccalc_fct ();
};

//%END DEFINITIONS

//  Definitions that we need to run the state machine
#ifndef MODULE
#define MODULE  void                    //  Libero dialog modules
#endif
typedef int t_event;                    //  Type for dialog entity

//- Class definition --------------------------------------------------------

class Ccalcul
{
    //  Function prototypes
    public:
        Ccalcul     (void);             //  Constructor
       ~Ccalcul     (void);             //  Destructor
    //  Functions and data that you want to add to the class
//%START CLASS
        int     calculate                 (char *input, double *result,
                                           int  *err_pos);
        Bool    add_function              (func_i i, char *name);
        Bool    add_function              (func_l l, char *name);
        Bool    add_function              (func_d d, char *name);
        Bool    add_function              (func_s s, char *name);
    private:
        int
            operator_ptr,               //  Current size of operator stack
            operand_ptr;                //  Current size of operand stack
        OPREQ
            operator_stack [operator_max];
        OPVAL
            operand_stack  [operand_max];
        double
            the_number,                 //  Value of number in expression
            op_1,
            op_2;                       //  Operands used in calculations
        char
            the_token,                  //  Current expression token
            op_type,                    //  Type S or N of operand
            the_priority,               //  Priority of current token
            the_name   [name_max],      //  Value of name in expression
            the_string [string_max],    //  Value of string in expression
            cur_name   [name_max],      //  Function to execute from stack
            cur_token,                  //  Token to execute from stack
            *expr;                      //  Pointer to expression to parse
        int
            xptr,                       //  Offset to next char to parse
            name_size,                  //  Size of name
            string_size,                //  Size of string
            token_posn;                 //  Offset of last token parsed
        double
            *result;                    //  Result of expression
        int
            *error_posn,                //  Offset of error in expression
            feedback;                   //  0 if no errors, else error type
        Ccalc_fct
            *flist;                     //  Function list
    private:
        void signal_error      (int error);
        void stack_operand     (char type, double value);
        void unstack_operator  (void);
        void execute_function  (void);
        void require_number_op (void);
        void require_string_op (void);
//%END CLASS
    private:
        void   raise_exception            (t_event event);
        MODULE initialise_the_program     (void);
        MODULE get_external_event         (void);
        MODULE get_next_token             (void);
        MODULE signal_invalid_token       (void);
        MODULE signal_token_missing       (void);
        MODULE stack_the_number           (void);
        MODULE stack_the_operator         (void);
        MODULE stack_the_string           (void);
        MODULE terminate_the_program      (void);
        MODULE unstack_all_operators      (void);
        MODULE unstack_ge_operators       (void);
        MODULE unstack_if_end_mark        (void);
        MODULE unstack_if_left_par        (void);
    //  Variables used by dialog interpreter
    protected:
        t_event
            _LR_event,                  //  Event for state transition
            _LR_state,                  //  Current dialog state
            _LR_savest,                 //  Saved dialog state
            _LR_index,                  //  Index into vector table
            the_next_event,             //  Next event from module
            the_exception_event;        //  Exception event from module
        word
            *_LR_vecptr;                //  Pointer into vector table
        Bool
            exception_raised;           //  TRUE if exception raised
};

//  The dialog modules are defined as class functions
typedef void (Ccalcul::*classfunc) (void);

//- Symbolic constants and event numbers ------------------------------------
#define _LR_STOP                        0xFFFFL
#define _LR_NULL_EVENT                  -2
#define terminate_event                 -1
#define end_mark_event                  0
#define error_event                     1
#define exception_event                 2
#define function_event                  3
#define left_par_event                  4
#define number_event                    5
#define ok_event                        6
#define operator_event                  7
#define other_event                     8
#define right_par_event                 9
#define string_event                    10
#define _LR_STATE_after_init            0
#define _LR_STATE_expecting_operand     1
#define _LR_STATE_expecting_operator    2
#define _LR_STATE_defaults              3
#define _LR_defaults_state              3

#endif                                  //  If included

