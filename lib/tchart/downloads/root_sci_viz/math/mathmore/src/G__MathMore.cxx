//
// File generated by core/utils/src/rootcint_tmp at Sat Jan 22 22:30:30 2011

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME mathdImathmoredIsrcdIG__MathMore
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__MathMore.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Polynomial Polynomial;
      #else
      class Polynomial  :  public ::ROOT::Math::ParamFunction< ::ROOT::Math::IParametricGradFunctionOneDim >,  public ::ROOT::Math::IGradientOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::ParamFunction< ::ROOT::Math::IParametricGradFunctionOneDim> ParFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Polynomial() throw() {};
         unsigned int fOrder; //
         vector< double > fDerived_params; //
         vector< ::complex< double >  > fRoots; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::ParamFunction< ::ROOT::Math::IParametricGradFunctionOneDim > ParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR;
      #else
      class ParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR  :  public ::ROOT::Math::IParametricGradFunctionOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IParametricGradFunctionOneDim BaseParFunc;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~ParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR() throw() {};
         unsigned int fNpar; //
         vector< double > fParams; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Derivator Derivator;
      #else
      class Derivator  {
         public:
         //friend XX;
         typedef void* (*GSLFuncPointer)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Derivator() throw() {};
         ::ROOT::Math::GSLDerivator* fDerivator; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Interpolator Interpolator;
      #else
      class Interpolator  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Interpolator() throw() {};
         ::ROOT::Math::GSLInterpolator* fInterp; //pointer to GSL interpolator class
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRootFinder GSLRootFinder;
      #else
      class GSLRootFinder  :  public ::ROOT::Math::IRootFinderMethod {
         public:
         //friend XX;
         typedef void* (*GSLFuncPointer)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLRootFinder() throw() {};
         ::ROOT::Math::GSLFunctionWrapper* fFunction; //
         ::ROOT::Math::GSLRootFSolver* fS; //
         double fRoot; //
         double fXlow; //
         double fXup; //
         int fIter; //
         int fStatus; //
         bool fValidInterval; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRootFinderDeriv GSLRootFinderDeriv;
      #else
      class GSLRootFinderDeriv  :  public ::ROOT::Math::IRootFinderMethod {
         public:
         //friend XX;
         typedef void* (*GSLFuncPointer)() ;
         typedef void* (*GSLFdFPointer)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLRootFinderDeriv() throw() {};
         ::ROOT::Math::GSLFunctionDerivWrapper* fFunction; //
         ::ROOT::Math::GSLRootFdFSolver* fS; //
         double fRoot; //
         double fPrevRoot; //
         int fIter; //
         int fStatus; //
         bool fValidPoint; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::Bisection Bisection;
      #else
      class Bisection  :  public ::ROOT::Math::GSLRootFinder {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Bisection() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::FalsePos FalsePos;
      #else
      class FalsePos  :  public ::ROOT::Math::GSLRootFinder {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~FalsePos() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::Brent Brent;
      #else
      class Brent  :  public ::ROOT::Math::GSLRootFinder {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Brent() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::Newton Newton;
      #else
      class Newton  :  public ::ROOT::Math::GSLRootFinderDeriv {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Newton() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::Secant Secant;
      #else
      class Secant  :  public ::ROOT::Math::GSLRootFinderDeriv {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Secant() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {
            namespace Roots {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Roots::Steffenson Steffenson;
      #else
      class Steffenson  :  public ::ROOT::Math::GSLRootFinderDeriv {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Steffenson() throw() {};
      };
      #endif
      } } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLIntegrator GSLIntegrator;
      #else
      class GSLIntegrator  :  public ::ROOT::Math::VirtualIntegratorOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLIntegrator() throw() {};
         ::ROOT::Math::IntegrationOneDim::Type fType; //
         ::ROOT::Math::Integration::GKRule fRule; //
         double fAbsTol; //
         double fRelTol; //
         unsigned long fSize; //
         unsigned long fMaxIntervals; //
         double fResult; //
         double fError; //
         int fStatus; //
         int fNEval; //
         ::ROOT::Math::GSLFunctionWrapper* fFunction; //
         ::ROOT::Math::GSLIntegrationWorkspace* fWorkspace; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VegasParameters VegasParameters;
      #else
      class VegasParameters  {
         public:
         //friend XX;
         double alpha; //
         unsigned long iterations; //
         int stage; //
         int mode; //
         int verbose; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::MiserParameters MiserParameters;
      #else
      class MiserParameters  {
         public:
         //friend XX;
         double estimate_frac; //
         unsigned long min_calls; //
         unsigned long min_calls_per_bisection; //
         double alpha; //
         double dither; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLMCIntegrator GSLMCIntegrator;
      #else
      class GSLMCIntegrator  :  public ::ROOT::Math::VirtualIntegratorMultiDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IntegrationMultiDim::Type Type;
         typedef void* (*GSLMonteFuncPointer)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLMCIntegrator() throw() {};
         ::ROOT::Math::IntegrationMultiDim::Type fType; //
         ::ROOT::Math::GSLRngWrapper* fRng; //
         unsigned int fDim; //
         unsigned int fCalls; //
         double fAbsTol; //
         double fRelTol; //
         double fResult; //
         double fError; //
         int fStatus; //
         ::ROOT::Math::GSLMCIntegrationWorkspace* fWorkspace; //
         ::ROOT::Math::GSLMonteFunctionWrapper* fFunction; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLMinimizer1D GSLMinimizer1D;
      #else
      class GSLMinimizer1D  :  public ::ROOT::Math::IMinimizer1D {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLMinimizer1D() throw() {};
         double fXmin; //
         double fXlow; //
         double fXup; //
         double fMin; //
         double fLow; //
         double fUp; //
         int fIter; //
         int fStatus; //status of last minimization (==0 ok =1 failed)
         bool fIsSet; //
         ::ROOT::Math::GSL1DMinimizerWrapper* fMinimizer; //
         ::ROOT::Math::GSLFunctionWrapper* fFunction; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Chebyshev Chebyshev;
      #else
      class Chebyshev  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Chebyshev() throw() {};
         unsigned long fOrder; //
         ::ROOT::Math::GSLChebSeries* fSeries; //
         ::ROOT::Math::GSLFunctionWrapper* fFunction; //pointer to function
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRandomEngine GSLRandomEngine;
      #else
      class GSLRandomEngine  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLRandomEngine() throw() {};
         ::ROOT::Math::GSLRngWrapper* fRng; //pointer to GSL generator wrapper (managed by the class)
         unsigned int fCurTime; //current time used to seed the generator
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngMT GSLRngMT;
      #else
      class GSLRngMT  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngRanLux GSLRngRanLux;
      #else
      class GSLRngRanLux  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngRanLuxS1 GSLRngRanLuxS1;
      #else
      class GSLRngRanLuxS1  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngRanLuxS2 GSLRngRanLuxS2;
      #else
      class GSLRngRanLuxS2  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngRanLuxD1 GSLRngRanLuxD1;
      #else
      class GSLRngRanLuxD1  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngRanLuxD2 GSLRngRanLuxD2;
      #else
      class GSLRngRanLuxD2  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngTaus GSLRngTaus;
      #else
      class GSLRngTaus  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLRngGFSR4 GSLRngGFSR4;
      #else
      class GSLRngGFSR4  :  public ::ROOT::Math::GSLRandomEngine {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::KelvinFunctions KelvinFunctions;
      #else
      class KelvinFunctions  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~KelvinFunctions() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLMinimizer GSLMinimizer;
      #else
      class GSLMinimizer  :  public ::ROOT::Math::Minimizer {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLMinimizer() throw() {};
         unsigned int fDim; //
         ::ROOT::Math::GSLMultiMinimizer* fGSLMultiMin; //
         :: ROOT::Math::IGradientFunctionMultiDim* fObjFunc; //
         double fMinVal; //
         double fLSTolerance; //Line Search Tolerance
         vector< double > fValues; //
         vector< double > fSteps; //
         vector< ::string > fNames; //
         vector< ::ROOT::Math::EMinimVariableType > fVarTypes; //vector specifyng the type of variables
         map< unsigned int, pair< double, double >  > fBounds; //map specifying the bound using as key the parameter index
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLSimAnFunc GSLSimAnFunc;
      #else
      class GSLSimAnFunc  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLSimAnFunc() throw() {};
         vector< double > fX; //
         vector< double > fScale; //
         :: ROOT::Math::IBaseFunctionMultiDim* fFunc; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLSimAnParams GSLSimAnParams;
      #else
      class GSLSimAnParams  {
         public:
         //friend XX;
         int n_tries; //number of points to try for each step
         int iters_fixed_T; //number of iterations at each temperature
         double step_size; //max step size used in random walk
         double k; //
         double t_initial; //
         double mu; //
         double t_min; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLSimAnnealing GSLSimAnnealing;
      #else
      class GSLSimAnnealing  {
         public:
         //friend XX;
         ::ROOT::Math::GSLSimAnParams fParams; //parameters for GSLSimAnnealig
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GSLSimAnMinimizer GSLSimAnMinimizer;
      #else
      class GSLSimAnMinimizer  :  public ::ROOT::Math::Minimizer {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GSLSimAnMinimizer() throw() {};
         unsigned int fDim; //dimension of the function to be minimized 
         bool fOwnFunc; //flag to indicate if objective function is managed 
         ::ROOT::Math::GSLSimAnnealing fSolver; //
         :: ROOT::Math::IBaseFunctionMultiDim* fObjFunc; //
         double fMinVal; //minimum values 
         vector< double > fValues; //
         vector< double > fSteps; //
         vector< ::string > fNames; //
         vector< ::ROOT::Math::EMinimVariableType > fVarTypes; //vector specifyng the type of variables
         map< unsigned int, pair< double, double >  > fBounds; //map specifying the bound using as key the parameter index
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Vavilov Vavilov;
      #else
      class Vavilov  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Vavilov() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VavilovAccurate VavilovAccurate;
      #else
      class VavilovAccurate  :  public ::ROOT::Math::Vavilov {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VavilovAccurate() throw() {};
         double fH[8]; //
         double fT0; //
         double fT1; //
         double fT; //
         double fOmega; //
         double fA_pdf[501]; //
         double fB_pdf[501]; //
         double fA_cdf[501]; //
         double fB_cdf[501]; //
         double fX0; //
         double fKappa; //
         double fBeta2; //
         double fEpsilonPM; //
         double fEpsilon; //
         bool fQuantileInit; //
         int fNQuant; //
         double fQuant[32]; //
         double fLambda[32]; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VavilovAccuratePdf VavilovAccuratePdf;
      #else
      class VavilovAccuratePdf  :  public ::ROOT::Math::IParametricFunctionOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VavilovAccuratePdf() throw() {};
         double fP[5]; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VavilovAccurateCdf VavilovAccurateCdf;
      #else
      class VavilovAccurateCdf  :  public ::ROOT::Math::IParametricFunctionOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VavilovAccurateCdf() throw() {};
         double fP[5]; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VavilovAccurateQuantile VavilovAccurateQuantile;
      #else
      class VavilovAccurateQuantile  :  public ::ROOT::Math::IParametricFunctionOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VavilovAccurateQuantile() throw() {};
         double fP[5]; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VavilovFast VavilovFast;
      #else
      class VavilovFast  :  public ::ROOT::Math::Vavilov {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VavilovFast() throw() {};
         double fKappa; //
         double fBeta2; //
         double fAC[14]; //
         double fHC[9]; //
         double fWCM[201]; //
         int fItype; //
         int fNpt; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngMT > RandomlEROOTcLcLMathcLcLGSLRngMTgR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngMTgR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngMT fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngTaus > RandomlEROOTcLcLMathcLcLGSLRngTausgR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngTausgR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngTaus fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngRanLux > RandomlEROOTcLcLMathcLcLGSLRngRanLuxgR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngRanLuxgR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngRanLux fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngRanLuxS1 > RandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngRanLuxS1 fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngRanLuxS2 > RandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngRanLuxS2 fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngRanLuxD1 > RandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngRanLuxD1 fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngRanLuxD2 > RandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngRanLuxD2 fEngine; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Random< ::ROOT::Math::GSLRngGFSR4 > RandomlEROOTcLcLMathcLcLGSLRngGFSR4gR;
      #else
      class RandomlEROOTcLcLMathcLcLGSLRngGFSR4gR  {
         public:
         //friend XX;
         ::ROOT::Math::GSLRngGFSR4 fEngine; //
      };
      #endif
      } } 
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOT_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT", 0 /*version*/, "include/Math/VavilovFast.h", 42,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOT_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOT_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }

namespace ROOT {
namespace Math {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMath_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math", 0 /*version*/, "include/Math/VavilovFast.h", 43,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMath_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMath_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
namespace MathMore {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathMore_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::MathMore", 0 /*version*/, "include/Math/QuantFuncMathMore.h", 148,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathMore_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathMore_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLPolynomial_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLPolynomial_Dictionary();
   static void *new_ROOTcLcLMathcLcLPolynomial(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLPolynomial(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLPolynomial(void *p);
   static void deleteArray_ROOTcLcLMathcLcLPolynomial(void *p);
   static void destruct_ROOTcLcLMathcLcLPolynomial(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Polynomial*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Polynomial) == sizeof(::ROOT::Shadow::ROOT::Math::Polynomial));
      ::ROOT::Math::Polynomial *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Polynomial),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Polynomial", "include/Math/Polynomial.h", 65,
                  typeid(::ROOT::Math::Polynomial), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLPolynomial_ShowMembers, &ROOTcLcLMathcLcLPolynomial_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Polynomial) );
      instance.SetNew(&new_ROOTcLcLMathcLcLPolynomial);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLPolynomial);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLPolynomial);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLPolynomial);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLPolynomial);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Polynomial*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Polynomial*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Polynomial*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLPolynomial_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Polynomial*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_Dictionary();
   static void delete_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p);
   static void destruct_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>) == sizeof(::ROOT::Shadow::ROOT::Math::ParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR));
      ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>", "include/Math/ParamFunction.h", 69,
                  typeid(::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_ShowMembers, &ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLDerivator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLDerivator_Dictionary();
   static void *new_ROOTcLcLMathcLcLDerivator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLDerivator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLDerivator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLDerivator(void *p);
   static void destruct_ROOTcLcLMathcLcLDerivator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Derivator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Derivator) == sizeof(::ROOT::Shadow::ROOT::Math::Derivator));
      ::ROOT::Math::Derivator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Derivator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Derivator", "include/Math/Derivator.h", 69,
                  typeid(::ROOT::Math::Derivator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLDerivator_ShowMembers, &ROOTcLcLMathcLcLDerivator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Derivator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLDerivator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLDerivator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLDerivator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLDerivator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLDerivator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Derivator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Derivator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Derivator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLDerivator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Derivator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLInterpolator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLInterpolator_Dictionary();
   static void *new_ROOTcLcLMathcLcLInterpolator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLInterpolator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLInterpolator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLInterpolator(void *p);
   static void destruct_ROOTcLcLMathcLcLInterpolator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Interpolator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Interpolator) == sizeof(::ROOT::Shadow::ROOT::Math::Interpolator));
      ::ROOT::Math::Interpolator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Interpolator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Interpolator", "include/Math/Interpolator.h", 63,
                  typeid(::ROOT::Math::Interpolator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLInterpolator_ShowMembers, &ROOTcLcLMathcLcLInterpolator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Interpolator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLInterpolator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLInterpolator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLInterpolator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLInterpolator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLInterpolator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Interpolator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Interpolator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Interpolator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLInterpolator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Interpolator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRootFinder_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRootFinder(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRootFinder(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRootFinder(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRootFinder(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRootFinder*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRootFinder) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRootFinder));
      ::ROOT::Math::GSLRootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRootFinder),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRootFinder", "include/Math/GSLRootFinder.h", 79,
                  typeid(::ROOT::Math::GSLRootFinder), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRootFinder_ShowMembers, &ROOTcLcLMathcLcLGSLRootFinder_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRootFinder) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRootFinder);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRootFinder);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRootFinder);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRootFinder);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRootFinder*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRootFinder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRootFinderDeriv_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRootFinderDeriv_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRootFinderDeriv(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRootFinderDeriv*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRootFinderDeriv) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRootFinderDeriv));
      ::ROOT::Math::GSLRootFinderDeriv *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRootFinderDeriv),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRootFinderDeriv", "include/Math/GSLRootFinderDeriv.h", 82,
                  typeid(::ROOT::Math::GSLRootFinderDeriv), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRootFinderDeriv_ShowMembers, &ROOTcLcLMathcLcLGSLRootFinderDeriv_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRootFinderDeriv) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRootFinderDeriv);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRootFinderDeriv);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRootFinderDeriv);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRootFinderDeriv);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRootFinderDeriv);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRootFinderDeriv*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRootFinderDeriv*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinderDeriv*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRootFinderDeriv_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinderDeriv*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
namespace Roots {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLRoots_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::Roots", 0 /*version*/, "include/Math/RootFinderAlgorithms.h", 51,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLRoots_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLRoots_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLBisection_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLBisection_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLBisection(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLBisection(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLBisection(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLBisection(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLBisection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::Bisection*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::Bisection) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::Bisection));
      ::ROOT::Math::Roots::Bisection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::Bisection),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::Bisection", "include/Math/RootFinderAlgorithms.h", 61,
                  typeid(::ROOT::Math::Roots::Bisection), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLBisection_ShowMembers, &ROOTcLcLMathcLcLRootscLcLBisection_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::Bisection) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLBisection);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLBisection);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLBisection);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLBisection);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLBisection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::Bisection*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::Bisection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Bisection*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLBisection_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Bisection*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLFalsePos_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLFalsePos_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLFalsePos(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::FalsePos*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::FalsePos) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::FalsePos));
      ::ROOT::Math::Roots::FalsePos *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::FalsePos),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::FalsePos", "include/Math/RootFinderAlgorithms.h", 83,
                  typeid(::ROOT::Math::Roots::FalsePos), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLFalsePos_ShowMembers, &ROOTcLcLMathcLcLRootscLcLFalsePos_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::FalsePos) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLFalsePos);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLFalsePos);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLFalsePos);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLFalsePos);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLFalsePos);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::FalsePos*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::FalsePos*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::FalsePos*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLFalsePos_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::FalsePos*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLBrent_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLBrent_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLBrent(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLBrent(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLBrent(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLBrent(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLBrent(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::Brent*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::Brent) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::Brent));
      ::ROOT::Math::Roots::Brent *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::Brent),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::Brent", "include/Math/RootFinderAlgorithms.h", 108,
                  typeid(::ROOT::Math::Roots::Brent), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLBrent_ShowMembers, &ROOTcLcLMathcLcLRootscLcLBrent_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::Brent) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLBrent);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLBrent);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLBrent);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLBrent);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLBrent);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::Brent*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::Brent*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Brent*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLBrent_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Brent*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLNewton_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLNewton_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLNewton(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLNewton(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLNewton(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLNewton(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLNewton(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::Newton*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::Newton) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::Newton));
      ::ROOT::Math::Roots::Newton *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::Newton),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::Newton", "include/Math/RootFinderAlgorithms.h", 136,
                  typeid(::ROOT::Math::Roots::Newton), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLNewton_ShowMembers, &ROOTcLcLMathcLcLRootscLcLNewton_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::Newton) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLNewton);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLNewton);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLNewton);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLNewton);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLNewton);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::Newton*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::Newton*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Newton*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLNewton_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Newton*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLSecant_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLSecant_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLSecant(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLSecant(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLSecant(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLSecant(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLSecant(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::Secant*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::Secant) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::Secant));
      ::ROOT::Math::Roots::Secant *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::Secant),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::Secant", "include/Math/RootFinderAlgorithms.h", 159,
                  typeid(::ROOT::Math::Roots::Secant), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLSecant_ShowMembers, &ROOTcLcLMathcLcLRootscLcLSecant_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::Secant) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLSecant);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLSecant);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLSecant);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLSecant);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLSecant);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::Secant*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::Secant*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Secant*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLSecant_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Secant*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLSteffenson_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRootscLcLSteffenson_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootscLcLSteffenson(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p);
   static void destruct_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Roots::Steffenson*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Roots::Steffenson) == sizeof(::ROOT::Shadow::ROOT::Math::Roots::Steffenson));
      ::ROOT::Math::Roots::Steffenson *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Roots::Steffenson),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Roots::Steffenson", "include/Math/RootFinderAlgorithms.h", 182,
                  typeid(::ROOT::Math::Roots::Steffenson), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRootscLcLSteffenson_ShowMembers, &ROOTcLcLMathcLcLRootscLcLSteffenson_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Roots::Steffenson) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootscLcLSteffenson);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootscLcLSteffenson);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootscLcLSteffenson);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootscLcLSteffenson);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootscLcLSteffenson);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Roots::Steffenson*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Roots::Steffenson*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Steffenson*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootscLcLSteffenson_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Steffenson*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
namespace Integration {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLIntegration_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::Integration", 0 /*version*/, "include/Math/IntegrationTypes.h", 44,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLIntegration_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLIntegration_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLGSLIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GSLIntegrator));
      ::ROOT::Math::GSLIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLIntegrator", "include/Math/GSLIntegrator.h", 104,
                  typeid(::ROOT::Math::GSLIntegrator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLIntegrator_ShowMembers, &ROOTcLcLMathcLcLGSLIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVegasParameters_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVegasParameters_Dictionary();
   static void *new_ROOTcLcLMathcLcLVegasParameters(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVegasParameters(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVegasParameters(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVegasParameters(void *p);
   static void destruct_ROOTcLcLMathcLcLVegasParameters(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VegasParameters*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VegasParameters) == sizeof(::ROOT::Shadow::ROOT::Math::VegasParameters));
      ::ROOT::Math::VegasParameters *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VegasParameters),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VegasParameters", "include/Math/MCParameters.h", 45,
                  typeid(::ROOT::Math::VegasParameters), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVegasParameters_ShowMembers, &ROOTcLcLMathcLcLVegasParameters_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VegasParameters) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVegasParameters);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVegasParameters);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVegasParameters);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVegasParameters);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVegasParameters);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VegasParameters*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VegasParameters*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VegasParameters*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVegasParameters_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VegasParameters*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLMiserParameters_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLMiserParameters_Dictionary();
   static void *new_ROOTcLcLMathcLcLMiserParameters(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLMiserParameters(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLMiserParameters(void *p);
   static void deleteArray_ROOTcLcLMathcLcLMiserParameters(void *p);
   static void destruct_ROOTcLcLMathcLcLMiserParameters(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::MiserParameters*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::MiserParameters) == sizeof(::ROOT::Shadow::ROOT::Math::MiserParameters));
      ::ROOT::Math::MiserParameters *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::MiserParameters),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::MiserParameters", "include/Math/MCParameters.h", 76,
                  typeid(::ROOT::Math::MiserParameters), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLMiserParameters_ShowMembers, &ROOTcLcLMathcLcLMiserParameters_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::MiserParameters) );
      instance.SetNew(&new_ROOTcLcLMathcLcLMiserParameters);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLMiserParameters);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLMiserParameters);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLMiserParameters);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLMiserParameters);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::MiserParameters*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::MiserParameters*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::MiserParameters*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLMiserParameters_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MiserParameters*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLMCIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLMCIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLMCIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLMCIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLMCIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLMCIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLMCIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLMCIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLMCIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GSLMCIntegrator));
      ::ROOT::Math::GSLMCIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLMCIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLMCIntegrator", "include/Math/GSLMCIntegrator.h", 95,
                  typeid(::ROOT::Math::GSLMCIntegrator), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLMCIntegrator_ShowMembers, &ROOTcLcLMathcLcLGSLMCIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLMCIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLMCIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLMCIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLMCIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLMCIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLMCIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLMCIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLMCIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLMCIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLMCIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMCIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
namespace Minim1D {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLMinim1D_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::Minim1D", 0 /*version*/, "include/Math/GSLMinimizer1D.h", 41,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLMinim1D_Dictionary, 0);
         return &instance;
      }
      // Insure that the inline function is _not_ optimized away by the compiler
      ::ROOT::TGenericClassInfo *(*_R__UNIQUE_(InitFunctionKeeper))() = &GenerateInitInstance;  
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLMinim1D_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLGSLMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLMinimizer1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLMinimizer1D(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLMinimizer1D(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLMinimizer1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLMinimizer1D(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLMinimizer1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLMinimizer1D*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLMinimizer1D) == sizeof(::ROOT::Shadow::ROOT::Math::GSLMinimizer1D));
      ::ROOT::Math::GSLMinimizer1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLMinimizer1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLMinimizer1D", "include/Math/GSLMinimizer1D.h", 81,
                  typeid(::ROOT::Math::GSLMinimizer1D), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLMinimizer1D_ShowMembers, &ROOTcLcLMathcLcLGSLMinimizer1D_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLMinimizer1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLMinimizer1D);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLMinimizer1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLMinimizer1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLMinimizer1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLMinimizer1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLMinimizer1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLMinimizer1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLMinimizer1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLChebyshev_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLChebyshev_Dictionary();
   static void delete_ROOTcLcLMathcLcLChebyshev(void *p);
   static void deleteArray_ROOTcLcLMathcLcLChebyshev(void *p);
   static void destruct_ROOTcLcLMathcLcLChebyshev(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Chebyshev*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Chebyshev) == sizeof(::ROOT::Shadow::ROOT::Math::Chebyshev));
      ::ROOT::Math::Chebyshev *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Chebyshev),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Chebyshev", "include/Math/Chebyshev.h", 77,
                  typeid(::ROOT::Math::Chebyshev), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLChebyshev_ShowMembers, &ROOTcLcLMathcLcLChebyshev_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Chebyshev) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLChebyshev);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLChebyshev);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLChebyshev);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Chebyshev*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Chebyshev*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Chebyshev*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLChebyshev_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Chebyshev*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRandomEngine_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRandomEngine_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRandomEngine(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRandomEngine(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRandomEngine(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRandomEngine(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRandomEngine(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRandomEngine*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRandomEngine) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRandomEngine));
      ::ROOT::Math::GSLRandomEngine *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRandomEngine),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRandomEngine", "include/Math/GSLRndmEngines.h", 63,
                  typeid(::ROOT::Math::GSLRandomEngine), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRandomEngine_ShowMembers, &ROOTcLcLMathcLcLGSLRandomEngine_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRandomEngine) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRandomEngine);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRandomEngine);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRandomEngine);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRandomEngine);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRandomEngine);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRandomEngine*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRandomEngine*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRandomEngine*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRandomEngine_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRandomEngine*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngMT_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngMT_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngMT(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngMT(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngMT(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngMT(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngMT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngMT*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngMT) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngMT));
      ::ROOT::Math::GSLRngMT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngMT),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngMT", "include/Math/GSLRndmEngines.h", 270,
                  typeid(::ROOT::Math::GSLRngMT), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngMT_ShowMembers, &ROOTcLcLMathcLcLGSLRngMT_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngMT) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngMT);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngMT);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngMT);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngMT);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngMT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngMT*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngMT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngMT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngMT_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngMT*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLux_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngRanLux_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngRanLux(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLux(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngRanLux(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLux(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLux(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngRanLux*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngRanLux) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngRanLux));
      ::ROOT::Math::GSLRngRanLux *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngRanLux),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngRanLux", "include/Math/GSLRndmEngines.h", 283,
                  typeid(::ROOT::Math::GSLRngRanLux), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngRanLux_ShowMembers, &ROOTcLcLMathcLcLGSLRngRanLux_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngRanLux) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngRanLux);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngRanLux);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngRanLux);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngRanLux);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngRanLux);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngRanLux*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngRanLux*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLux*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngRanLux_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLux*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxS1_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngRanLuxS1_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxS1(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngRanLuxS1*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngRanLuxS1) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngRanLuxS1));
      ::ROOT::Math::GSLRngRanLuxS1 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngRanLuxS1),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngRanLuxS1", "include/Math/GSLRndmEngines.h", 296,
                  typeid(::ROOT::Math::GSLRngRanLuxS1), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngRanLuxS1_ShowMembers, &ROOTcLcLMathcLcLGSLRngRanLuxS1_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngRanLuxS1) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngRanLuxS1);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngRanLuxS1);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngRanLuxS1);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS1);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngRanLuxS1);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngRanLuxS1*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngRanLuxS1*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS1*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngRanLuxS1_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS1*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxS2_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngRanLuxS2_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxS2(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngRanLuxS2*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngRanLuxS2) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngRanLuxS2));
      ::ROOT::Math::GSLRngRanLuxS2 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngRanLuxS2),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngRanLuxS2", "include/Math/GSLRndmEngines.h", 310,
                  typeid(::ROOT::Math::GSLRngRanLuxS2), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngRanLuxS2_ShowMembers, &ROOTcLcLMathcLcLGSLRngRanLuxS2_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngRanLuxS2) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngRanLuxS2);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngRanLuxS2);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngRanLuxS2);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS2);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngRanLuxS2);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngRanLuxS2*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngRanLuxS2*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS2*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngRanLuxS2_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS2*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxD1_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngRanLuxD1_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxD1(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngRanLuxD1*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngRanLuxD1) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngRanLuxD1));
      ::ROOT::Math::GSLRngRanLuxD1 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngRanLuxD1),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngRanLuxD1", "include/Math/GSLRndmEngines.h", 324,
                  typeid(::ROOT::Math::GSLRngRanLuxD1), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngRanLuxD1_ShowMembers, &ROOTcLcLMathcLcLGSLRngRanLuxD1_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngRanLuxD1) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngRanLuxD1);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngRanLuxD1);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngRanLuxD1);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD1);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngRanLuxD1);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngRanLuxD1*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngRanLuxD1*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD1*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngRanLuxD1_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD1*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxD2_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngRanLuxD2_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxD2(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngRanLuxD2*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngRanLuxD2) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngRanLuxD2));
      ::ROOT::Math::GSLRngRanLuxD2 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngRanLuxD2),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngRanLuxD2", "include/Math/GSLRndmEngines.h", 337,
                  typeid(::ROOT::Math::GSLRngRanLuxD2), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngRanLuxD2_ShowMembers, &ROOTcLcLMathcLcLGSLRngRanLuxD2_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngRanLuxD2) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngRanLuxD2);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngRanLuxD2);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngRanLuxD2);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD2);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngRanLuxD2);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngRanLuxD2*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngRanLuxD2*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD2*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngRanLuxD2_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD2*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngTaus_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngTaus_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngTaus(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngTaus(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngTaus(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngTaus(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngTaus(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngTaus*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngTaus) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngTaus));
      ::ROOT::Math::GSLRngTaus *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngTaus),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngTaus", "include/Math/GSLRndmEngines.h", 351,
                  typeid(::ROOT::Math::GSLRngTaus), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngTaus_ShowMembers, &ROOTcLcLMathcLcLGSLRngTaus_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngTaus) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngTaus);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngTaus);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngTaus);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngTaus);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngTaus);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngTaus*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngTaus*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngTaus*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngTaus_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngTaus*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngGFSR4_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLRngGFSR4_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLRngGFSR4(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLRngGFSR4(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLRngGFSR4(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLRngGFSR4(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLRngGFSR4(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLRngGFSR4*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLRngGFSR4) == sizeof(::ROOT::Shadow::ROOT::Math::GSLRngGFSR4));
      ::ROOT::Math::GSLRngGFSR4 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLRngGFSR4),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLRngGFSR4", "include/Math/GSLRndmEngines.h", 363,
                  typeid(::ROOT::Math::GSLRngGFSR4), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLRngGFSR4_ShowMembers, &ROOTcLcLMathcLcLGSLRngGFSR4_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLRngGFSR4) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLRngGFSR4);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLRngGFSR4);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLRngGFSR4);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLRngGFSR4);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLRngGFSR4);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLRngGFSR4*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLRngGFSR4*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngGFSR4*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLRngGFSR4_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngGFSR4*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLKelvinFunctions_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLKelvinFunctions_Dictionary();
   static void *new_ROOTcLcLMathcLcLKelvinFunctions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLKelvinFunctions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLKelvinFunctions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLKelvinFunctions(void *p);
   static void destruct_ROOTcLcLMathcLcLKelvinFunctions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::KelvinFunctions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::KelvinFunctions) == sizeof(::ROOT::Shadow::ROOT::Math::KelvinFunctions));
      ::ROOT::Math::KelvinFunctions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::KelvinFunctions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::KelvinFunctions", "include/Math/KelvinFunctions.h", 39,
                  typeid(::ROOT::Math::KelvinFunctions), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLKelvinFunctions_ShowMembers, &ROOTcLcLMathcLcLKelvinFunctions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::KelvinFunctions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLKelvinFunctions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLKelvinFunctions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLKelvinFunctions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLKelvinFunctions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLKelvinFunctions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::KelvinFunctions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::KelvinFunctions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::KelvinFunctions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLKelvinFunctions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::KelvinFunctions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLMinimizer_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLMinimizer(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLMinimizer(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLMinimizer*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLMinimizer) == sizeof(::ROOT::Shadow::ROOT::Math::GSLMinimizer));
      ::ROOT::Math::GSLMinimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLMinimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLMinimizer", "include/Math/GSLMinimizer.h", 94,
                  typeid(::ROOT::Math::GSLMinimizer), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLMinimizer_ShowMembers, &ROOTcLcLMathcLcLGSLMinimizer_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLMinimizer) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLMinimizer);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLMinimizer);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLMinimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLMinimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLLSResidualFunc_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLLSResidualFunc_Dictionary();
   static void *new_ROOTcLcLMathcLcLLSResidualFunc(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLLSResidualFunc(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLLSResidualFunc(void *p);
   static void deleteArray_ROOTcLcLMathcLcLLSResidualFunc(void *p);
   static void destruct_ROOTcLcLMathcLcLLSResidualFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::LSResidualFunc*)
   {
      ::ROOT::Math::LSResidualFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::LSResidualFunc),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::LSResidualFunc", "include/Math/GSLNLSMinimizer.h", 77,
                  typeid(::ROOT::Math::LSResidualFunc), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLLSResidualFunc_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::LSResidualFunc) );
      instance.SetNew(&new_ROOTcLcLMathcLcLLSResidualFunc);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLLSResidualFunc);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLLSResidualFunc);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLLSResidualFunc);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLLSResidualFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::LSResidualFunc*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::LSResidualFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::LSResidualFunc*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLLSResidualFunc_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::LSResidualFunc*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLNLSMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLNLSMinimizer_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLNLSMinimizer(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLNLSMinimizer*)
   {
      ::ROOT::Math::GSLNLSMinimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLNLSMinimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLNLSMinimizer", "include/Math/GSLNLSMinimizer.h", 162,
                  typeid(::ROOT::Math::GSLNLSMinimizer), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLGSLNLSMinimizer_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::GSLNLSMinimizer) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLNLSMinimizer);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLNLSMinimizer);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLNLSMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLNLSMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLNLSMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLNLSMinimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLNLSMinimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLNLSMinimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLNLSMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLNLSMinimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnFunc_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLSimAnFunc_Dictionary();
   static void delete_ROOTcLcLMathcLcLGSLSimAnFunc(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnFunc(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLSimAnFunc(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLSimAnFunc*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLSimAnFunc) == sizeof(::ROOT::Shadow::ROOT::Math::GSLSimAnFunc));
      ::ROOT::Math::GSLSimAnFunc *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLSimAnFunc),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLSimAnFunc", "include/Math/GSLSimAnnealing.h", 50,
                  typeid(::ROOT::Math::GSLSimAnFunc), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLSimAnFunc_ShowMembers, &ROOTcLcLMathcLcLGSLSimAnFunc_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLSimAnFunc) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLSimAnFunc);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLSimAnFunc);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLSimAnFunc);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLSimAnFunc*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLSimAnFunc*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnFunc*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLSimAnFunc_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnFunc*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnParams_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLSimAnParams_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLSimAnParams(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnParams(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLSimAnParams(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnParams(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLSimAnParams(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLSimAnParams*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLSimAnParams) == sizeof(::ROOT::Shadow::ROOT::Math::GSLSimAnParams));
      ::ROOT::Math::GSLSimAnParams *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLSimAnParams),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLSimAnParams", "include/Math/GSLSimAnnealing.h", 161,
                  typeid(::ROOT::Math::GSLSimAnParams), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLSimAnParams_ShowMembers, &ROOTcLcLMathcLcLGSLSimAnParams_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLSimAnParams) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLSimAnParams);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLSimAnParams);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLSimAnParams);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLSimAnParams);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLSimAnParams);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLSimAnParams*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLSimAnParams*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnParams*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLSimAnParams_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnParams*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnnealing_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLSimAnnealing_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLSimAnnealing(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnnealing(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLSimAnnealing(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnnealing(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLSimAnnealing(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLSimAnnealing*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLSimAnnealing) == sizeof(::ROOT::Shadow::ROOT::Math::GSLSimAnnealing));
      ::ROOT::Math::GSLSimAnnealing *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLSimAnnealing),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLSimAnnealing", "include/Math/GSLSimAnnealing.h", 193,
                  typeid(::ROOT::Math::GSLSimAnnealing), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLSimAnnealing_ShowMembers, &ROOTcLcLMathcLcLGSLSimAnnealing_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLSimAnnealing) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLSimAnnealing);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLSimAnnealing);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLSimAnnealing);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLSimAnnealing);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLSimAnnealing);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLSimAnnealing*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLSimAnnealing*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnnealing*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLSimAnnealing_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnnealing*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLGSLSimAnMinimizer_Dictionary();
   static void *new_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnMinimizer(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GSLSimAnMinimizer*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GSLSimAnMinimizer) == sizeof(::ROOT::Shadow::ROOT::Math::GSLSimAnMinimizer));
      ::ROOT::Math::GSLSimAnMinimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GSLSimAnMinimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GSLSimAnMinimizer", "include/Math/GSLSimAnMinimizer.h", 78,
                  typeid(::ROOT::Math::GSLSimAnMinimizer), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLGSLSimAnMinimizer_ShowMembers, &ROOTcLcLMathcLcLGSLSimAnMinimizer_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GSLSimAnMinimizer) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGSLSimAnMinimizer);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGSLSimAnMinimizer);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGSLSimAnMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGSLSimAnMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGSLSimAnMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GSLSimAnMinimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GSLSimAnMinimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnMinimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGSLSimAnMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnMinimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilov_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilov_Dictionary();
   static void delete_ROOTcLcLMathcLcLVavilov(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilov(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilov(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Vavilov*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Vavilov) == sizeof(::ROOT::Shadow::ROOT::Math::Vavilov));
      ::ROOT::Math::Vavilov *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Vavilov),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Vavilov", "include/Math/Vavilov.h", 121,
                  typeid(::ROOT::Math::Vavilov), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilov_ShowMembers, &ROOTcLcLMathcLcLVavilov_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Vavilov) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilov);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilov);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilov);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Vavilov*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Vavilov*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Vavilov*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilov_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Vavilov*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurate_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilovAccurate_Dictionary();
   static void *new_ROOTcLcLMathcLcLVavilovAccurate(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurate(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVavilovAccurate(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurate(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilovAccurate(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VavilovAccurate*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VavilovAccurate) == sizeof(::ROOT::Shadow::ROOT::Math::VavilovAccurate));
      ::ROOT::Math::VavilovAccurate *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VavilovAccurate),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VavilovAccurate", "include/Math/VavilovAccurate.h", 131,
                  typeid(::ROOT::Math::VavilovAccurate), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilovAccurate_ShowMembers, &ROOTcLcLMathcLcLVavilovAccurate_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VavilovAccurate) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVavilovAccurate);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVavilovAccurate);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilovAccurate);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilovAccurate);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilovAccurate);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VavilovAccurate*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VavilovAccurate*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurate*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilovAccurate_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurate*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccuratePdf_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilovAccuratePdf_Dictionary();
   static void *new_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVavilovAccuratePdf(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VavilovAccuratePdf*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VavilovAccuratePdf) == sizeof(::ROOT::Shadow::ROOT::Math::VavilovAccuratePdf));
      ::ROOT::Math::VavilovAccuratePdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VavilovAccuratePdf),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VavilovAccuratePdf", "include/Math/VavilovAccuratePdf.h", 70,
                  typeid(::ROOT::Math::VavilovAccuratePdf), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilovAccuratePdf_ShowMembers, &ROOTcLcLMathcLcLVavilovAccuratePdf_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VavilovAccuratePdf) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVavilovAccuratePdf);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVavilovAccuratePdf);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilovAccuratePdf);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilovAccuratePdf);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilovAccuratePdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VavilovAccuratePdf*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VavilovAccuratePdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccuratePdf*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilovAccuratePdf_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccuratePdf*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurateCdf_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilovAccurateCdf_Dictionary();
   static void *new_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurateCdf(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VavilovAccurateCdf*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VavilovAccurateCdf) == sizeof(::ROOT::Shadow::ROOT::Math::VavilovAccurateCdf));
      ::ROOT::Math::VavilovAccurateCdf *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VavilovAccurateCdf),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VavilovAccurateCdf", "include/Math/VavilovAccurateCdf.h", 73,
                  typeid(::ROOT::Math::VavilovAccurateCdf), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilovAccurateCdf_ShowMembers, &ROOTcLcLMathcLcLVavilovAccurateCdf_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VavilovAccurateCdf) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVavilovAccurateCdf);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVavilovAccurateCdf);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilovAccurateCdf);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilovAccurateCdf);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilovAccurateCdf);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VavilovAccurateCdf*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VavilovAccurateCdf*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateCdf*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilovAccurateCdf_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateCdf*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurateQuantile_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilovAccurateQuantile_Dictionary();
   static void *new_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurateQuantile(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VavilovAccurateQuantile*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VavilovAccurateQuantile) == sizeof(::ROOT::Shadow::ROOT::Math::VavilovAccurateQuantile));
      ::ROOT::Math::VavilovAccurateQuantile *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VavilovAccurateQuantile),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VavilovAccurateQuantile", "include/Math/VavilovAccurateQuantile.h", 73,
                  typeid(::ROOT::Math::VavilovAccurateQuantile), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilovAccurateQuantile_ShowMembers, &ROOTcLcLMathcLcLVavilovAccurateQuantile_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VavilovAccurateQuantile) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVavilovAccurateQuantile);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVavilovAccurateQuantile);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilovAccurateQuantile);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilovAccurateQuantile);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilovAccurateQuantile);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VavilovAccurateQuantile*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VavilovAccurateQuantile*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateQuantile*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilovAccurateQuantile_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateQuantile*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVavilovFast_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLVavilovFast_Dictionary();
   static void *new_ROOTcLcLMathcLcLVavilovFast(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLVavilovFast(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLVavilovFast(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVavilovFast(void *p);
   static void destruct_ROOTcLcLMathcLcLVavilovFast(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VavilovFast*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VavilovFast) == sizeof(::ROOT::Shadow::ROOT::Math::VavilovFast));
      ::ROOT::Math::VavilovFast *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VavilovFast),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VavilovFast", "include/Math/VavilovFast.h", 116,
                  typeid(::ROOT::Math::VavilovFast), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLVavilovFast_ShowMembers, &ROOTcLcLMathcLcLVavilovFast_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VavilovFast) );
      instance.SetNew(&new_ROOTcLcLMathcLcLVavilovFast);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLVavilovFast);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVavilovFast);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVavilovFast);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVavilovFast);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VavilovFast*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VavilovFast*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VavilovFast*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVavilovFast_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovFast*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngMT>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngMTgR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngMT> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngMT>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngMT>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngMT>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngMT>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngTaus>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngTausgR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngTaus> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngTaus>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngTaus>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngTaus>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngTaus>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngRanLux>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_Dictionary();
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p);
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>) == sizeof(::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
      ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>", "include/Math/Random.h", 58,
                  typeid(::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_ShowMembers, &ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>.
      typedef ::ROOT::Shadow::ROOT::Math::ParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNpar", &sobj->fNpar);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fParams", (void*)&sobj->fParams);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fParams, "fParams.", false);
      R__insp.GenericShowMembers("ROOT::Math::IParametricGradFunctionOneDim", ( ::ROOT::Math::IParametricGradFunctionOneDim * )( (::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) obj ), false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p) {
      delete ((::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p) {
      delete [] ((::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void *p) {
      typedef ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLPolynomial_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Polynomial.
      typedef ::ROOT::Shadow::ROOT::Math::Polynomial ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Polynomial*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOrder", &sobj->fOrder);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDerived_params", (void*)&sobj->fDerived_params);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fDerived_params, "fDerived_params.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRoots", (void*)&sobj->fRoots);
      R__insp.InspectMember("vector<std::complex<double> >", (void*)&sobj->fRoots, "fRoots.", false);
      R__insp.GenericShowMembers("ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>", ( ::ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> * )( (::ROOT::Math::Polynomial*) obj ), false);
      R__insp.GenericShowMembers("ROOT::Math::IGradientOneDim", ( ::ROOT::Math::IGradientOneDim * )( (::ROOT::Math::Polynomial*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLPolynomial(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Polynomial : new ::ROOT::Math::Polynomial;
   }
   static void *newArray_ROOTcLcLMathcLcLPolynomial(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Polynomial[nElements] : new ::ROOT::Math::Polynomial[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLPolynomial(void *p) {
      delete ((::ROOT::Math::Polynomial*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLPolynomial(void *p) {
      delete [] ((::ROOT::Math::Polynomial*)p);
   }
   static void destruct_ROOTcLcLMathcLcLPolynomial(void *p) {
      typedef ::ROOT::Math::Polynomial current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Polynomial

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLChebyshev_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Chebyshev.
      typedef ::ROOT::Shadow::ROOT::Math::Chebyshev ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Chebyshev*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOrder", &sobj->fOrder);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fSeries", &sobj->fSeries);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLChebyshev(void *p) {
      delete ((::ROOT::Math::Chebyshev*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLChebyshev(void *p) {
      delete [] ((::ROOT::Math::Chebyshev*)p);
   }
   static void destruct_ROOTcLcLMathcLcLChebyshev(void *p) {
      typedef ::ROOT::Math::Chebyshev current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Chebyshev

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLDerivator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Derivator.
      typedef ::ROOT::Shadow::ROOT::Math::Derivator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Derivator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fDerivator", &sobj->fDerivator);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLDerivator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Derivator : new ::ROOT::Math::Derivator;
   }
   static void *newArray_ROOTcLcLMathcLcLDerivator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Derivator[nElements] : new ::ROOT::Math::Derivator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLDerivator(void *p) {
      delete ((::ROOT::Math::Derivator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLDerivator(void *p) {
      delete [] ((::ROOT::Math::Derivator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLDerivator(void *p) {
      typedef ::ROOT::Math::Derivator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Derivator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilov_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Vavilov.
      typedef ::ROOT::Shadow::ROOT::Math::Vavilov ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Vavilov*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilov(void *p) {
      delete ((::ROOT::Math::Vavilov*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilov(void *p) {
      delete [] ((::ROOT::Math::Vavilov*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilov(void *p) {
      typedef ::ROOT::Math::Vavilov current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Vavilov

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurate_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VavilovAccurate.
      typedef ::ROOT::Shadow::ROOT::Math::VavilovAccurate ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurate*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fH[8]", sobj->fH);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fT0", &sobj->fT0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fT1", &sobj->fT1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fT", &sobj->fT);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOmega", &sobj->fOmega);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fA_pdf[501]", sobj->fA_pdf);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fB_pdf[501]", sobj->fB_pdf);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fA_cdf[501]", sobj->fA_cdf);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fB_cdf[501]", sobj->fB_cdf);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fX0", &sobj->fX0);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fKappa", &sobj->fKappa);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBeta2", &sobj->fBeta2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEpsilonPM", &sobj->fEpsilonPM);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEpsilon", &sobj->fEpsilon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fQuantileInit", &sobj->fQuantileInit);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNQuant", &sobj->fNQuant);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fQuant[32]", sobj->fQuant);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLambda[32]", sobj->fLambda);
      R__insp.GenericShowMembers("ROOT::Math::Vavilov", ( ::ROOT::Math::Vavilov * )( (::ROOT::Math::VavilovAccurate*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVavilovAccurate(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurate : new ::ROOT::Math::VavilovAccurate;
   }
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurate(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurate[nElements] : new ::ROOT::Math::VavilovAccurate[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilovAccurate(void *p) {
      delete ((::ROOT::Math::VavilovAccurate*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurate(void *p) {
      delete [] ((::ROOT::Math::VavilovAccurate*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilovAccurate(void *p) {
      typedef ::ROOT::Math::VavilovAccurate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VavilovAccurate

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilovFast_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VavilovFast.
      typedef ::ROOT::Shadow::ROOT::Math::VavilovFast ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovFast*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fKappa", &sobj->fKappa);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBeta2", &sobj->fBeta2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAC[14]", sobj->fAC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fHC[9]", sobj->fHC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fWCM[201]", sobj->fWCM);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fItype", &sobj->fItype);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNpt", &sobj->fNpt);
      R__insp.GenericShowMembers("ROOT::Math::Vavilov", ( ::ROOT::Math::Vavilov * )( (::ROOT::Math::VavilovFast*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVavilovFast(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovFast : new ::ROOT::Math::VavilovFast;
   }
   static void *newArray_ROOTcLcLMathcLcLVavilovFast(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovFast[nElements] : new ::ROOT::Math::VavilovFast[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilovFast(void *p) {
      delete ((::ROOT::Math::VavilovFast*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilovFast(void *p) {
      delete [] ((::ROOT::Math::VavilovFast*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilovFast(void *p) {
      typedef ::ROOT::Math::VavilovFast current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VavilovFast

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccuratePdf_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VavilovAccuratePdf.
      typedef ::ROOT::Shadow::ROOT::Math::VavilovAccuratePdf ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccuratePdf*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fP[5]", sobj->fP);
      R__insp.GenericShowMembers("ROOT::Math::IParametricFunctionOneDim", ( ::ROOT::Math::IParametricFunctionOneDim * )( (::ROOT::Math::VavilovAccuratePdf*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccuratePdf : new ::ROOT::Math::VavilovAccuratePdf;
   }
   static void *newArray_ROOTcLcLMathcLcLVavilovAccuratePdf(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccuratePdf[nElements] : new ::ROOT::Math::VavilovAccuratePdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p) {
      delete ((::ROOT::Math::VavilovAccuratePdf*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p) {
      delete [] ((::ROOT::Math::VavilovAccuratePdf*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilovAccuratePdf(void *p) {
      typedef ::ROOT::Math::VavilovAccuratePdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VavilovAccuratePdf

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurateCdf_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VavilovAccurateCdf.
      typedef ::ROOT::Shadow::ROOT::Math::VavilovAccurateCdf ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateCdf*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fP[5]", sobj->fP);
      R__insp.GenericShowMembers("ROOT::Math::IParametricFunctionOneDim", ( ::ROOT::Math::IParametricFunctionOneDim * )( (::ROOT::Math::VavilovAccurateCdf*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurateCdf : new ::ROOT::Math::VavilovAccurateCdf;
   }
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurateCdf(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurateCdf[nElements] : new ::ROOT::Math::VavilovAccurateCdf[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p) {
      delete ((::ROOT::Math::VavilovAccurateCdf*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p) {
      delete [] ((::ROOT::Math::VavilovAccurateCdf*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilovAccurateCdf(void *p) {
      typedef ::ROOT::Math::VavilovAccurateCdf current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VavilovAccurateCdf

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVavilovAccurateQuantile_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VavilovAccurateQuantile.
      typedef ::ROOT::Shadow::ROOT::Math::VavilovAccurateQuantile ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VavilovAccurateQuantile*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fP[5]", sobj->fP);
      R__insp.GenericShowMembers("ROOT::Math::IParametricFunctionOneDim", ( ::ROOT::Math::IParametricFunctionOneDim * )( (::ROOT::Math::VavilovAccurateQuantile*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurateQuantile : new ::ROOT::Math::VavilovAccurateQuantile;
   }
   static void *newArray_ROOTcLcLMathcLcLVavilovAccurateQuantile(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VavilovAccurateQuantile[nElements] : new ::ROOT::Math::VavilovAccurateQuantile[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p) {
      delete ((::ROOT::Math::VavilovAccurateQuantile*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p) {
      delete [] ((::ROOT::Math::VavilovAccurateQuantile*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVavilovAccurateQuantile(void *p) {
      typedef ::ROOT::Math::VavilovAccurateQuantile current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VavilovAccurateQuantile

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GSLIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLIntegrator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fType", &sobj->fType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRule", &sobj->fRule);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAbsTol", &sobj->fAbsTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRelTol", &sobj->fRelTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSize", &sobj->fSize);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMaxIntervals", &sobj->fMaxIntervals);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fResult", &sobj->fResult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fError", &sobj->fError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNEval", &sobj->fNEval);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fWorkspace", &sobj->fWorkspace);
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegratorOneDim", ( ::ROOT::Math::VirtualIntegratorOneDim * )( (::ROOT::Math::GSLIntegrator*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLIntegrator : new ::ROOT::Math::GSLIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLIntegrator[nElements] : new ::ROOT::Math::GSLIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLIntegrator(void *p) {
      delete ((::ROOT::Math::GSLIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLIntegrator(void *p) {
      delete [] ((::ROOT::Math::GSLIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLIntegrator(void *p) {
      typedef ::ROOT::Math::GSLIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLMinimizer1D.
      typedef ::ROOT::Shadow::ROOT::Math::GSLMinimizer1D ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer1D*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXmin", &sobj->fXmin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXlow", &sobj->fXlow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXup", &sobj->fXup);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMin", &sobj->fMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLow", &sobj->fLow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fUp", &sobj->fUp);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIter", &sobj->fIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIsSet", &sobj->fIsSet);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fMinimizer", &sobj->fMinimizer);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.GenericShowMembers("ROOT::Math::IMinimizer1D", ( ::ROOT::Math::IMinimizer1D * )( (::ROOT::Math::GSLMinimizer1D*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLMinimizer1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMinimizer1D : new ::ROOT::Math::GSLMinimizer1D;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLMinimizer1D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMinimizer1D[nElements] : new ::ROOT::Math::GSLMinimizer1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLMinimizer1D(void *p) {
      delete ((::ROOT::Math::GSLMinimizer1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLMinimizer1D(void *p) {
      delete [] ((::ROOT::Math::GSLMinimizer1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLMinimizer1D(void *p) {
      typedef ::ROOT::Math::GSLMinimizer1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLMinimizer1D

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLInterpolator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Interpolator.
      typedef ::ROOT::Shadow::ROOT::Math::Interpolator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Interpolator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fInterp", &sobj->fInterp);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLInterpolator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Interpolator : new ::ROOT::Math::Interpolator;
   }
   static void *newArray_ROOTcLcLMathcLcLInterpolator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Interpolator[nElements] : new ::ROOT::Math::Interpolator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLInterpolator(void *p) {
      delete ((::ROOT::Math::Interpolator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLInterpolator(void *p) {
      delete [] ((::ROOT::Math::Interpolator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLInterpolator(void *p) {
      typedef ::ROOT::Math::Interpolator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Interpolator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRandomEngine_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRandomEngine.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRandomEngine ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRandomEngine*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fRng", &sobj->fRng);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCurTime", &sobj->fCurTime);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRandomEngine(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRandomEngine : new ::ROOT::Math::GSLRandomEngine;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRandomEngine(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRandomEngine[nElements] : new ::ROOT::Math::GSLRandomEngine[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRandomEngine(void *p) {
      delete ((::ROOT::Math::GSLRandomEngine*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRandomEngine(void *p) {
      delete [] ((::ROOT::Math::GSLRandomEngine*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRandomEngine(void *p) {
      typedef ::ROOT::Math::GSLRandomEngine current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRandomEngine

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngMT_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngMT.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngMT ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngMT*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngMT*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngMT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngMT : new ::ROOT::Math::GSLRngMT;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngMT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngMT[nElements] : new ::ROOT::Math::GSLRngMT[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngMT(void *p) {
      delete ((::ROOT::Math::GSLRngMT*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngMT(void *p) {
      delete [] ((::ROOT::Math::GSLRngMT*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngMT(void *p) {
      typedef ::ROOT::Math::GSLRngMT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngMT

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngTaus_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngTaus.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngTaus ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngTaus*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngTaus*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngTaus(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngTaus : new ::ROOT::Math::GSLRngTaus;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngTaus(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngTaus[nElements] : new ::ROOT::Math::GSLRngTaus[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngTaus(void *p) {
      delete ((::ROOT::Math::GSLRngTaus*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngTaus(void *p) {
      delete [] ((::ROOT::Math::GSLRngTaus*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngTaus(void *p) {
      typedef ::ROOT::Math::GSLRngTaus current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngTaus

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLux_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngRanLux.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngRanLux ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLux*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngRanLux*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngRanLux(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLux : new ::ROOT::Math::GSLRngRanLux;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLux(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLux[nElements] : new ::ROOT::Math::GSLRngRanLux[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngRanLux(void *p) {
      delete ((::ROOT::Math::GSLRngRanLux*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLux(void *p) {
      delete [] ((::ROOT::Math::GSLRngRanLux*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLux(void *p) {
      typedef ::ROOT::Math::GSLRngRanLux current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngRanLux

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxS1_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngRanLuxS1.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngRanLuxS1 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS1*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngRanLuxS1*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxS1 : new ::ROOT::Math::GSLRngRanLuxS1;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxS1(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxS1[nElements] : new ::ROOT::Math::GSLRngRanLuxS1[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p) {
      delete ((::ROOT::Math::GSLRngRanLuxS1*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p) {
      delete [] ((::ROOT::Math::GSLRngRanLuxS1*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxS1(void *p) {
      typedef ::ROOT::Math::GSLRngRanLuxS1 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngRanLuxS1

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxS2_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngRanLuxS2.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngRanLuxS2 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxS2*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngRanLuxS2*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxS2 : new ::ROOT::Math::GSLRngRanLuxS2;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxS2(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxS2[nElements] : new ::ROOT::Math::GSLRngRanLuxS2[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p) {
      delete ((::ROOT::Math::GSLRngRanLuxS2*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p) {
      delete [] ((::ROOT::Math::GSLRngRanLuxS2*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxS2(void *p) {
      typedef ::ROOT::Math::GSLRngRanLuxS2 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngRanLuxS2

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxD1_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngRanLuxD1.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngRanLuxD1 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD1*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngRanLuxD1*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxD1 : new ::ROOT::Math::GSLRngRanLuxD1;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxD1(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxD1[nElements] : new ::ROOT::Math::GSLRngRanLuxD1[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p) {
      delete ((::ROOT::Math::GSLRngRanLuxD1*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p) {
      delete [] ((::ROOT::Math::GSLRngRanLuxD1*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxD1(void *p) {
      typedef ::ROOT::Math::GSLRngRanLuxD1 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngRanLuxD1

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngRanLuxD2_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngRanLuxD2.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngRanLuxD2 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngRanLuxD2*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngRanLuxD2*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxD2 : new ::ROOT::Math::GSLRngRanLuxD2;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngRanLuxD2(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngRanLuxD2[nElements] : new ::ROOT::Math::GSLRngRanLuxD2[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p) {
      delete ((::ROOT::Math::GSLRngRanLuxD2*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p) {
      delete [] ((::ROOT::Math::GSLRngRanLuxD2*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngRanLuxD2(void *p) {
      typedef ::ROOT::Math::GSLRngRanLuxD2 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngRanLuxD2

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRngGFSR4_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRngGFSR4.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRngGFSR4 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRngGFSR4*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRandomEngine", ( ::ROOT::Math::GSLRandomEngine * )( (::ROOT::Math::GSLRngGFSR4*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRngGFSR4(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngGFSR4 : new ::ROOT::Math::GSLRngGFSR4;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRngGFSR4(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRngGFSR4[nElements] : new ::ROOT::Math::GSLRngGFSR4[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRngGFSR4(void *p) {
      delete ((::ROOT::Math::GSLRngGFSR4*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRngGFSR4(void *p) {
      delete [] ((::ROOT::Math::GSLRngGFSR4*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRngGFSR4(void *p) {
      typedef ::ROOT::Math::GSLRngGFSR4 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRngGFSR4

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngMT>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngMTgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngMT", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngMT> : new ::ROOT::Math::Random<ROOT::Math::GSLRngMT>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngMT>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngMT>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngMT>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngMT> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngMT>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngTaus>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngTausgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngTaus", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngTaus> : new ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngTaus> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngTaus>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngRanLux>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngRanLux", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux> : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngRanLux>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngRanLuxS1", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngRanLuxS2", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngRanLuxD1", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngRanLuxD2", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>.
      typedef ::ROOT::Shadow::ROOT::Math::RandomlEROOTcLcLMathcLcLGSLRngGFSR4gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fEngine", (void*)&sobj->fEngine);
      R__insp.InspectMember("ROOT::Math::GSLRngGFSR4", (void*)&sobj->fEngine, "fEngine.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> : new ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>;
   }
   static void *newArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>[nElements] : new ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p) {
      delete ((::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p) {
      delete [] ((::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void *p) {
      typedef ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLKelvinFunctions_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::KelvinFunctions.
      typedef ::ROOT::Shadow::ROOT::Math::KelvinFunctions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::KelvinFunctions*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLKelvinFunctions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::KelvinFunctions : new ::ROOT::Math::KelvinFunctions;
   }
   static void *newArray_ROOTcLcLMathcLcLKelvinFunctions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::KelvinFunctions[nElements] : new ::ROOT::Math::KelvinFunctions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLKelvinFunctions(void *p) {
      delete ((::ROOT::Math::KelvinFunctions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLKelvinFunctions(void *p) {
      delete [] ((::ROOT::Math::KelvinFunctions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLKelvinFunctions(void *p) {
      typedef ::ROOT::Math::KelvinFunctions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::KelvinFunctions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLMinimizer.
      typedef ::ROOT::Shadow::ROOT::Math::GSLMinimizer ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMinimizer*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDim", &sobj->fDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fGSLMultiMin", &sobj->fGSLMultiMin);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fObjFunc", &sobj->fObjFunc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMinVal", &sobj->fMinVal);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fLSTolerance", &sobj->fLSTolerance);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fValues", (void*)&sobj->fValues);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fValues, "fValues.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSteps", (void*)&sobj->fSteps);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fSteps, "fSteps.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNames", (void*)&sobj->fNames);
      R__insp.InspectMember("vector<std::string>", (void*)&sobj->fNames, "fNames.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fVarTypes", (void*)&sobj->fVarTypes);
      R__insp.InspectMember("vector<ROOT::Math::EMinimVariableType>", (void*)&sobj->fVarTypes, "fVarTypes.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBounds", (void*)&sobj->fBounds);
      R__insp.InspectMember("map<unsigned int,std::pair<double,double> >", (void*)&sobj->fBounds, "fBounds.", false);
      R__insp.GenericShowMembers("ROOT::Math::Minimizer", ( ::ROOT::Math::Minimizer * )( (::ROOT::Math::GSLMinimizer*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLMinimizer(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMinimizer : new ::ROOT::Math::GSLMinimizer;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLMinimizer(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMinimizer[nElements] : new ::ROOT::Math::GSLMinimizer[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLMinimizer(void *p) {
      delete ((::ROOT::Math::GSLMinimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLMinimizer(void *p) {
      delete [] ((::ROOT::Math::GSLMinimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLMinimizer(void *p) {
      typedef ::ROOT::Math::GSLMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLMinimizer

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLSimAnMinimizer.
      typedef ::ROOT::Shadow::ROOT::Math::GSLSimAnMinimizer ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnMinimizer*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDim", &sobj->fDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fOwnFunc", &sobj->fOwnFunc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSolver", (void*)&sobj->fSolver);
      R__insp.InspectMember("ROOT::Math::GSLSimAnnealing", (void*)&sobj->fSolver, "fSolver.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fObjFunc", &sobj->fObjFunc);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fMinVal", &sobj->fMinVal);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fValues", (void*)&sobj->fValues);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fValues, "fValues.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fSteps", (void*)&sobj->fSteps);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fSteps, "fSteps.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fNames", (void*)&sobj->fNames);
      R__insp.InspectMember("vector<std::string>", (void*)&sobj->fNames, "fNames.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fVarTypes", (void*)&sobj->fVarTypes);
      R__insp.InspectMember("vector<ROOT::Math::EMinimVariableType>", (void*)&sobj->fVarTypes, "fVarTypes.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fBounds", (void*)&sobj->fBounds);
      R__insp.InspectMember("map<unsigned int,std::pair<double,double> >", (void*)&sobj->fBounds, "fBounds.", false);
      R__insp.GenericShowMembers("ROOT::Math::Minimizer", ( ::ROOT::Math::Minimizer * )( (::ROOT::Math::GSLSimAnMinimizer*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnMinimizer : new ::ROOT::Math::GSLSimAnMinimizer;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnMinimizer(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnMinimizer[nElements] : new ::ROOT::Math::GSLSimAnMinimizer[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p) {
      delete ((::ROOT::Math::GSLSimAnMinimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p) {
      delete [] ((::ROOT::Math::GSLSimAnMinimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLSimAnMinimizer(void *p) {
      typedef ::ROOT::Math::GSLSimAnMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLSimAnMinimizer

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnFunc_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLSimAnFunc.
      typedef ::ROOT::Shadow::ROOT::Math::GSLSimAnFunc ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnFunc*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fX", (void*)&sobj->fX);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fX, "fX.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fScale", (void*)&sobj->fScale);
      R__insp.InspectMember("vector<double>", (void*)&sobj->fScale, "fScale.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunc", &sobj->fFunc);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLSimAnFunc(void *p) {
      delete ((::ROOT::Math::GSLSimAnFunc*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnFunc(void *p) {
      delete [] ((::ROOT::Math::GSLSimAnFunc*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLSimAnFunc(void *p) {
      typedef ::ROOT::Math::GSLSimAnFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLSimAnFunc

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnParams_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLSimAnParams.
      typedef ::ROOT::Shadow::ROOT::Math::GSLSimAnParams ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnParams*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "n_tries", &sobj->n_tries);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "iters_fixed_T", &sobj->iters_fixed_T);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "step_size", &sobj->step_size);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "k", &sobj->k);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "t_initial", &sobj->t_initial);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mu", &sobj->mu);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "t_min", &sobj->t_min);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLSimAnParams(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnParams : new ::ROOT::Math::GSLSimAnParams;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnParams(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnParams[nElements] : new ::ROOT::Math::GSLSimAnParams[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLSimAnParams(void *p) {
      delete ((::ROOT::Math::GSLSimAnParams*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnParams(void *p) {
      delete [] ((::ROOT::Math::GSLSimAnParams*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLSimAnParams(void *p) {
      typedef ::ROOT::Math::GSLSimAnParams current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLSimAnParams

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLSimAnnealing_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLSimAnnealing.
      typedef ::ROOT::Shadow::ROOT::Math::GSLSimAnnealing ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLSimAnnealing*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fParams", (void*)&sobj->fParams);
      R__insp.InspectMember("ROOT::Math::GSLSimAnParams", (void*)&sobj->fParams, "fParams.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLSimAnnealing(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnnealing : new ::ROOT::Math::GSLSimAnnealing;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLSimAnnealing(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLSimAnnealing[nElements] : new ::ROOT::Math::GSLSimAnnealing[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLSimAnnealing(void *p) {
      delete ((::ROOT::Math::GSLSimAnnealing*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLSimAnnealing(void *p) {
      delete [] ((::ROOT::Math::GSLSimAnnealing*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLSimAnnealing(void *p) {
      typedef ::ROOT::Math::GSLSimAnnealing current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLSimAnnealing

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLNLSMinimizer : new ::ROOT::Math::GSLNLSMinimizer;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLNLSMinimizer(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLNLSMinimizer[nElements] : new ::ROOT::Math::GSLNLSMinimizer[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p) {
      delete ((::ROOT::Math::GSLNLSMinimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p) {
      delete [] ((::ROOT::Math::GSLNLSMinimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLNLSMinimizer(void *p) {
      typedef ::ROOT::Math::GSLNLSMinimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLNLSMinimizer

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLLSResidualFunc(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::LSResidualFunc : new ::ROOT::Math::LSResidualFunc;
   }
   static void *newArray_ROOTcLcLMathcLcLLSResidualFunc(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::LSResidualFunc[nElements] : new ::ROOT::Math::LSResidualFunc[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLLSResidualFunc(void *p) {
      delete ((::ROOT::Math::LSResidualFunc*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLLSResidualFunc(void *p) {
      delete [] ((::ROOT::Math::LSResidualFunc*)p);
   }
   static void destruct_ROOTcLcLMathcLcLLSResidualFunc(void *p) {
      typedef ::ROOT::Math::LSResidualFunc current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::LSResidualFunc

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLMCIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLMCIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GSLMCIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLMCIntegrator*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fType", &sobj->fType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fRng", &sobj->fRng);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fDim", &sobj->fDim);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCalls", &sobj->fCalls);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fAbsTol", &sobj->fAbsTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRelTol", &sobj->fRelTol);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fResult", &sobj->fResult);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fError", &sobj->fError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fWorkspace", &sobj->fWorkspace);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.GenericShowMembers("ROOT::Math::VirtualIntegratorMultiDim", ( ::ROOT::Math::VirtualIntegratorMultiDim * )( (::ROOT::Math::GSLMCIntegrator*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLMCIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMCIntegrator : new ::ROOT::Math::GSLMCIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLMCIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLMCIntegrator[nElements] : new ::ROOT::Math::GSLMCIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLMCIntegrator(void *p) {
      delete ((::ROOT::Math::GSLMCIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLMCIntegrator(void *p) {
      delete [] ((::ROOT::Math::GSLMCIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLMCIntegrator(void *p) {
      typedef ::ROOT::Math::GSLMCIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLMCIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVegasParameters_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::VegasParameters.
      typedef ::ROOT::Shadow::ROOT::Math::VegasParameters ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VegasParameters*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "alpha", &sobj->alpha);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "iterations", &sobj->iterations);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "stage", &sobj->stage);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "mode", &sobj->mode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "verbose", &sobj->verbose);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLVegasParameters(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VegasParameters : new ::ROOT::Math::VegasParameters;
   }
   static void *newArray_ROOTcLcLMathcLcLVegasParameters(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::VegasParameters[nElements] : new ::ROOT::Math::VegasParameters[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVegasParameters(void *p) {
      delete ((::ROOT::Math::VegasParameters*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVegasParameters(void *p) {
      delete [] ((::ROOT::Math::VegasParameters*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVegasParameters(void *p) {
      typedef ::ROOT::Math::VegasParameters current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VegasParameters

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLMiserParameters_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::MiserParameters.
      typedef ::ROOT::Shadow::ROOT::Math::MiserParameters ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MiserParameters*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "estimate_frac", &sobj->estimate_frac);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "min_calls", &sobj->min_calls);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "min_calls_per_bisection", &sobj->min_calls_per_bisection);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "alpha", &sobj->alpha);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dither", &sobj->dither);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLMiserParameters(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MiserParameters : new ::ROOT::Math::MiserParameters;
   }
   static void *newArray_ROOTcLcLMathcLcLMiserParameters(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MiserParameters[nElements] : new ::ROOT::Math::MiserParameters[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLMiserParameters(void *p) {
      delete ((::ROOT::Math::MiserParameters*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLMiserParameters(void *p) {
      delete [] ((::ROOT::Math::MiserParameters*)p);
   }
   static void destruct_ROOTcLcLMathcLcLMiserParameters(void *p) {
      typedef ::ROOT::Math::MiserParameters current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::MiserParameters

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRootFinder.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRootFinder ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinder*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fS", &sobj->fS);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRoot", &sobj->fRoot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXlow", &sobj->fXlow);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fXup", &sobj->fXup);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIter", &sobj->fIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fValidInterval", &sobj->fValidInterval);
      R__insp.GenericShowMembers("ROOT::Math::IRootFinderMethod", ( ::ROOT::Math::IRootFinderMethod * )( (::ROOT::Math::GSLRootFinder*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRootFinder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRootFinder : new ::ROOT::Math::GSLRootFinder;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRootFinder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRootFinder[nElements] : new ::ROOT::Math::GSLRootFinder[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRootFinder(void *p) {
      delete ((::ROOT::Math::GSLRootFinder*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRootFinder(void *p) {
      delete [] ((::ROOT::Math::GSLRootFinder*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRootFinder(void *p) {
      typedef ::ROOT::Math::GSLRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRootFinder

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGSLRootFinderDeriv_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::GSLRootFinderDeriv.
      typedef ::ROOT::Shadow::ROOT::Math::GSLRootFinderDeriv ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GSLRootFinderDeriv*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*fS", &sobj->fS);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fRoot", &sobj->fRoot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fPrevRoot", &sobj->fPrevRoot);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fIter", &sobj->fIter);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fValidPoint", &sobj->fValidPoint);
      R__insp.GenericShowMembers("ROOT::Math::IRootFinderMethod", ( ::ROOT::Math::IRootFinderMethod * )( (::ROOT::Math::GSLRootFinderDeriv*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRootFinderDeriv : new ::ROOT::Math::GSLRootFinderDeriv;
   }
   static void *newArray_ROOTcLcLMathcLcLGSLRootFinderDeriv(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GSLRootFinderDeriv[nElements] : new ::ROOT::Math::GSLRootFinderDeriv[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p) {
      delete ((::ROOT::Math::GSLRootFinderDeriv*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p) {
      delete [] ((::ROOT::Math::GSLRootFinderDeriv*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGSLRootFinderDeriv(void *p) {
      typedef ::ROOT::Math::GSLRootFinderDeriv current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GSLRootFinderDeriv

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLBisection_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::Bisection.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::Bisection ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Bisection*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinder", ( ::ROOT::Math::GSLRootFinder * )( (::ROOT::Math::Roots::Bisection*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLBisection(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Bisection : new ::ROOT::Math::Roots::Bisection;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLBisection(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Bisection[nElements] : new ::ROOT::Math::Roots::Bisection[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLBisection(void *p) {
      delete ((::ROOT::Math::Roots::Bisection*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLBisection(void *p) {
      delete [] ((::ROOT::Math::Roots::Bisection*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLBisection(void *p) {
      typedef ::ROOT::Math::Roots::Bisection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::Bisection

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLFalsePos_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::FalsePos.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::FalsePos ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::FalsePos*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinder", ( ::ROOT::Math::GSLRootFinder * )( (::ROOT::Math::Roots::FalsePos*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::FalsePos : new ::ROOT::Math::Roots::FalsePos;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLFalsePos(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::FalsePos[nElements] : new ::ROOT::Math::Roots::FalsePos[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p) {
      delete ((::ROOT::Math::Roots::FalsePos*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p) {
      delete [] ((::ROOT::Math::Roots::FalsePos*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLFalsePos(void *p) {
      typedef ::ROOT::Math::Roots::FalsePos current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::FalsePos

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLBrent_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::Brent.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::Brent ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Brent*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinder", ( ::ROOT::Math::GSLRootFinder * )( (::ROOT::Math::Roots::Brent*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLBrent(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Brent : new ::ROOT::Math::Roots::Brent;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLBrent(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Brent[nElements] : new ::ROOT::Math::Roots::Brent[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLBrent(void *p) {
      delete ((::ROOT::Math::Roots::Brent*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLBrent(void *p) {
      delete [] ((::ROOT::Math::Roots::Brent*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLBrent(void *p) {
      typedef ::ROOT::Math::Roots::Brent current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::Brent

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLNewton_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::Newton.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::Newton ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Newton*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinderDeriv", ( ::ROOT::Math::GSLRootFinderDeriv * )( (::ROOT::Math::Roots::Newton*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLNewton(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Newton : new ::ROOT::Math::Roots::Newton;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLNewton(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Newton[nElements] : new ::ROOT::Math::Roots::Newton[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLNewton(void *p) {
      delete ((::ROOT::Math::Roots::Newton*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLNewton(void *p) {
      delete [] ((::ROOT::Math::Roots::Newton*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLNewton(void *p) {
      typedef ::ROOT::Math::Roots::Newton current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::Newton

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLSecant_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::Secant.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::Secant ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Secant*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinderDeriv", ( ::ROOT::Math::GSLRootFinderDeriv * )( (::ROOT::Math::Roots::Secant*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLSecant(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Secant : new ::ROOT::Math::Roots::Secant;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLSecant(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Secant[nElements] : new ::ROOT::Math::Roots::Secant[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLSecant(void *p) {
      delete ((::ROOT::Math::Roots::Secant*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLSecant(void *p) {
      delete [] ((::ROOT::Math::Roots::Secant*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLSecant(void *p) {
      typedef ::ROOT::Math::Roots::Secant current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::Secant

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootscLcLSteffenson_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::Roots::Steffenson.
      typedef ::ROOT::Shadow::ROOT::Math::Roots::Steffenson ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Roots::Steffenson*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("ROOT::Math::GSLRootFinderDeriv", ( ::ROOT::Math::GSLRootFinderDeriv * )( (::ROOT::Math::Roots::Steffenson*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Steffenson : new ::ROOT::Math::Roots::Steffenson;
   }
   static void *newArray_ROOTcLcLMathcLcLRootscLcLSteffenson(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Roots::Steffenson[nElements] : new ::ROOT::Math::Roots::Steffenson[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p) {
      delete ((::ROOT::Math::Roots::Steffenson*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p) {
      delete [] ((::ROOT::Math::Roots::Steffenson*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootscLcLSteffenson(void *p) {
      typedef ::ROOT::Math::Roots::Steffenson current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Roots::Steffenson

namespace ROOT {
   void maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR_Dictionary();
   static void *new_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p = 0);
   static void *newArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(Long_t size, void *p);
   static void delete_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p);
   static void deleteArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p);
   static void destruct_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<unsigned int,pair<double,double> >*)
   {
      map<unsigned int,pair<double,double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<unsigned int,pair<double,double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<unsigned int,pair<double,double> >", -2, "prec_stl/map", 63,
                  typeid(map<unsigned int,pair<double,double> >), DefineBehavior(ptr, ptr),
                  0, &maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(map<unsigned int,pair<double,double> >) );
      instance.SetNew(&new_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR);
      instance.SetNewArray(&newArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR);
      instance.SetDelete(&delete_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR);
      instance.SetDestructor(&destruct_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<unsigned int,pair<double,double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<unsigned int,pair<double,double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<unsigned int,pair<double,double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<unsigned int,pair<double,double> > : new map<unsigned int,pair<double,double> >;
   }
   static void *newArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<unsigned int,pair<double,double> >[nElements] : new map<unsigned int,pair<double,double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p) {
      delete ((map<unsigned int,pair<double,double> >*)p);
   }
   static void deleteArray_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p) {
      delete [] ((map<unsigned int,pair<double,double> >*)p);
   }
   static void destruct_maplEunsignedsPintcOpairlEdoublecOdoublegRsPgR(void *p) {
      typedef map<unsigned int,pair<double,double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<unsigned int,pair<double,double> >

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLEMinimVariableTypegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLEMinimVariableTypegR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::EMinimVariableType>*)
   {
      vector<ROOT::Math::EMinimVariableType> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::EMinimVariableType>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::EMinimVariableType>", -2, "prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::EMinimVariableType>), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLEMinimVariableTypegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<ROOT::Math::EMinimVariableType>) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::EMinimVariableType> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::EMinimVariableType>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLEMinimVariableTypegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::EMinimVariableType>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::EMinimVariableType> : new vector<ROOT::Math::EMinimVariableType>;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::EMinimVariableType>[nElements] : new vector<ROOT::Math::EMinimVariableType>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p) {
      delete ((vector<ROOT::Math::EMinimVariableType>*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p) {
      delete [] ((vector<ROOT::Math::EMinimVariableType>*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLEMinimVariableTypegR(void *p) {
      typedef vector<ROOT::Math::EMinimVariableType> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::EMinimVariableType>

namespace ROOT {
   void vectorlEcomplexlEdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEcomplexlEdoublegRsPgR_Dictionary();
   static void *new_vectorlEcomplexlEdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEcomplexlEdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEcomplexlEdoublegRsPgR(void *p);
   static void deleteArray_vectorlEcomplexlEdoublegRsPgR(void *p);
   static void destruct_vectorlEcomplexlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<complex<double> >*)
   {
      vector<complex<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<complex<double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<complex<double> >", -2, "prec_stl/vector", 49,
                  typeid(vector<complex<double> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEcomplexlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<complex<double> >) );
      instance.SetNew(&new_vectorlEcomplexlEdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEcomplexlEdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEcomplexlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEcomplexlEdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEcomplexlEdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<complex<double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<complex<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEcomplexlEdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<complex<double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEcomplexlEdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<complex<double> > : new vector<complex<double> >;
   }
   static void *newArray_vectorlEcomplexlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<complex<double> >[nElements] : new vector<complex<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEcomplexlEdoublegRsPgR(void *p) {
      delete ((vector<complex<double> >*)p);
   }
   static void deleteArray_vectorlEcomplexlEdoublegRsPgR(void *p) {
      delete [] ((vector<complex<double> >*)p);
   }
   static void destruct_vectorlEcomplexlEdoublegRsPgR(void *p) {
      typedef vector<complex<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<complex<double> >

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "prec_stl/vector", 49,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEstringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEstringgR_Dictionary();
   static void *new_vectorlEstringgR(void *p = 0);
   static void *newArray_vectorlEstringgR(Long_t size, void *p);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<string>*)
   {
      vector<string> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<string>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<string>", -2, "prec_stl/vector", 49,
                  typeid(vector<string>), DefineBehavior(ptr, ptr),
                  0, &vectorlEstringgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<string> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEstringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<string>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<string>[nElements] : new vector<string>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<string>

/********************************************************
* math/mathmore/src/G__MathMore.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__MathMore();

extern "C" void G__set_cpp_environmentG__MathMore() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("Math/DistFuncMathMore.h");
  G__add_compiledheader("Math/SpecFuncMathMore.h");
  G__add_compiledheader("Math/PdfFuncMathMore.h");
  G__add_compiledheader("Math/Polynomial.h");
  G__add_compiledheader("Math/Derivator.h");
  G__add_compiledheader("Math/Interpolator.h");
  G__add_compiledheader("Math/InterpolationTypes.h");
  G__add_compiledheader("Math/GSLRootFinder.h");
  G__add_compiledheader("Math/GSLRootFinderDeriv.h");
  G__add_compiledheader("Math/RootFinderAlgorithms.h");
  G__add_compiledheader("Math/GSLIntegrator.h");
  G__add_compiledheader("Math/GSLMCIntegrator.h");
  G__add_compiledheader("Math/MCParameters.h");
  G__add_compiledheader("Math/GSLMinimizer1D.h");
  G__add_compiledheader("Math/Chebyshev.h");
  G__add_compiledheader("Math/Random.h");
  G__add_compiledheader("Math/GSLRndmEngines.h");
  G__add_compiledheader("Math/KelvinFunctions.h");
  G__add_compiledheader("Math/GSLMinimizer.h");
  G__add_compiledheader("Math/GSLNLSMinimizer.h");
  G__add_compiledheader("Math/GSLSimAnMinimizer.h");
  G__add_compiledheader("Math/Vavilov.h");
  G__add_compiledheader("Math/VavilovAccurate.h");
  G__add_compiledheader("Math/VavilovAccuratePdf.h");
  G__add_compiledheader("Math/VavilovAccurateCdf.h");
  G__add_compiledheader("Math/VavilovAccurateQuantile.h");
  G__add_compiledheader("Math/VavilovFast.h");
  G__add_compiledheader("/web/servers/service-phgt-0/lib/sci_visualization/downloads/root_sci_viz/math/mathmore/src/GSLError.h");
  G__cpp_reset_tagtableG__MathMore();
}
#include <new>
extern "C" int G__cpp_dllrevG__MathMore() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ROOT */
static int G__G__MathMore_19_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::CreateClass(
(const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (TVirtualIsAProxy*) G__int(libp->para[3])
, (ShowMembersFunc_t) G__int(libp->para[4]), (const char*) G__int(libp->para[5])
, (const char*) G__int(libp->para[6]), (Int_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_19_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::AddClass((const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (VoidFuncPtr_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_19_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::RemoveClass((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_19_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::ResetClassVersion((TClass*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Short_t) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_19_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::RegisterClassTemplate((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_19_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::DefineBehavior((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math */
static int G__G__MathMore_99_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::noncentral_chisquared_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::assoc_laguerre((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::assoc_legendre((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::comp_ellint_1((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::comp_ellint_2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::comp_ellint_3((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::conf_hyperg((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::conf_hypergU((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cyl_bessel_i((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cyl_bessel_j((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cyl_bessel_k((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cyl_neumann((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::ellint_1((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::ellint_2((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::ellint_3((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::expint((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::hyperg((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::laguerre((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::legendre((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::riemann_zeta((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::sph_bessel((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::sph_legendre((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::sph_neumann((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_Ai((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_Bi((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_Ai_deriv((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_Bi_deriv((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_zero_Ai((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_zero_Bi((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_zero_Ai_deriv((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::airy_zero_Bi_deriv((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::wigner_3j((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int) G__int(libp->para[3])
, (int) G__int(libp->para[4]), (int) G__int(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::wigner_6j((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int) G__int(libp->para[3])
, (int) G__int(libp->para[4]), (int) G__int(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::wigner_9j(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int) G__int(libp->para[3])
, (int) G__int(libp->para[4]), (int) G__int(libp->para[5])
, (int) G__int(libp->para[6]), (int) G__int(libp->para[7])
, (int) G__int(libp->para[8])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_accurate_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_accurate_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_accurate_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_accurate_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_accurate_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_fast_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_fast_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_fast_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_fast_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_99_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::vavilov_fast_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::MathMore */
static int G__G__MathMore_100_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::MathMore::chisquared_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_100_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::MathMore::gamma_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Polynomial */
static int G__G__MathMore_113_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Polynomial((unsigned int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::Polynomial((unsigned int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::Polynomial[n];
       } else {
         p = new((void*) gvp) ROOT::Math::Polynomial[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::Polynomial;
       } else {
         p = new((void*) gvp) ROOT::Math::Polynomial;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Polynomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) ROOT::Math::Polynomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
   } else {
     p = new((void*) gvp) ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 5
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
   } else {
     p = new((void*) gvp) ROOT::Math::Polynomial(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<std::complex<double> >& obj = ((ROOT::Math::Polynomial*) G__getstructoffset())->FindRoots();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double>* pobj;
         vector<double> xobj = ((ROOT::Math::Polynomial*) G__getstructoffset())->FindRealRoots();
         pobj = new vector<double>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<std::complex<double> >& obj = ((ROOT::Math::Polynomial*) G__getstructoffset())->FindNumRoots();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_113_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Polynomial*) G__getstructoffset())->Order());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_113_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Polynomial* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Polynomial(*(ROOT::Math::Polynomial*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Polynomial G__TROOTcLcLMathcLcLPolynomial;
static int G__G__MathMore_113_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Polynomial*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Polynomial*) (soff+(sizeof(ROOT::Math::Polynomial)*i)))->~G__TROOTcLcLMathcLcLPolynomial();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Polynomial*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Polynomial*) (soff))->~G__TROOTcLcLMathcLcLPolynomial();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_113_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Polynomial* dest = (ROOT::Math::Polynomial*) G__getstructoffset();
   *dest = *(ROOT::Math::Polynomial*) libp->para[0].ref;
   const ROOT::Math::Polynomial& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> */
// automatic destructor
typedef ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> G__TROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR;
static int G__G__MathMore_114_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) (soff+(sizeof(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>)*i)))->~G__TROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) (soff))->~G__TROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_114_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>* dest = (ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) G__getstructoffset();
   *dest = *(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*) libp->para[0].ref;
   const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Derivator */
static int G__G__MathMore_125_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Derivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Derivator[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Derivator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Derivator;
     } else {
       p = new((void*) gvp) ROOT::Math::Derivator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Derivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Derivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Derivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Derivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Derivator(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])), (void*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Derivator(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])), (void*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Derivator(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])));
     } else {
       p = new((void*) gvp) ROOT::Math::Derivator(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Derivator*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ROOT::Math::Derivator*) G__getstructoffset())->SetFunction(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])), (void*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::Derivator*) G__getstructoffset())->SetFunction(libp->para[0].ref ? *(const ROOT::Math::Derivator::GSLFuncPointer*) libp->para[0].ref : *(const ROOT::Math::Derivator::GSLFuncPointer*) (void*) (&G__Mlong(libp->para[0])));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->Eval((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->Eval((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalCentral((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalCentral((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalForward((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalForward((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalBackward((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->EvalBackward((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalCentral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalCentral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalForward(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalForward(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalBackward(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::EvalBackward(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (double) G__double(libp->para[4])));
      break;
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamMultiFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (double) G__double(libp->para[4])));
      break;
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamMultiFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::Derivator::Eval(*(ROOT::Math::IParamMultiFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Derivator*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_125_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Derivator*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Derivator G__TROOTcLcLMathcLcLDerivator;
static int G__G__MathMore_125_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Derivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Derivator*) (soff+(sizeof(ROOT::Math::Derivator)*i)))->~G__TROOTcLcLMathcLcLDerivator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Derivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Derivator*) (soff))->~G__TROOTcLcLMathcLcLDerivator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Interpolator */
static int G__G__MathMore_129_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Interpolator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Interpolator((unsigned int) G__int(libp->para[0]), (ROOT::Math::Interpolation::Type) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Interpolator((unsigned int) G__int(libp->para[0]), (ROOT::Math::Interpolation::Type) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Interpolator((unsigned int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::Interpolator((unsigned int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::Interpolator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::Interpolator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::Interpolator;
       } else {
         p = new((void*) gvp) ROOT::Math::Interpolator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Interpolator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Interpolator(
*(vector<double>*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref
, (ROOT::Math::Interpolation::Type) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::Interpolator(
*(vector<double>*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref
, (ROOT::Math::Interpolation::Type) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Interpolator(*(vector<double>*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::Interpolator(*(vector<double>*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Interpolator*) G__getstructoffset())->SetData(*(vector<double>*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Interpolator*) G__getstructoffset())->SetData((unsigned int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Interpolator*) G__getstructoffset())->Eval((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Interpolator*) G__getstructoffset())->Deriv((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Interpolator*) G__getstructoffset())->Deriv2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Interpolator*) G__getstructoffset())->Integ((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Interpolator*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_129_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Interpolator*) G__getstructoffset())->TypeGet();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Interpolator G__TROOTcLcLMathcLcLInterpolator;
static int G__G__MathMore_129_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Interpolator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Interpolator*) (soff+(sizeof(ROOT::Math::Interpolator)*i)))->~G__TROOTcLcLMathcLcLInterpolator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Interpolator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Interpolator*) (soff))->~G__TROOTcLcLMathcLcLInterpolator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRootFinder */
static int G__G__MathMore_133_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRootFinder* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRootFinder[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRootFinder[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRootFinder;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRootFinder;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_133_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::GSLRootFinder*) G__getstructoffset())->SetFunction((ROOT::Math::GSLRootFinder::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRootFinder G__TROOTcLcLMathcLcLGSLRootFinder;
static int G__G__MathMore_133_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRootFinder*) (soff+(sizeof(ROOT::Math::GSLRootFinder)*i)))->~G__TROOTcLcLMathcLcLGSLRootFinder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRootFinder*) (soff))->~G__TROOTcLcLMathcLcLGSLRootFinder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRootFinderDeriv */
static int G__G__MathMore_136_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRootFinderDeriv* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRootFinderDeriv[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRootFinderDeriv[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRootFinderDeriv;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRootFinderDeriv;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_136_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::GSLRootFinderDeriv*) G__getstructoffset())->SetFunction((ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer) G__int(libp->para[0]), (ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer) G__int(libp->para[1])
, (ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (double) G__double(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRootFinderDeriv G__TROOTcLcLMathcLcLGSLRootFinderDeriv;
static int G__G__MathMore_136_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRootFinderDeriv*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRootFinderDeriv*) (soff+(sizeof(ROOT::Math::GSLRootFinderDeriv)*i)))->~G__TROOTcLcLMathcLcLGSLRootFinderDeriv();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRootFinderDeriv*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRootFinderDeriv*) (soff))->~G__TROOTcLcLMathcLcLGSLRootFinderDeriv();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots */

/* ROOT::Math::Roots::Bisection */
static int G__G__MathMore_138_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::Bisection* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Bisection[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Bisection[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Bisection;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Bisection;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::Bisection G__TROOTcLcLMathcLcLRootscLcLBisection;
static int G__G__MathMore_138_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::Bisection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::Bisection*) (soff+(sizeof(ROOT::Math::Roots::Bisection)*i)))->~G__TROOTcLcLMathcLcLRootscLcLBisection();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::Bisection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::Bisection*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLBisection();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots::FalsePos */
static int G__G__MathMore_139_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::FalsePos* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::FalsePos[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::FalsePos[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::FalsePos;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::FalsePos;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::FalsePos G__TROOTcLcLMathcLcLRootscLcLFalsePos;
static int G__G__MathMore_139_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::FalsePos*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::FalsePos*) (soff+(sizeof(ROOT::Math::Roots::FalsePos)*i)))->~G__TROOTcLcLMathcLcLRootscLcLFalsePos();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::FalsePos*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::FalsePos*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLFalsePos();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots::Brent */
static int G__G__MathMore_140_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::Brent* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Brent[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Brent[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Brent;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Brent;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::Brent G__TROOTcLcLMathcLcLRootscLcLBrent;
static int G__G__MathMore_140_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::Brent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::Brent*) (soff+(sizeof(ROOT::Math::Roots::Brent)*i)))->~G__TROOTcLcLMathcLcLRootscLcLBrent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::Brent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::Brent*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLBrent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots::Newton */
static int G__G__MathMore_141_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::Newton* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Newton[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Newton[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Newton;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Newton;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::Newton G__TROOTcLcLMathcLcLRootscLcLNewton;
static int G__G__MathMore_141_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::Newton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::Newton*) (soff+(sizeof(ROOT::Math::Roots::Newton)*i)))->~G__TROOTcLcLMathcLcLRootscLcLNewton();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::Newton*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::Newton*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLNewton();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots::Secant */
static int G__G__MathMore_142_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::Secant* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Secant[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Secant[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Secant;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Secant;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::Secant G__TROOTcLcLMathcLcLRootscLcLSecant;
static int G__G__MathMore_142_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::Secant*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::Secant*) (soff+(sizeof(ROOT::Math::Roots::Secant)*i)))->~G__TROOTcLcLMathcLcLRootscLcLSecant();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::Secant*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::Secant*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLSecant();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Roots::Steffenson */
static int G__G__MathMore_143_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Roots::Steffenson* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Steffenson[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Steffenson[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Roots::Steffenson;
     } else {
       p = new((void*) gvp) ROOT::Math::Roots::Steffenson;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Roots::Steffenson G__TROOTcLcLMathcLcLRootscLcLSteffenson;
static int G__G__MathMore_143_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Roots::Steffenson*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Roots::Steffenson*) (soff+(sizeof(ROOT::Math::Roots::Steffenson)*i)))->~G__TROOTcLcLMathcLcLRootscLcLSteffenson();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Roots::Steffenson*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Roots::Steffenson*) (soff))->~G__TROOTcLcLMathcLcLRootscLcLSteffenson();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Integration */

/* ROOT::Math::GSLIntegrator */
static int G__G__MathMore_158_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (size_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (size_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLIntegrator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLIntegrator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLIntegrator;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLIntegrator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (size_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (size_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLIntegrator((const ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (const ROOT::Math::Integration::GKRule) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 5
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLIntegrator(
(const char*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLIntegrator(
(const char*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->SetFunction((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->SetFunction((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->IntegralCauchy(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->IntegralUp(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->IntegralLow(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->IntegralUp((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->IntegralLow((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->Integral((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, *(vector<double>*) libp->para[2].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLIntegrator*) G__getstructoffset())->SetIntegrationRule((ROOT::Math::Integration::GKRule) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::GSLIntegrator*) G__getstructoffset())->GetType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_158_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::GSLIntegrator*) G__getstructoffset())->GetTypeName());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLIntegrator G__TROOTcLcLMathcLcLGSLIntegrator;
static int G__G__MathMore_158_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLIntegrator*) (soff+(sizeof(ROOT::Math::GSLIntegrator)*i)))->~G__TROOTcLcLMathcLcLGSLIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGSLIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VegasParameters */
static int G__G__MathMore_161_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VegasParameters* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VegasParameters[n];
     } else {
       p = new((void*) gvp) ROOT::Math::VegasParameters[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VegasParameters;
     } else {
       p = new((void*) gvp) ROOT::Math::VegasParameters;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_161_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VegasParameters* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::VegasParameters(*(ROOT::Math::IOptions*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::VegasParameters(*(ROOT::Math::IOptions*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_161_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VegasParameters*) G__getstructoffset())->SetDefaultValues();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_161_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::VegasParameters& obj = ((ROOT::Math::VegasParameters*) G__getstructoffset())->operator=(*(ROOT::Math::IOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_161_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::VegasParameters*) G__getstructoffset())->operator()());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_161_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VegasParameters* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VegasParameters(*(ROOT::Math::VegasParameters*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VegasParameters G__TROOTcLcLMathcLcLVegasParameters;
static int G__G__MathMore_161_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VegasParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VegasParameters*) (soff+(sizeof(ROOT::Math::VegasParameters)*i)))->~G__TROOTcLcLMathcLcLVegasParameters();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VegasParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VegasParameters*) (soff))->~G__TROOTcLcLMathcLcLVegasParameters();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_161_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VegasParameters* dest = (ROOT::Math::VegasParameters*) G__getstructoffset();
   *dest = *(ROOT::Math::VegasParameters*) libp->para[0].ref;
   const ROOT::Math::VegasParameters& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::MiserParameters */
static int G__G__MathMore_162_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MiserParameters* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MiserParameters((size_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::MiserParameters((size_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::MiserParameters[n];
       } else {
         p = new((void*) gvp) ROOT::Math::MiserParameters[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::MiserParameters;
       } else {
         p = new((void*) gvp) ROOT::Math::MiserParameters;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_162_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((ROOT::Math::MiserParameters*) G__getstructoffset())->SetDefaultValues((size_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((ROOT::Math::MiserParameters*) G__getstructoffset())->SetDefaultValues();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_162_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MiserParameters* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MiserParameters(*(ROOT::Math::IOptions*) libp->para[0].ref, (size_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::MiserParameters(*(ROOT::Math::IOptions*) libp->para[0].ref, (size_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MiserParameters(*(ROOT::Math::IOptions*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::MiserParameters(*(ROOT::Math::IOptions*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_162_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::MiserParameters& obj = ((ROOT::Math::MiserParameters*) G__getstructoffset())->operator=(*(ROOT::Math::IOptions*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_162_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::MiserParameters*) G__getstructoffset())->operator()());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_162_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::MiserParameters* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::MiserParameters(*(ROOT::Math::MiserParameters*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::MiserParameters G__TROOTcLcLMathcLcLMiserParameters;
static int G__G__MathMore_162_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::MiserParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::MiserParameters*) (soff+(sizeof(ROOT::Math::MiserParameters)*i)))->~G__TROOTcLcLMathcLcLMiserParameters();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::MiserParameters*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::MiserParameters*) (soff))->~G__TROOTcLcLMathcLcLMiserParameters();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_162_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MiserParameters* dest = (ROOT::Math::MiserParameters*) G__getstructoffset();
   *dest = *(ROOT::Math::MiserParameters*) libp->para[0].ref;
   const ROOT::Math::MiserParameters& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLMCIntegrator */
static int G__G__MathMore_167_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLMCIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMCIntegrator(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMCIntegrator(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMCIntegrator(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMCIntegrator(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMCIntegrator((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMCIntegrator((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMCIntegrator((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMCIntegrator((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMCIntegrator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMCIntegrator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMCIntegrator;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMCIntegrator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLMCIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLMCIntegrator(
(const char*) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLMCIntegrator(
(const char*) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetFunction((ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (void*) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetFunction((ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->Integral(libp->para[0].ref ? *(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer*) libp->para[0].ref : *(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer*) (void*) (&G__Mlong(libp->para[0])), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (void*) G__int(libp->para[4])));
      break;
   case 4:
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->Integral(libp->para[0].ref ? *(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer*) libp->para[0].ref : *(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer*) (void*) (&G__Mlong(libp->para[0])), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetGenerator((ROOT::Math::GSLRngWrapper*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetType((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetTypeName((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetMode((ROOT::Math::MCIntegration::Mode) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetParameters(*(ROOT::Math::VegasParameters*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->SetParameters(*(ROOT::Math::MiserParameters*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->Sigma());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->ChiSqr());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->GetType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->GetTypeName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_167_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::GSLMCIntegrator*) G__getstructoffset())->ExtraOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLMCIntegrator G__TROOTcLcLMathcLcLGSLMCIntegrator;
static int G__G__MathMore_167_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLMCIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLMCIntegrator*) (soff+(sizeof(ROOT::Math::GSLMCIntegrator)*i)))->~G__TROOTcLcLMathcLcLGSLMCIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLMCIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLMCIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGSLMCIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Minim1D */

/* ROOT::Math::GSLMinimizer1D */
static int G__G__MathMore_172_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLMinimizer1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMinimizer1D((ROOT::Math::Minim1D::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMinimizer1D((ROOT::Math::Minim1D::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMinimizer1D[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMinimizer1D[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMinimizer1D;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMinimizer1D;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_172_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLMinimizer1D*) G__getstructoffset())->SetFunction((ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_172_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::GSLMinimizer1D*) G__getstructoffset())->Iterate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_172_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::GSLMinimizer1D::TestInterval((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLMinimizer1D G__TROOTcLcLMathcLcLGSLMinimizer1D;
static int G__G__MathMore_172_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLMinimizer1D*) (soff+(sizeof(ROOT::Math::GSLMinimizer1D)*i)))->~G__TROOTcLcLMathcLcLGSLMinimizer1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLMinimizer1D*) (soff))->~G__TROOTcLcLMathcLcLGSLMinimizer1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Chebyshev */
static int G__G__MathMore_174_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Chebyshev* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Chebyshev(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (size_t) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::Chebyshev(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (size_t) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Chebyshev* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 5
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Chebyshev(
(ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
   } else {
     p = new((void*) gvp) ROOT::Math::Chebyshev(
(ROOT::Math::GSLFuncPointer) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (size_t) G__int(libp->para[4]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Chebyshev*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const pair<double,double>* pobj;
         const pair<double,double> xobj = ((const ROOT::Math::Chebyshev*) G__getstructoffset())->EvalErr((double) G__double(libp->para[0]));
         pobj = new pair<double,double>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Chebyshev*) G__getstructoffset())->operator()((double) G__double(libp->para[0]), (size_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const pair<double,double>* pobj;
         const pair<double,double> xobj = ((const ROOT::Math::Chebyshev*) G__getstructoffset())->EvalErr((double) G__double(libp->para[0]), (size_t) G__int(libp->para[1]));
         pobj = new pair<double,double>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::Chebyshev*) G__getstructoffset())->Deriv());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_174_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::Chebyshev*) G__getstructoffset())->Integral());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Chebyshev G__TROOTcLcLMathcLcLChebyshev;
static int G__G__MathMore_174_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Chebyshev*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Chebyshev*) (soff+(sizeof(ROOT::Math::Chebyshev)*i)))->~G__TROOTcLcLMathcLcLChebyshev();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Chebyshev*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Chebyshev*) (soff))->~G__TROOTcLcLMathcLcLChebyshev();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRandomEngine */
static int G__G__MathMore_176_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRandomEngine* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRandomEngine[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRandomEngine[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRandomEngine;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRandomEngine;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRandomEngine* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLRandomEngine((ROOT::Math::GSLRngWrapper*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLRandomEngine((ROOT::Math::GSLRngWrapper*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Initialize();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Terminate();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->operator()());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->RndmInt((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->RandomArray((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Gaussian((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->GaussianZig((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->GaussianRatio((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Exponential((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Cauchy((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Landau());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Dir2D(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Dir3D(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Binomial((double) G__double(libp->para[0]), (unsigned int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_176_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<unsigned int>* pobj;
         const vector<unsigned int> xobj = ((const ROOT::Math::GSLRandomEngine*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_176_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRandomEngine* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRandomEngine(*(ROOT::Math::GSLRandomEngine*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRandomEngine G__TROOTcLcLMathcLcLGSLRandomEngine;
static int G__G__MathMore_176_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRandomEngine*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRandomEngine*) (soff+(sizeof(ROOT::Math::GSLRandomEngine)*i)))->~G__TROOTcLcLMathcLcLGSLRandomEngine();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRandomEngine*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRandomEngine*) (soff))->~G__TROOTcLcLMathcLcLGSLRandomEngine();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_176_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRandomEngine* dest = (ROOT::Math::GSLRandomEngine*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRandomEngine*) libp->para[0].ref;
   const ROOT::Math::GSLRandomEngine& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngMT */
static int G__G__MathMore_181_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngMT* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngMT[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngMT[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngMT;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngMT;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_181_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngMT* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngMT(*(ROOT::Math::GSLRngMT*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngMT G__TROOTcLcLMathcLcLGSLRngMT;
static int G__G__MathMore_181_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngMT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngMT*) (soff+(sizeof(ROOT::Math::GSLRngMT)*i)))->~G__TROOTcLcLMathcLcLGSLRngMT();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngMT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngMT*) (soff))->~G__TROOTcLcLMathcLcLGSLRngMT();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_181_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngMT* dest = (ROOT::Math::GSLRngMT*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngMT*) libp->para[0].ref;
   const ROOT::Math::GSLRngMT& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngRanLux */
static int G__G__MathMore_182_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLux* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLux[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLux[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLux;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLux;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_182_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngRanLux* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngRanLux(*(ROOT::Math::GSLRngRanLux*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngRanLux G__TROOTcLcLMathcLcLGSLRngRanLux;
static int G__G__MathMore_182_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngRanLux*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngRanLux*) (soff+(sizeof(ROOT::Math::GSLRngRanLux)*i)))->~G__TROOTcLcLMathcLcLGSLRngRanLux();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngRanLux*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngRanLux*) (soff))->~G__TROOTcLcLMathcLcLGSLRngRanLux();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_182_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLux* dest = (ROOT::Math::GSLRngRanLux*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngRanLux*) libp->para[0].ref;
   const ROOT::Math::GSLRngRanLux& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngRanLuxS1 */
static int G__G__MathMore_183_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxS1* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxS1[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxS1[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxS1;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxS1;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_183_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngRanLuxS1* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngRanLuxS1(*(ROOT::Math::GSLRngRanLuxS1*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngRanLuxS1 G__TROOTcLcLMathcLcLGSLRngRanLuxS1;
static int G__G__MathMore_183_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngRanLuxS1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngRanLuxS1*) (soff+(sizeof(ROOT::Math::GSLRngRanLuxS1)*i)))->~G__TROOTcLcLMathcLcLGSLRngRanLuxS1();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngRanLuxS1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngRanLuxS1*) (soff))->~G__TROOTcLcLMathcLcLGSLRngRanLuxS1();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_183_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxS1* dest = (ROOT::Math::GSLRngRanLuxS1*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngRanLuxS1*) libp->para[0].ref;
   const ROOT::Math::GSLRngRanLuxS1& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngRanLuxS2 */
static int G__G__MathMore_184_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxS2* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxS2[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxS2[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxS2;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxS2;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_184_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngRanLuxS2* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngRanLuxS2(*(ROOT::Math::GSLRngRanLuxS2*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngRanLuxS2 G__TROOTcLcLMathcLcLGSLRngRanLuxS2;
static int G__G__MathMore_184_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngRanLuxS2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngRanLuxS2*) (soff+(sizeof(ROOT::Math::GSLRngRanLuxS2)*i)))->~G__TROOTcLcLMathcLcLGSLRngRanLuxS2();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngRanLuxS2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngRanLuxS2*) (soff))->~G__TROOTcLcLMathcLcLGSLRngRanLuxS2();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_184_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxS2* dest = (ROOT::Math::GSLRngRanLuxS2*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngRanLuxS2*) libp->para[0].ref;
   const ROOT::Math::GSLRngRanLuxS2& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngRanLuxD1 */
static int G__G__MathMore_185_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxD1* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxD1[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxD1[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxD1;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxD1;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_185_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngRanLuxD1* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngRanLuxD1(*(ROOT::Math::GSLRngRanLuxD1*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngRanLuxD1 G__TROOTcLcLMathcLcLGSLRngRanLuxD1;
static int G__G__MathMore_185_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngRanLuxD1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngRanLuxD1*) (soff+(sizeof(ROOT::Math::GSLRngRanLuxD1)*i)))->~G__TROOTcLcLMathcLcLGSLRngRanLuxD1();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngRanLuxD1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngRanLuxD1*) (soff))->~G__TROOTcLcLMathcLcLGSLRngRanLuxD1();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_185_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxD1* dest = (ROOT::Math::GSLRngRanLuxD1*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngRanLuxD1*) libp->para[0].ref;
   const ROOT::Math::GSLRngRanLuxD1& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngRanLuxD2 */
static int G__G__MathMore_186_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxD2* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxD2[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxD2[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngRanLuxD2;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngRanLuxD2;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_186_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngRanLuxD2* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngRanLuxD2(*(ROOT::Math::GSLRngRanLuxD2*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngRanLuxD2 G__TROOTcLcLMathcLcLGSLRngRanLuxD2;
static int G__G__MathMore_186_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngRanLuxD2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngRanLuxD2*) (soff+(sizeof(ROOT::Math::GSLRngRanLuxD2)*i)))->~G__TROOTcLcLMathcLcLGSLRngRanLuxD2();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngRanLuxD2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngRanLuxD2*) (soff))->~G__TROOTcLcLMathcLcLGSLRngRanLuxD2();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_186_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngRanLuxD2* dest = (ROOT::Math::GSLRngRanLuxD2*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngRanLuxD2*) libp->para[0].ref;
   const ROOT::Math::GSLRngRanLuxD2& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngTaus */
static int G__G__MathMore_187_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngTaus* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngTaus[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngTaus[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngTaus;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngTaus;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_187_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngTaus* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngTaus(*(ROOT::Math::GSLRngTaus*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngTaus G__TROOTcLcLMathcLcLGSLRngTaus;
static int G__G__MathMore_187_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngTaus*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngTaus*) (soff+(sizeof(ROOT::Math::GSLRngTaus)*i)))->~G__TROOTcLcLMathcLcLGSLRngTaus();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngTaus*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngTaus*) (soff))->~G__TROOTcLcLMathcLcLGSLRngTaus();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_187_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngTaus* dest = (ROOT::Math::GSLRngTaus*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngTaus*) libp->para[0].ref;
   const ROOT::Math::GSLRngTaus& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLRngGFSR4 */
static int G__G__MathMore_188_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngGFSR4* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngGFSR4[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngGFSR4[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLRngGFSR4;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLRngGFSR4;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_188_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLRngGFSR4* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLRngGFSR4(*(ROOT::Math::GSLRngGFSR4*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLRngGFSR4 G__TROOTcLcLMathcLcLGSLRngGFSR4;
static int G__G__MathMore_188_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLRngGFSR4*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLRngGFSR4*) (soff+(sizeof(ROOT::Math::GSLRngGFSR4)*i)))->~G__TROOTcLcLMathcLcLGSLRngGFSR4();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLRngGFSR4*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLRngGFSR4*) (soff))->~G__TROOTcLcLMathcLcLGSLRngGFSR4();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_188_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLRngGFSR4* dest = (ROOT::Math::GSLRngGFSR4*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLRngGFSR4*) libp->para[0].ref;
   const ROOT::Math::GSLRngGFSR4& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::KelvinFunctions */
static int G__G__MathMore_194_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Ber((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Bei((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Ker((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Kei((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::DBer((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::DBei((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::DKer((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::DKei((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::F1((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::F2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::G1((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::G2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::M((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Theta((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::N((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_194_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::KelvinFunctions::Phi((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__G__MathMore_194_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::KelvinFunctions *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::KelvinFunctions[n];
     } else {
       p = new((void*) gvp) ROOT::Math::KelvinFunctions[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::KelvinFunctions;
     } else {
       p = new((void*) gvp) ROOT::Math::KelvinFunctions;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_194_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::KelvinFunctions* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::KelvinFunctions(*(ROOT::Math::KelvinFunctions*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::KelvinFunctions G__TROOTcLcLMathcLcLKelvinFunctions;
static int G__G__MathMore_194_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::KelvinFunctions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::KelvinFunctions*) (soff+(sizeof(ROOT::Math::KelvinFunctions)*i)))->~G__TROOTcLcLMathcLcLKelvinFunctions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::KelvinFunctions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::KelvinFunctions*) (soff))->~G__TROOTcLcLMathcLcLKelvinFunctions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_194_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::KelvinFunctions* dest = (ROOT::Math::KelvinFunctions*) G__getstructoffset();
   *dest = *(ROOT::Math::KelvinFunctions*) libp->para[0].ref;
   const ROOT::Math::KelvinFunctions& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLMinimizer */
static int G__G__MathMore_207_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLMinimizer* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLMinimizer((ROOT::Math::EGSLMinimizerType) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLMinimizer((ROOT::Math::EGSLMinimizerType) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMinimizer[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMinimizer[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLMinimizer;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLMinimizer;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_207_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLMinimizer* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLMinimizer((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLMinimizer((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_207_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::GSLMinimizer*) G__getstructoffset())->ObjFunction());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_207_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::GSLMinimizer*) G__getstructoffset())->TransformFunction());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLMinimizer G__TROOTcLcLMathcLcLGSLMinimizer;
static int G__G__MathMore_207_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLMinimizer*) (soff+(sizeof(ROOT::Math::GSLMinimizer)*i)))->~G__TROOTcLcLMathcLcLGSLMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLMinimizer*) (soff))->~G__TROOTcLcLMathcLcLGSLMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::LSResidualFunc */
static int G__G__MathMore_230_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LSResidualFunc* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::LSResidualFunc[n];
     } else {
       p = new((void*) gvp) ROOT::Math::LSResidualFunc[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::LSResidualFunc;
     } else {
       p = new((void*) gvp) ROOT::Math::LSResidualFunc;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_230_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LSResidualFunc* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::LSResidualFunc(*(ROOT::Math::FitMethodFunction*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) ROOT::Math::LSResidualFunc(*(ROOT::Math::FitMethodFunction*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_230_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LSResidualFunc* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::LSResidualFunc(*(ROOT::Math::LSResidualFunc*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::LSResidualFunc(*(ROOT::Math::LSResidualFunc*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_230_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LSResidualFunc& obj = ((ROOT::Math::LSResidualFunc*) G__getstructoffset())->operator=(*(ROOT::Math::LSResidualFunc*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::LSResidualFunc G__TROOTcLcLMathcLcLLSResidualFunc;
static int G__G__MathMore_230_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::LSResidualFunc*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::LSResidualFunc*) (soff+(sizeof(ROOT::Math::LSResidualFunc)*i)))->~G__TROOTcLcLMathcLcLLSResidualFunc();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::LSResidualFunc*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::LSResidualFunc*) (soff))->~G__TROOTcLcLMathcLcLLSResidualFunc();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLNLSMinimizer */
static int G__G__MathMore_231_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLNLSMinimizer* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLNLSMinimizer((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLNLSMinimizer((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLNLSMinimizer[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLNLSMinimizer[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLNLSMinimizer;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLNLSMinimizer;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLNLSMinimizer G__TROOTcLcLMathcLcLGSLNLSMinimizer;
static int G__G__MathMore_231_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLNLSMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLNLSMinimizer*) (soff+(sizeof(ROOT::Math::GSLNLSMinimizer)*i)))->~G__TROOTcLcLMathcLcLGSLNLSMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLNLSMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLNLSMinimizer*) (soff))->~G__TROOTcLcLMathcLcLGSLNLSMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLSimAnFunc */
static int G__G__MathMore_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnFunc* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLSimAnFunc(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLSimAnFunc(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnFunc* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GSLSimAnFunc(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) ROOT::Math::GSLSimAnFunc(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GSLSimAnFunc& obj = ((ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->FastCopy(*(ROOT::Math::GSLSimAnFunc*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Energy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Step(*(ROOT::Math::GSLRandomEngine*) libp->para[0].ref, (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Distance(*(ROOT::Math::GSLSimAnFunc*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->SetX((double*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->X((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double>& obj = ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->X();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->Scale((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_236_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GSLSimAnFunc*) G__getstructoffset())->SetX((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_236_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLSimAnFunc* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLSimAnFunc(*(ROOT::Math::GSLSimAnFunc*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLSimAnFunc G__TROOTcLcLMathcLcLGSLSimAnFunc;
static int G__G__MathMore_236_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLSimAnFunc*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLSimAnFunc*) (soff+(sizeof(ROOT::Math::GSLSimAnFunc)*i)))->~G__TROOTcLcLMathcLcLGSLSimAnFunc();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLSimAnFunc*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLSimAnFunc*) (soff))->~G__TROOTcLcLMathcLcLGSLSimAnFunc();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLSimAnParams */
static int G__G__MathMore_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnParams* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLSimAnParams[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLSimAnParams[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLSimAnParams;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLSimAnParams;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GSLSimAnParams* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GSLSimAnParams(*(ROOT::Math::GSLSimAnParams*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLSimAnParams G__TROOTcLcLMathcLcLGSLSimAnParams;
static int G__G__MathMore_237_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLSimAnParams*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLSimAnParams*) (soff+(sizeof(ROOT::Math::GSLSimAnParams)*i)))->~G__TROOTcLcLMathcLcLGSLSimAnParams();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLSimAnParams*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLSimAnParams*) (soff))->~G__TROOTcLcLMathcLcLGSLSimAnParams();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnParams* dest = (ROOT::Math::GSLSimAnParams*) G__getstructoffset();
   *dest = *(ROOT::Math::GSLSimAnParams*) libp->para[0].ref;
   const ROOT::Math::GSLSimAnParams& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLSimAnnealing */
static int G__G__MathMore_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnnealing* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLSimAnnealing[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GSLSimAnnealing[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLSimAnnealing;
     } else {
       p = new((void*) gvp) ROOT::Math::GSLSimAnnealing;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 105, (long) ((ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Solve(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (bool) G__int(libp->para[4])));
      break;
   case 4:
      G__letint(result7, 105, (long) ((ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Solve(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_238_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) ((ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Solve(*(ROOT::Math::GSLSimAnFunc*) libp->para[0].ref, (bool) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Solve(*(ROOT::Math::GSLSimAnFunc*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_238_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GSLSimAnParams& obj = ((ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Params();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_238_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GSLSimAnParams& obj = ((const ROOT::Math::GSLSimAnnealing*) G__getstructoffset())->Params();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLSimAnnealing G__TROOTcLcLMathcLcLGSLSimAnnealing;
static int G__G__MathMore_238_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLSimAnnealing*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLSimAnnealing*) (soff+(sizeof(ROOT::Math::GSLSimAnnealing)*i)))->~G__TROOTcLcLMathcLcLGSLSimAnnealing();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLSimAnnealing*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLSimAnnealing*) (soff))->~G__TROOTcLcLMathcLcLGSLSimAnnealing();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GSLSimAnMinimizer */
static int G__G__MathMore_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GSLSimAnMinimizer* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GSLSimAnMinimizer((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GSLSimAnMinimizer((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLSimAnMinimizer[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GSLSimAnMinimizer[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GSLSimAnMinimizer;
       } else {
         p = new((void*) gvp) ROOT::Math::GSLSimAnMinimizer;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GSLSimAnMinimizer G__TROOTcLcLMathcLcLGSLSimAnMinimizer;
static int G__G__MathMore_239_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GSLSimAnMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GSLSimAnMinimizer*) (soff+(sizeof(ROOT::Math::GSLSimAnMinimizer)*i)))->~G__TROOTcLcLMathcLcLGSLSimAnMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GSLSimAnMinimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GSLSimAnMinimizer*) (soff))->~G__TROOTcLcLMathcLcLGSLSimAnMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Vavilov */
static int G__G__MathMore_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Pdf((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Cdf((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Cdf_c((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Quantile((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Quantile_c((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Vavilov*) G__getstructoffset())->SetKappaBeta2((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->GetLambdaMin());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->GetLambdaMax());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->GetKappa());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->GetBeta2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Mode());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Vavilov*) G__getstructoffset())->Mode((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Mean());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Variance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Skewness());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Vavilov*) G__getstructoffset())->Kurtosis());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::Vavilov::Mean((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::Vavilov::Variance((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::Vavilov::Skewness((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_240_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::Vavilov::Kurtosis((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Vavilov G__TROOTcLcLMathcLcLVavilov;
static int G__G__MathMore_240_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Vavilov*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Vavilov*) (soff+(sizeof(ROOT::Math::Vavilov)*i)))->~G__TROOTcLcLMathcLcLVavilov();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Vavilov*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Vavilov*) (soff))->~G__TROOTcLcLMathcLcLVavilov();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_240_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Vavilov* dest = (ROOT::Math::Vavilov*) G__getstructoffset();
   *dest = *(ROOT::Math::Vavilov*) libp->para[0].ref;
   const ROOT::Math::Vavilov& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VavilovAccurate */
static int G__G__MathMore_241_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurate* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurate(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurate(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurate(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurate(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurate((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurate((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurate((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurate((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::VavilovAccurate[n];
       } else {
         p = new((void*) gvp) ROOT::Math::VavilovAccurate[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::VavilovAccurate;
       } else {
         p = new((void*) gvp) ROOT::Math::VavilovAccurate;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::VavilovAccurate*) G__getstructoffset())->Set((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::VavilovAccurate*) G__getstructoffset())->Set((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::VavilovAccurate*) G__getstructoffset())->Set((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VavilovAccurate*) G__getstructoffset())->GetEpsilonPM());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VavilovAccurate*) G__getstructoffset())->GetEpsilon());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VavilovAccurate*) G__getstructoffset())->GetNTerms());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::VavilovAccurate::GetInstance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_241_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::VavilovAccurate::GetInstance((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_241_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VavilovAccurate* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VavilovAccurate(*(ROOT::Math::VavilovAccurate*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VavilovAccurate G__TROOTcLcLMathcLcLVavilovAccurate;
static int G__G__MathMore_241_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VavilovAccurate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VavilovAccurate*) (soff+(sizeof(ROOT::Math::VavilovAccurate)*i)))->~G__TROOTcLcLMathcLcLVavilovAccurate();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VavilovAccurate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VavilovAccurate*) (soff))->~G__TROOTcLcLMathcLcLVavilovAccurate();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_241_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurate* dest = (ROOT::Math::VavilovAccurate*) G__getstructoffset();
   *dest = *(ROOT::Math::VavilovAccurate*) libp->para[0].ref;
   const ROOT::Math::VavilovAccurate& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VavilovAccuratePdf */
static int G__G__MathMore_243_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccuratePdf* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccuratePdf[n];
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccuratePdf[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccuratePdf;
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccuratePdf;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_243_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccuratePdf* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::VavilovAccuratePdf((double*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::VavilovAccuratePdf((double*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_243_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VavilovAccuratePdf* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VavilovAccuratePdf(*(ROOT::Math::VavilovAccuratePdf*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VavilovAccuratePdf G__TROOTcLcLMathcLcLVavilovAccuratePdf;
static int G__G__MathMore_243_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VavilovAccuratePdf*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VavilovAccuratePdf*) (soff+(sizeof(ROOT::Math::VavilovAccuratePdf)*i)))->~G__TROOTcLcLMathcLcLVavilovAccuratePdf();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VavilovAccuratePdf*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VavilovAccuratePdf*) (soff))->~G__TROOTcLcLMathcLcLVavilovAccuratePdf();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_243_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccuratePdf* dest = (ROOT::Math::VavilovAccuratePdf*) G__getstructoffset();
   *dest = *(ROOT::Math::VavilovAccuratePdf*) libp->para[0].ref;
   const ROOT::Math::VavilovAccuratePdf& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VavilovAccurateCdf */
static int G__G__MathMore_244_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateCdf* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurateCdf[n];
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurateCdf[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurateCdf;
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurateCdf;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_244_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateCdf* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::VavilovAccurateCdf((double*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::VavilovAccurateCdf((double*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_244_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VavilovAccurateCdf* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VavilovAccurateCdf(*(ROOT::Math::VavilovAccurateCdf*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VavilovAccurateCdf G__TROOTcLcLMathcLcLVavilovAccurateCdf;
static int G__G__MathMore_244_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VavilovAccurateCdf*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VavilovAccurateCdf*) (soff+(sizeof(ROOT::Math::VavilovAccurateCdf)*i)))->~G__TROOTcLcLMathcLcLVavilovAccurateCdf();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VavilovAccurateCdf*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VavilovAccurateCdf*) (soff))->~G__TROOTcLcLMathcLcLVavilovAccurateCdf();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_244_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateCdf* dest = (ROOT::Math::VavilovAccurateCdf*) G__getstructoffset();
   *dest = *(ROOT::Math::VavilovAccurateCdf*) libp->para[0].ref;
   const ROOT::Math::VavilovAccurateCdf& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VavilovAccurateQuantile */
static int G__G__MathMore_245_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateQuantile* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurateQuantile[n];
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurateQuantile[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovAccurateQuantile;
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovAccurateQuantile;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_245_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateQuantile* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::VavilovAccurateQuantile((double*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::VavilovAccurateQuantile((double*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_245_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VavilovAccurateQuantile* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VavilovAccurateQuantile(*(ROOT::Math::VavilovAccurateQuantile*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VavilovAccurateQuantile G__TROOTcLcLMathcLcLVavilovAccurateQuantile;
static int G__G__MathMore_245_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VavilovAccurateQuantile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VavilovAccurateQuantile*) (soff+(sizeof(ROOT::Math::VavilovAccurateQuantile)*i)))->~G__TROOTcLcLMathcLcLVavilovAccurateQuantile();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VavilovAccurateQuantile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VavilovAccurateQuantile*) (soff))->~G__TROOTcLcLMathcLcLVavilovAccurateQuantile();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_245_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovAccurateQuantile* dest = (ROOT::Math::VavilovAccurateQuantile*) G__getstructoffset();
   *dest = *(ROOT::Math::VavilovAccurateQuantile*) libp->para[0].ref;
   const ROOT::Math::VavilovAccurateQuantile& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VavilovFast */
static int G__G__MathMore_246_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovFast* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovFast((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovFast((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::VavilovFast((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::VavilovFast((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::VavilovFast[n];
       } else {
         p = new((void*) gvp) ROOT::Math::VavilovFast[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::VavilovFast;
       } else {
         p = new((void*) gvp) ROOT::Math::VavilovFast;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_246_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::VavilovFast::GetInstance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_246_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::Math::VavilovFast::GetInstance((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_246_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::VavilovFast* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::VavilovFast(*(ROOT::Math::VavilovFast*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VavilovFast G__TROOTcLcLMathcLcLVavilovFast;
static int G__G__MathMore_246_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VavilovFast*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VavilovFast*) (soff+(sizeof(ROOT::Math::VavilovFast)*i)))->~G__TROOTcLcLMathcLcLVavilovFast();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VavilovFast*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VavilovFast*) (soff))->~G__TROOTcLcLMathcLcLVavilovFast();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_246_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VavilovFast* dest = (ROOT::Math::VavilovFast*) G__getstructoffset();
   *dest = *(ROOT::Math::VavilovFast*) libp->para[0].ref;
   const ROOT::Math::VavilovFast& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngMT> */
static int G__G__MathMore_247_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngMT>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngMT>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngMT>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngMT>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngMT>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngMT>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngMT>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngMT>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngMT>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngMT>(*(ROOT::Math::GSLRngMT*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngMT>(*(ROOT::Math::GSLRngMT*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_247_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_247_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngMT>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngMT>(*(ROOT::Math::Random<ROOT::Math::GSLRngMT>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngMT> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR;
static int G__G__MathMore_247_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngMT>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngMT>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngMT>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngMT>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_247_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngMT>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngMT>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngMT>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngMT>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngTaus> */
static int G__G__MathMore_248_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngTaus>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngTaus>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngTaus>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngTaus>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngTaus>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngTaus>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngTaus>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngTaus>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngTaus>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngTaus>(*(ROOT::Math::GSLRngTaus*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngTaus>(*(ROOT::Math::GSLRngTaus*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_248_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_248_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngTaus>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngTaus>(*(ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngTaus> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR;
static int G__G__MathMore_248_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngTaus>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_248_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngTaus>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngTaus>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngTaus>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngRanLux> */
static int G__G__MathMore_249_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLux>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLux>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLux>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLux>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLux>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLux>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLux>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLux>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLux>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLux>(*(ROOT::Math::GSLRngRanLux*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLux>(*(ROOT::Math::GSLRngRanLux*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_249_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_249_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLux>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLux>(*(ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngRanLux> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR;
static int G__G__MathMore_249_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLux>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_249_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLux>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngRanLux>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> */
static int G__G__MathMore_250_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>(*(ROOT::Math::GSLRngRanLuxS1*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>(*(ROOT::Math::GSLRngRanLuxS1*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_250_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_250_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>(*(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR;
static int G__G__MathMore_250_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_250_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> */
static int G__G__MathMore_251_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>(*(ROOT::Math::GSLRngRanLuxS2*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>(*(ROOT::Math::GSLRngRanLuxS2*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_251_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_251_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>(*(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR;
static int G__G__MathMore_251_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_251_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> */
static int G__G__MathMore_252_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>(*(ROOT::Math::GSLRngRanLuxD1*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>(*(ROOT::Math::GSLRngRanLuxD1*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_252_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_252_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>(*(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR;
static int G__G__MathMore_252_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_252_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> */
static int G__G__MathMore_253_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>(*(ROOT::Math::GSLRngRanLuxD2*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>(*(ROOT::Math::GSLRngRanLuxD2*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_253_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_253_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>(*(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR;
static int G__G__MathMore_253_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_253_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> */
static int G__G__MathMore_254_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>;
     } else {
       p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>((unsigned int) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>((unsigned int) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>(*(ROOT::Math::GSLRngGFSR4*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>(*(ROOT::Math::GSLRngGFSR4*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Uniform((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Rndm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->RndmArray((int) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->EngineSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->SetSeed((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Gaus((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausBM((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausBM());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausR((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausR((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GausR());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->GaussianTail((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Gaussian2D((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Exp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->BreitWigner((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Landau((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Landau((double) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->LogNormal((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->ChiSquare((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->FDist((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->tDist((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Circle(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (double) G__double(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Sphere(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Poisson((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Binomial((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->NegativeBinomial((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathMore_254_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<unsigned int>* pobj;
         vector<unsigned int> xobj = ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset())->Multinomial((unsigned int) G__int(libp->para[0]), *(vector<double>*) libp->para[1].ref);
         pobj = new vector<unsigned int>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathMore_254_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>(*(ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR;
static int G__G__MathMore_254_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) (soff+(sizeof(ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>)*i)))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) (soff))->~G__TROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathMore_254_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>* dest = (ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) G__getstructoffset();
   *dest = *(ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*) libp->para[0].ref;
   const ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* ROOT */

/* ROOT::Math */

/* ROOT::MathMore */

/* ROOT::Math::Polynomial */

/* ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> */

/* ROOT::Math::Derivator */

/* ROOT::Math::Interpolator */

/* ROOT::Math::GSLRootFinder */

/* ROOT::Math::GSLRootFinderDeriv */

/* ROOT::Math::Roots */

/* ROOT::Math::Roots::Bisection */

/* ROOT::Math::Roots::FalsePos */

/* ROOT::Math::Roots::Brent */

/* ROOT::Math::Roots::Newton */

/* ROOT::Math::Roots::Secant */

/* ROOT::Math::Roots::Steffenson */

/* ROOT::Math::Integration */

/* ROOT::Math::GSLIntegrator */

/* ROOT::Math::VegasParameters */

/* ROOT::Math::MiserParameters */

/* ROOT::Math::GSLMCIntegrator */

/* ROOT::Math::Minim1D */

/* ROOT::Math::GSLMinimizer1D */

/* ROOT::Math::Chebyshev */

/* ROOT::Math::GSLRandomEngine */

/* ROOT::Math::GSLRngMT */

/* ROOT::Math::GSLRngRanLux */

/* ROOT::Math::GSLRngRanLuxS1 */

/* ROOT::Math::GSLRngRanLuxS2 */

/* ROOT::Math::GSLRngRanLuxD1 */

/* ROOT::Math::GSLRngRanLuxD2 */

/* ROOT::Math::GSLRngTaus */

/* ROOT::Math::GSLRngGFSR4 */

/* ROOT::Math::KelvinFunctions */

/* ROOT::Math::GSLMinimizer */

/* ROOT::Math::LSResidualFunc */

/* ROOT::Math::GSLNLSMinimizer */

/* ROOT::Math::GSLSimAnFunc */

/* ROOT::Math::GSLSimAnParams */

/* ROOT::Math::GSLSimAnnealing */

/* ROOT::Math::GSLSimAnMinimizer */

/* ROOT::Math::Vavilov */

/* ROOT::Math::VavilovAccurate */

/* ROOT::Math::VavilovAccuratePdf */

/* ROOT::Math::VavilovAccurateCdf */

/* ROOT::Math::VavilovAccurateQuantile */

/* ROOT::Math::VavilovFast */

/* ROOT::Math::Random<ROOT::Math::GSLRngMT> */

/* ROOT::Math::Random<ROOT::Math::GSLRngTaus> */

/* ROOT::Math::Random<ROOT::Math::GSLRngRanLux> */

/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> */

/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> */

/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> */

/* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> */

/* ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__MathMore {
 public:
  G__Sizep2memfuncG__MathMore(): p(&G__Sizep2memfuncG__MathMore::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__MathMore::*p)();
};

size_t G__get_sizep2memfuncG__MathMore()
{
  G__Sizep2memfuncG__MathMore a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */
static long G__2vbo_ROOTcLcLMathcLcLPolynomial_ROOTcLcLMathcLcLIBaseFunctionOneDim_3(long pobject) {
  ROOT::Math::Polynomial *G__Lderived=(ROOT::Math::Polynomial*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_ROOTcLcLMathcLcLIBaseFunctionOneDim_2(long pobject) {
  ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> *G__Lderived=(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLLSResidualFunc_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::LSResidualFunc *G__Lderived=(ROOT::Math::LSResidualFunc*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLVavilovAccuratePdf_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::VavilovAccuratePdf *G__Lderived=(ROOT::Math::VavilovAccuratePdf*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLVavilovAccurateCdf_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::VavilovAccurateCdf *G__Lderived=(ROOT::Math::VavilovAccurateCdf*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLVavilovAccurateQuantile_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::VavilovAccurateQuantile *G__Lderived=(ROOT::Math::VavilovAccurateQuantile*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}


/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__MathMore() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial))) {
     ROOT::Math::Polynomial *G__Lderived;
     G__Lderived=(ROOT::Math::Polynomial*)0x1000;
     {
       ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> *G__Lpbase=(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IParametricGradFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricGradFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLPolynomial_ROOTcLcLMathcLcLIBaseFunctionOneDim_3,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       ROOT::Math::IGradientOneDim *G__Lpbase=(ROOT::Math::IGradientOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR))) {
     ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> *G__Lderived;
     G__Lderived=(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0x1000;
     {
       ROOT::Math::IParametricGradFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricGradFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR_ROOTcLcLMathcLcLIBaseFunctionOneDim_2,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder))) {
     ROOT::Math::GSLRootFinder *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRootFinder*)0x1000;
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv))) {
     ROOT::Math::GSLRootFinderDeriv *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRootFinderDeriv*)0x1000;
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection))) {
     ROOT::Math::Roots::Bisection *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::Bisection*)0x1000;
     {
       ROOT::Math::GSLRootFinder *G__Lpbase=(ROOT::Math::GSLRootFinder*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos))) {
     ROOT::Math::Roots::FalsePos *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::FalsePos*)0x1000;
     {
       ROOT::Math::GSLRootFinder *G__Lpbase=(ROOT::Math::GSLRootFinder*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent))) {
     ROOT::Math::Roots::Brent *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::Brent*)0x1000;
     {
       ROOT::Math::GSLRootFinder *G__Lpbase=(ROOT::Math::GSLRootFinder*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton))) {
     ROOT::Math::Roots::Newton *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::Newton*)0x1000;
     {
       ROOT::Math::GSLRootFinderDeriv *G__Lpbase=(ROOT::Math::GSLRootFinderDeriv*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant))) {
     ROOT::Math::Roots::Secant *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::Secant*)0x1000;
     {
       ROOT::Math::GSLRootFinderDeriv *G__Lpbase=(ROOT::Math::GSLRootFinderDeriv*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson))) {
     ROOT::Math::Roots::Steffenson *G__Lderived;
     G__Lderived=(ROOT::Math::Roots::Steffenson*)0x1000;
     {
       ROOT::Math::GSLRootFinderDeriv *G__Lpbase=(ROOT::Math::GSLRootFinderDeriv*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator))) {
     ROOT::Math::GSLIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GSLIntegrator*)0x1000;
     {
       ROOT::Math::VirtualIntegratorOneDim *G__Lpbase=(ROOT::Math::VirtualIntegratorOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator))) {
     ROOT::Math::GSLMCIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GSLMCIntegrator*)0x1000;
     {
       ROOT::Math::VirtualIntegratorMultiDim *G__Lpbase=(ROOT::Math::VirtualIntegratorMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D))) {
     ROOT::Math::GSLMinimizer1D *G__Lderived;
     G__Lderived=(ROOT::Math::GSLMinimizer1D*)0x1000;
     {
       ROOT::Math::IMinimizer1D *G__Lpbase=(ROOT::Math::IMinimizer1D*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIMinimizer1D),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT))) {
     ROOT::Math::GSLRngMT *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngMT*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux))) {
     ROOT::Math::GSLRngRanLux *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngRanLux*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1))) {
     ROOT::Math::GSLRngRanLuxS1 *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngRanLuxS1*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2))) {
     ROOT::Math::GSLRngRanLuxS2 *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngRanLuxS2*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1))) {
     ROOT::Math::GSLRngRanLuxD1 *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngRanLuxD1*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2))) {
     ROOT::Math::GSLRngRanLuxD2 *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngRanLuxD2*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus))) {
     ROOT::Math::GSLRngTaus *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngTaus*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4))) {
     ROOT::Math::GSLRngGFSR4 *G__Lderived;
     G__Lderived=(ROOT::Math::GSLRngGFSR4*)0x1000;
     {
       ROOT::Math::GSLRandomEngine *G__Lpbase=(ROOT::Math::GSLRandomEngine*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer))) {
     ROOT::Math::GSLMinimizer *G__Lderived;
     G__Lderived=(ROOT::Math::GSLMinimizer*)0x1000;
     {
       ROOT::Math::Minimizer *G__Lpbase=(ROOT::Math::Minimizer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc))) {
     ROOT::Math::LSResidualFunc *G__Lderived;
     G__Lderived=(ROOT::Math::LSResidualFunc*)0x1000;
     {
       ROOT::Math::IGradientFunctionMultiDim *G__Lpbase=(ROOT::Math::IGradientFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLLSResidualFunc_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer))) {
     ROOT::Math::GSLNLSMinimizer *G__Lderived;
     G__Lderived=(ROOT::Math::GSLNLSMinimizer*)0x1000;
     {
       ROOT::Math::Minimizer *G__Lpbase=(ROOT::Math::Minimizer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer))) {
     ROOT::Math::GSLSimAnMinimizer *G__Lderived;
     G__Lderived=(ROOT::Math::GSLSimAnMinimizer*)0x1000;
     {
       ROOT::Math::Minimizer *G__Lpbase=(ROOT::Math::Minimizer*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate))) {
     ROOT::Math::VavilovAccurate *G__Lderived;
     G__Lderived=(ROOT::Math::VavilovAccurate*)0x1000;
     {
       ROOT::Math::Vavilov *G__Lpbase=(ROOT::Math::Vavilov*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf))) {
     ROOT::Math::VavilovAccuratePdf *G__Lderived;
     G__Lderived=(ROOT::Math::VavilovAccuratePdf*)0x1000;
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLVavilovAccuratePdf_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf))) {
     ROOT::Math::VavilovAccurateCdf *G__Lderived;
     G__Lderived=(ROOT::Math::VavilovAccurateCdf*)0x1000;
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLVavilovAccurateCdf_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile))) {
     ROOT::Math::VavilovAccurateQuantile *G__Lderived;
     G__Lderived=(ROOT::Math::VavilovAccurateQuantile*)0x1000;
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLVavilovAccurateQuantile_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast))) {
     ROOT::Math::VavilovFast *G__Lderived;
     G__Lderived=(ROOT::Math::VavilovFast*)0x1000;
     {
       ROOT::Math::Vavilov *G__Lpbase=(ROOT::Math::Vavilov*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast),G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__MathMore() {

   /* Setting up typedef entry */
   G__search_typename2("Short_t",115,-1,0,-1);
   G__setnewtype(-1,"Signed Short integer 2 bytes (short)",0);
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("VoidFuncPtr_t",89,-1,0,-1);
   G__setnewtype(-1,"pointer to void function",0);
   G__search_typename2("ShowMembersFunc_t",89,-1,0,-1);
   G__setnewtype(-1,"void (*ShowMembersFunc_t)(void *obj, TMemberInspector &R__insp);",0);
   G__search_typename2("NewFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewFunc_t)(void *);",0);
   G__search_typename2("NewArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewArrFunc_t)(Long_t size, void *arena);",0);
   G__search_typename2("DelFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelFunc_t)(void *);",0);
   G__search_typename2("DelArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelArrFunc_t)(void *);",0);
   G__search_typename2("DesFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void  (*DesFunc_t)(void *);",0);
   G__search_typename2("DirAutoAdd_t",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__setnewtype(-1,"void  (*DirAutoAdd_t)(void *, TDirectory*);",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGenFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGenFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGradFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamGradFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ParamFunction<IParamGradFunction>",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseParFunc",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<double>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ParFunc",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::complex<double> >",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<complex<double> >",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("GSLFuncPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   G__setnewtype(-1,"double ( * GSLFuncPointer ) ( double, void * );",0);
   G__search_typename2("GSLFuncPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"double ( * GSLFuncPointer ) ( double, void *);",0);
   G__search_typename2("GSLFuncPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder));
   G__setnewtype(-1,"double ( * GSLFuncPointer ) ( double, void *);",0);
   G__search_typename2("GSLFuncPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv));
   G__setnewtype(-1,"double ( * GSLFuncPointer ) ( double, void *);",0);
   G__search_typename2("GSLFdFPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv));
   G__setnewtype(-1,"void ( * GSLFdFPointer ) ( double, void *, double *, double *);",0);
   G__search_typename2("Type",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("GSLMonteFuncPointer",89,-1,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   G__setnewtype(-1,"double ( * GSLMonteFuncPointer ) ( double *, size_t, void *);",0);
   G__search_typename2("vector<unsigned int>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("GSLRngRanLux1",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"for backward compatibility",0);
   G__search_typename2("GSLRngRanLux2",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"for backward compatibility",0);
   G__search_typename2("GSLRngRanLux48",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"for backward compatibility",0);
   G__search_typename2("vector<std::string>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::Math::EMinimVariableType>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<unsigned int,std::pair<double,double> >",117,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<unsigned int,pair<double,double> >",117,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<unsigned int,pair<double,double>,less<unsigned int> >",117,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodGradFunction",117,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<LSResidualFunc>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::Math::LSResidualFunc>",117,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ROOT */
static void G__setup_memvarROOT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   {
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math */
static void G__setup_memvarROOTcLcLMath(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType),-1,-2,1,G__FastAllocString(2048).Format("kDefault=%lldLL",(long long)ROOT::Math::kDefault).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType),-1,-2,1,G__FastAllocString(2048).Format("kFix=%lldLL",(long long)ROOT::Math::kFix).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType),-1,-2,1,G__FastAllocString(2048).Format("kBounds=%lldLL",(long long)ROOT::Math::kBounds).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType),-1,-2,1,G__FastAllocString(2048).Format("kLowBound=%lldLL",(long long)ROOT::Math::kLowBound).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType),-1,-2,1,G__FastAllocString(2048).Format("kUpBound=%lldLL",(long long)ROOT::Math::kUpBound).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType),-1,-2,1,G__FastAllocString(2048).Format("kConjugateFR=%lldLL",(long long)ROOT::Math::kConjugateFR).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType),-1,-2,1,G__FastAllocString(2048).Format("kConjugatePR=%lldLL",(long long)ROOT::Math::kConjugatePR).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType),-1,-2,1,G__FastAllocString(2048).Format("kVectorBFGS=%lldLL",(long long)ROOT::Math::kVectorBFGS).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType),-1,-2,1,G__FastAllocString(2048).Format("kVectorBFGS2=%lldLL",(long long)ROOT::Math::kVectorBFGS2).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType),-1,-2,1,G__FastAllocString(2048).Format("kSteepestDescent=%lldLL",(long long)ROOT::Math::kSteepestDescent).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::MathMore */
static void G__setup_memvarROOTcLcLMathMore(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathMore));
   {
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Polynomial */
static void G__setup_memvarROOTcLcLMathcLcLPolynomial(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   { ROOT::Math::Polynomial *p; p=(ROOT::Math::Polynomial*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fOrder=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fDerived_params=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR),G__defined_typename("vector<std::complex<double> >"),-1,4,"fRoots=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> */
static void G__setup_memvarROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR));
   { ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> *p; p=(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNpar=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,2,"fParams=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Derivator */
static void G__setup_memvarROOTcLcLMathcLcLDerivator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   { ROOT::Math::Derivator *p; p=(ROOT::Math::Derivator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLDerivator),-1,-1,4,"fDerivator=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Interpolator */
static void G__setup_memvarROOTcLcLMathcLcLInterpolator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator));
   { ROOT::Math::Interpolator *p; p=(ROOT::Math::Interpolator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLInterpolator),-1,-1,4,"fInterp=",0,"pointer to GSL interpolator class");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRootFinder */
static void G__setup_memvarROOTcLcLMathcLcLGSLRootFinder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder));
   { ROOT::Math::GSLRootFinder *p; p=(ROOT::Math::GSLRootFinder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper),-1,-1,4,"fFunction=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFSolver),-1,-1,4,"fS=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRoot=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXlow=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXup=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fIter=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fValidInterval=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRootFinderDeriv */
static void G__setup_memvarROOTcLcLMathcLcLGSLRootFinderDeriv(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv));
   { ROOT::Math::GSLRootFinderDeriv *p; p=(ROOT::Math::GSLRootFinderDeriv*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionDerivWrapper),-1,-1,4,"fFunction=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFdFSolver),-1,-1,4,"fS=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRoot=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fPrevRoot=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fIter=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fValidPoint=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots */
static void G__setup_memvarROOTcLcLMathcLcLRoots(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRoots));
   {
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::Bisection */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLBisection(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection));
   { ROOT::Math::Roots::Bisection *p; p=(ROOT::Math::Roots::Bisection*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::FalsePos */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLFalsePos(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos));
   { ROOT::Math::Roots::FalsePos *p; p=(ROOT::Math::Roots::FalsePos*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::Brent */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLBrent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent));
   { ROOT::Math::Roots::Brent *p; p=(ROOT::Math::Roots::Brent*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::Newton */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLNewton(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton));
   { ROOT::Math::Roots::Newton *p; p=(ROOT::Math::Roots::Newton*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::Secant */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLSecant(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant));
   { ROOT::Math::Roots::Secant *p; p=(ROOT::Math::Roots::Secant*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Roots::Steffenson */
static void G__setup_memvarROOTcLcLMathcLcLRootscLcLSteffenson(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson));
   { ROOT::Math::Roots::Steffenson *p; p=(ROOT::Math::Roots::Steffenson*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Integration */
static void G__setup_memvarROOTcLcLMathcLcLIntegration(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegration));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS15=%lldLL",(long long)ROOT::Math::Integration::kGAUSS15).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS21=%lldLL",(long long)ROOT::Math::Integration::kGAUSS21).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS31=%lldLL",(long long)ROOT::Math::Integration::kGAUSS31).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS41=%lldLL",(long long)ROOT::Math::Integration::kGAUSS41).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS51=%lldLL",(long long)ROOT::Math::Integration::kGAUSS51).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-2,1,G__FastAllocString(2048).Format("kGAUSS61=%lldLL",(long long)ROOT::Math::Integration::kGAUSS61).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGSLIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   { ROOT::Math::GSLIntegrator *p; p=(ROOT::Math::GSLIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-1,4,"fType=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule),-1,-1,4,"fRule=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fAbsTol=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelTol=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fSize=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fMaxIntervals=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fResult=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fError=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNEval=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper),-1,-1,4,"fFunction=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrationWorkspace),-1,-1,4,"fWorkspace=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VegasParameters */
static void G__setup_memvarROOTcLcLMathcLcLVegasParameters(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters));
   { ROOT::Math::VegasParameters *p; p=(ROOT::Math::VegasParameters*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->alpha)-(long)(p)),100,0,0,-1,-1,-1,1,"alpha=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->iterations)-(long)(p)),107,0,0,-1,G__defined_typename("size_t"),-1,1,"iterations=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->stage)-(long)(p)),105,0,0,-1,-1,-1,1,"stage=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->mode)-(long)(p)),105,0,0,-1,-1,-1,1,"mode=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->verbose)-(long)(p)),105,0,0,-1,-1,-1,1,"verbose=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::MiserParameters */
static void G__setup_memvarROOTcLcLMathcLcLMiserParameters(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters));
   { ROOT::Math::MiserParameters *p; p=(ROOT::Math::MiserParameters*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->estimate_frac)-(long)(p)),100,0,0,-1,-1,-1,1,"estimate_frac=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->min_calls)-(long)(p)),107,0,0,-1,G__defined_typename("size_t"),-1,1,"min_calls=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->min_calls_per_bisection)-(long)(p)),107,0,0,-1,G__defined_typename("size_t"),-1,1,"min_calls_per_bisection=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->alpha)-(long)(p)),100,0,0,-1,-1,-1,1,"alpha=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dither)-(long)(p)),100,0,0,-1,-1,-1,1,"dither=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLMCIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGSLMCIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   { ROOT::Math::GSLMCIntegrator *p; p=(ROOT::Math::GSLMCIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-1,4,"fType=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngWrapper),-1,-1,4,"fRng=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fCalls=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fAbsTol=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelTol=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fResult=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fError=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrationWorkspace),-1,-1,4,"fWorkspace=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMonteFunctionWrapper),-1,-1,4,"fFunction=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Minim1D */
static void G__setup_memvarROOTcLcLMathcLcLMinim1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1D));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1DcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kGOLDENSECTION=%lldLL",(long long)ROOT::Math::Minim1D::kGOLDENSECTION).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1DcLcLType),-1,-2,1,G__FastAllocString(2048).Format("kBRENT=%lldLL",(long long)ROOT::Math::Minim1D::kBRENT).data(),0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLMinimizer1D */
static void G__setup_memvarROOTcLcLMathcLcLGSLMinimizer1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D));
   { ROOT::Math::GSLMinimizer1D *p; p=(ROOT::Math::GSLMinimizer1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXmin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXlow=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fXup=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fLow=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fUp=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fIter=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,"status of last minimization (==0 ok =1 failed)");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fIsSet=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSL1DMinimizerWrapper),-1,-1,4,"fMinimizer=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper),-1,-1,4,"fFunction=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Chebyshev */
static void G__setup_memvarROOTcLcLMathcLcLChebyshev(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev));
   { ROOT::Math::Chebyshev *p; p=(ROOT::Math::Chebyshev*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"fOrder=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLChebSeries),-1,-1,4,"fSeries=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper),-1,-1,4,"fFunction=",0,"pointer to function");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRandomEngine */
static void G__setup_memvarROOTcLcLMathcLcLGSLRandomEngine(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine));
   { ROOT::Math::GSLRandomEngine *p; p=(ROOT::Math::GSLRandomEngine*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngWrapper),-1,-1,4,"fRng=",0,"pointer to GSL generator wrapper (managed by the class)");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fCurTime=",0,"current time used to seed the generator");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngMT */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngMT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT));
   { ROOT::Math::GSLRngMT *p; p=(ROOT::Math::GSLRngMT*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngRanLux */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngRanLux(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux));
   { ROOT::Math::GSLRngRanLux *p; p=(ROOT::Math::GSLRngRanLux*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngRanLuxS1 */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxS1(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1));
   { ROOT::Math::GSLRngRanLuxS1 *p; p=(ROOT::Math::GSLRngRanLuxS1*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngRanLuxS2 */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxS2(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2));
   { ROOT::Math::GSLRngRanLuxS2 *p; p=(ROOT::Math::GSLRngRanLuxS2*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngRanLuxD1 */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxD1(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1));
   { ROOT::Math::GSLRngRanLuxD1 *p; p=(ROOT::Math::GSLRngRanLuxD1*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngRanLuxD2 */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxD2(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2));
   { ROOT::Math::GSLRngRanLuxD2 *p; p=(ROOT::Math::GSLRngRanLuxD2*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngTaus */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngTaus(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus));
   { ROOT::Math::GSLRngTaus *p; p=(ROOT::Math::GSLRngTaus*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLRngGFSR4 */
static void G__setup_memvarROOTcLcLMathcLcLGSLRngGFSR4(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4));
   { ROOT::Math::GSLRngGFSR4 *p; p=(ROOT::Math::GSLRngGFSR4*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::KelvinFunctions */
static void G__setup_memvarROOTcLcLMathcLcLKelvinFunctions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions));
   { ROOT::Math::KelvinFunctions *p; p=(ROOT::Math::KelvinFunctions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-2,2,"fgMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-2,2,"fgEpsilon=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLMinimizer */
static void G__setup_memvarROOTcLcLMathcLcLGSLMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer));
   { ROOT::Math::GSLMinimizer *p; p=(ROOT::Math::GSLMinimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiMinimizer),-1,-1,4,"fGSLMultiMin=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),G__defined_typename("IMultiGradFunction"),-1,4,"fObjFunc=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fMinVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fLSTolerance=",0,"Line Search Tolerance");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fValues=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fSteps=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<std::string>"),-1,4,"fNames=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR),G__defined_typename("vector<ROOT::Math::EMinimVariableType>"),-1,4,"fVarTypes=",0,"vector specifyng the type of variables");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),G__defined_typename("map<unsigned int,std::pair<double,double> >"),-1,4,"fBounds=",0,"map specifying the bound using as key the parameter index");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::LSResidualFunc */
static void G__setup_memvarROOTcLcLMathcLcLLSResidualFunc(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc));
   { ROOT::Math::LSResidualFunc *p; p=(ROOT::Math::LSResidualFunc*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fIndex=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),G__defined_typename("FitMethodFunction"),-1,4,"fChi2=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fX2=",0,"cached vector");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLNLSMinimizer */
static void G__setup_memvarROOTcLcLMathcLcLGSLNLSMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer));
   { ROOT::Math::GSLNLSMinimizer *p; p=(ROOT::Math::GSLNLSMinimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,"dimension of the function to be minimized ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNFree=",0,"dimension of the internal function to be minimized ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fSize=",0,"number of fit points (residuals)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiFit),-1,-1,4,"fGSLMultiFit=",0,"pointer to GSL multi fit solver ");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),G__defined_typename("FitMethodFunction"),-1,4,"fObjFunc=",0,"pointer to Least square function");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fMinVal=",0,"minimum function value");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fEdm=",0,"edm value");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fLSTolerance=",0,"Line Search Tolerance");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fValues=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fErrors=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fCovMatrix=",0,"cov matrix (stored as cov[ i * dim + j] ");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fSteps=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<std::string>"),-1,4,"fNames=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR),G__defined_typename("vector<LSResidualFunc>"),-1,4,"fResiduals=",0,"! transient Vector of the residual functions");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR),G__defined_typename("vector<ROOT::Math::EMinimVariableType>"),-1,4,"fVarTypes=",0,"vector specifyng the type of variables");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),G__defined_typename("map<unsigned int,std::pair<double,double> >"),-1,4,"fBounds=",0,"map specifying the bound using as key the parameter index");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLSimAnFunc */
static void G__setup_memvarROOTcLcLMathcLcLGSLSimAnFunc(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc));
   { ROOT::Math::GSLSimAnFunc *p; p=(ROOT::Math::GSLSimAnFunc*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fScale=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),G__defined_typename("IMultiGenFunction"),-1,4,"fFunc=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLSimAnParams */
static void G__setup_memvarROOTcLcLMathcLcLGSLSimAnParams(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams));
   { ROOT::Math::GSLSimAnParams *p; p=(ROOT::Math::GSLSimAnParams*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->n_tries)-(long)(p)),105,0,0,-1,-1,-1,1,"n_tries=",0,"number of points to try for each step");
   G__memvar_setup((void*)((long)(&p->iters_fixed_T)-(long)(p)),105,0,0,-1,-1,-1,1,"iters_fixed_T=",0,"number of iterations at each temperature");
   G__memvar_setup((void*)((long)(&p->step_size)-(long)(p)),100,0,0,-1,-1,-1,1,"step_size=",0,"max step size used in random walk");
   G__memvar_setup((void*)((long)(&p->k)-(long)(p)),100,0,0,-1,-1,-1,1,"k=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->t_initial)-(long)(p)),100,0,0,-1,-1,-1,1,"t_initial=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->mu)-(long)(p)),100,0,0,-1,-1,-1,1,"mu=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->t_min)-(long)(p)),100,0,0,-1,-1,-1,1,"t_min=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLSimAnnealing */
static void G__setup_memvarROOTcLcLMathcLcLGSLSimAnnealing(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing));
   { ROOT::Math::GSLSimAnnealing *p; p=(ROOT::Math::GSLSimAnnealing*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams),-1,-1,4,"fParams=",0,"parameters for GSLSimAnnealig");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GSLSimAnMinimizer */
static void G__setup_memvarROOTcLcLMathcLcLGSLSimAnMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer));
   { ROOT::Math::GSLSimAnMinimizer *p; p=(ROOT::Math::GSLSimAnMinimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,"dimension of the function to be minimized ");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fOwnFunc=",0,"flag to indicate if objective function is managed ");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing),-1,-1,4,"fSolver=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),G__defined_typename("IMultiGenFunction"),-1,4,"fObjFunc=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fMinVal=",0,"minimum values ");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fValues=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fSteps=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<std::string>"),-1,4,"fNames=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR),G__defined_typename("vector<ROOT::Math::EMinimVariableType>"),-1,4,"fVarTypes=",0,"vector specifyng the type of variables");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR),G__defined_typename("map<unsigned int,std::pair<double,double> >"),-1,4,"fBounds=",0,"map specifying the bound using as key the parameter index");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Vavilov */
static void G__setup_memvarROOTcLcLMathcLcLVavilov(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov));
   { ROOT::Math::Vavilov *p; p=(ROOT::Math::Vavilov*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VavilovAccurate */
static void G__setup_memvarROOTcLcLMathcLcLVavilovAccurate(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate));
   { ROOT::Math::VavilovAccurate *p; p=(ROOT::Math::VavilovAccurate*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratecLcLdA),-1,-2,4,"MAXTERMS=500LL",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fH[8]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fT0=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fT1=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fT=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fOmega=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fA_pdf[501]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fB_pdf[501]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fA_cdf[501]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fB_cdf[501]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fX0=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fKappa=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fBeta2=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fEpsilonPM=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fEpsilon=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fQuantileInit=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNQuant=",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratecLcLdA),-1,-2,4,"kNquantMax=32LL",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fQuant[32]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fLambda[32]=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate),-1,-2,4,"fgInstance=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VavilovAccuratePdf */
static void G__setup_memvarROOTcLcLMathcLcLVavilovAccuratePdf(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf));
   { ROOT::Math::VavilovAccuratePdf *p; p=(ROOT::Math::VavilovAccuratePdf*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fP[5]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VavilovAccurateCdf */
static void G__setup_memvarROOTcLcLMathcLcLVavilovAccurateCdf(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf));
   { ROOT::Math::VavilovAccurateCdf *p; p=(ROOT::Math::VavilovAccurateCdf*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fP[5]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VavilovAccurateQuantile */
static void G__setup_memvarROOTcLcLMathcLcLVavilovAccurateQuantile(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile));
   { ROOT::Math::VavilovAccurateQuantile *p; p=(ROOT::Math::VavilovAccurateQuantile*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fP[5]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VavilovFast */
static void G__setup_memvarROOTcLcLMathcLcLVavilovFast(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast));
   { ROOT::Math::VavilovFast *p; p=(ROOT::Math::VavilovFast*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fKappa=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fBeta2=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fAC[14]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fHC[9]=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fWCM[201]=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fItype=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fNpt=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast),-1,-2,4,"fgInstance=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngMT> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   { ROOT::Math::Random<ROOT::Math::GSLRngMT> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngMT>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngTaus> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   { ROOT::Math::Random<ROOT::Math::GSLRngTaus> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngTaus>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLux> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   { ROOT::Math::Random<ROOT::Math::GSLRngRanLux> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngRanLux>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   { ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   { ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   { ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   { ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> */
static void G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   { ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> *p; p=(ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4),-1,-1,4,"fEngine=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__MathMore() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncROOT(void) {
   /* ROOT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOT));
   G__memfunc_setup("CreateClass",1098,G__G__MathMore_19_0_1, 85, G__get_linked_tagnum(&G__G__MathMoreLN_TClass), -1, 0, 9, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info U 'TVirtualIsAProxy' - 0 - isa "
"Y - 'ShowMembersFunc_t' 0 - show C - - 10 - dfil "
"C - - 10 - ifil i - 'Int_t' 0 - dl "
"i - 'Int_t' 0 - il", (char*)NULL, (void*) G__func2void( (TClass* (*)(const char*, Version_t, const type_info&, TVirtualIsAProxy*, ShowMembersFunc_t, const char*, const char*, Int_t, Int_t))(&ROOT::CreateClass) ), 0);
   G__memfunc_setup("AddClass",767,G__G__MathMore_19_0_2, 121, -1, -1, 0, 5, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info Y - 'VoidFuncPtr_t' 0 - dict "
"i - 'Int_t' 0 - pragmabits", (char*)NULL, (void*) G__func2void( (void (*)(const char*, Version_t, const type_info&, VoidFuncPtr_t, Int_t))(&ROOT::AddClass) ), 0);
   G__memfunc_setup("RemoveClass",1124,G__G__MathMore_19_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - cname", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::RemoveClass) ), 0);
   G__memfunc_setup("ResetClassVersion",1759,G__G__MathMore_19_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"U 'TClass' - 0 - - C - - 10 - - "
"s - 'Short_t' 0 - -", (char*)NULL, (void*) G__func2void( (void (*)(TClass*, const char*, Short_t))(&ROOT::ResetClassVersion) ), 0);
   G__memfunc_setup("RegisterClassTemplate",2167,G__G__MathMore_19_0_5, 85, G__get_linked_tagnum(&G__G__MathMoreLN_TNamed), -1, 0, 3, 1, 1, 0, 
"C - - 10 - name C - - 10 - file "
"i - 'Int_t' 0 - line", (char*)NULL, (void*) G__func2void( (TNamed* (*)(const char*, const char*, Int_t))(&ROOT::RegisterClassTemplate) ), 0);
   G__memfunc_setup("DefineBehavior",1403,G__G__MathMore_19_0_6, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLTInitBehavior), -1, 0, 2, 1, 1, 1, 
"Y - - 0 - - Y - - 0 - -", (char*)NULL, (void*) G__func2void( (const ROOT::TInitBehavior* (*)(void*, void*))(&ROOT::DefineBehavior) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMath(void) {
   /* ROOT::Math */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMath));
   G__memfunc_setup("noncentral_chisquared_pdf",2645,G__G__MathMore_99_0_1, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 - lambda", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::noncentral_chisquared_pdf) ), 0);
   G__memfunc_setup("tdistribution_quantile_c",2584,G__G__MathMore_99_0_2, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::tdistribution_quantile_c) ), 0);
   G__memfunc_setup("tdistribution_quantile",2390,G__G__MathMore_99_0_3, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::tdistribution_quantile) ), 0);
   G__memfunc_setup("assoc_laguerre",1487,G__G__MathMore_99_0_4, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - d - - 0 - m "
"d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, double))(&ROOT::Math::assoc_laguerre) ), 0);
   G__memfunc_setup("assoc_legendre",1470,G__G__MathMore_99_0_5, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - h - - 0 - - "
"d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, unsigned int, double))(&ROOT::Math::assoc_legendre) ), 0);
   G__memfunc_setup("comp_ellint_1",1318,G__G__MathMore_99_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - k", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::comp_ellint_1) ), 0);
   G__memfunc_setup("comp_ellint_2",1319,G__G__MathMore_99_0_7, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - k", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::comp_ellint_2) ), 0);
   G__memfunc_setup("comp_ellint_3",1320,G__G__MathMore_99_0_8, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - k", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::comp_ellint_3) ), 0);
   G__memfunc_setup("conf_hyperg",1172,G__G__MathMore_99_0_9, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - z", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::conf_hyperg) ), 0);
   G__memfunc_setup("conf_hypergU",1257,G__G__MathMore_99_0_10, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - z", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::conf_hypergU) ), 0);
   G__memfunc_setup("cyl_bessel_i",1261,G__G__MathMore_99_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cyl_bessel_i) ), 0);
   G__memfunc_setup("cyl_bessel_j",1262,G__G__MathMore_99_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cyl_bessel_j) ), 0);
   G__memfunc_setup("cyl_bessel_k",1263,G__G__MathMore_99_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cyl_bessel_k) ), 0);
   G__memfunc_setup("cyl_neumann",1177,G__G__MathMore_99_0_14, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cyl_neumann) ), 0);
   G__memfunc_setup("ellint_1",792,G__G__MathMore_99_0_15, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - k d - - 0 - phi", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::ellint_1) ), 0);
   G__memfunc_setup("ellint_2",793,G__G__MathMore_99_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - k d - - 0 - phi", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::ellint_2) ), 0);
   G__memfunc_setup("ellint_3",794,G__G__MathMore_99_0_17, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - n d - - 0 - k "
"d - - 0 - phi", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::ellint_3) ), 0);
   G__memfunc_setup("expint",664,G__G__MathMore_99_0_18, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::expint) ), 0);
   G__memfunc_setup("hyperg",655,G__G__MathMore_99_0_19, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::hyperg) ), 0);
   G__memfunc_setup("laguerre",855,G__G__MathMore_99_0_20, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::laguerre) ), 0);
   G__memfunc_setup("legendre",838,G__G__MathMore_99_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::legendre) ), 0);
   G__memfunc_setup("riemann_zeta",1277,G__G__MathMore_99_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::riemann_zeta) ), 0);
   G__memfunc_setup("sph_bessel",1064,G__G__MathMore_99_0_23, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::sph_bessel) ), 0);
   G__memfunc_setup("sph_legendre",1264,G__G__MathMore_99_0_24, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - h - - 0 - - "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, unsigned int, double))(&ROOT::Math::sph_legendre) ), 0);
   G__memfunc_setup("sph_neumann",1180,G__G__MathMore_99_0_25, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::sph_neumann) ), 0);
   G__memfunc_setup("airy_Ai",702,G__G__MathMore_99_0_26, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::airy_Ai) ), 0);
   G__memfunc_setup("airy_Bi",703,G__G__MathMore_99_0_27, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::airy_Bi) ), 0);
   G__memfunc_setup("airy_Ai_deriv",1335,G__G__MathMore_99_0_28, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::airy_Ai_deriv) ), 0);
   G__memfunc_setup("airy_Bi_deriv",1336,G__G__MathMore_99_0_29, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::airy_Bi_deriv) ), 0);
   G__memfunc_setup("airy_zero_Ai",1245,G__G__MathMore_99_0_30, 100, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int))(&ROOT::Math::airy_zero_Ai) ), 0);
   G__memfunc_setup("airy_zero_Bi",1246,G__G__MathMore_99_0_31, 100, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int))(&ROOT::Math::airy_zero_Bi) ), 0);
   G__memfunc_setup("airy_zero_Ai_deriv",1878,G__G__MathMore_99_0_32, 100, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int))(&ROOT::Math::airy_zero_Ai_deriv) ), 0);
   G__memfunc_setup("airy_zero_Bi_deriv",1879,G__G__MathMore_99_0_33, 100, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int))(&ROOT::Math::airy_zero_Bi_deriv) ), 0);
   G__memfunc_setup("wigner_3j",904,G__G__MathMore_99_0_34, 100, -1, -1, 0, 6, 1, 1, 0, 
"i - - 0 - ja i - - 0 - jb "
"i - - 0 - jc i - - 0 - ma "
"i - - 0 - mb i - - 0 - mc", (char*)NULL, (void*) G__func2void( (double (*)(int, int, int, int, int, int))(&ROOT::Math::wigner_3j) ), 0);
   G__memfunc_setup("wigner_6j",907,G__G__MathMore_99_0_35, 100, -1, -1, 0, 6, 1, 1, 0, 
"i - - 0 - ja i - - 0 - jb "
"i - - 0 - jc i - - 0 - jd "
"i - - 0 - je i - - 0 - jf", (char*)NULL, (void*) G__func2void( (double (*)(int, int, int, int, int, int))(&ROOT::Math::wigner_6j) ), 0);
   G__memfunc_setup("wigner_9j",910,G__G__MathMore_99_0_36, 100, -1, -1, 0, 9, 1, 1, 0, 
"i - - 0 - ja i - - 0 - jb "
"i - - 0 - jc i - - 0 - jd "
"i - - 0 - je i - - 0 - jf "
"i - - 0 - jg i - - 0 - jh "
"i - - 0 - ji", (char*)NULL, (void*) G__func2void( (double (*)(int, int, int, int, int, int, int, int, int))(&ROOT::Math::wigner_9j) ), 0);
   G__memfunc_setup("vavilov_accurate_pdf",2119,G__G__MathMore_99_0_37, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_accurate_pdf) ), 0);
   G__memfunc_setup("vavilov_accurate_cdf",2106,G__G__MathMore_99_0_38, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_accurate_cdf) ), 0);
   G__memfunc_setup("vavilov_accurate_cdf_c",2300,G__G__MathMore_99_0_39, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_accurate_cdf_c) ), 0);
   G__memfunc_setup("vavilov_accurate_quantile",2672,G__G__MathMore_99_0_40, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_accurate_quantile) ), 0);
   G__memfunc_setup("vavilov_accurate_quantile_c",2866,G__G__MathMore_99_0_41, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_accurate_quantile_c) ), 0);
   G__memfunc_setup("vavilov_fast_pdf",1709,G__G__MathMore_99_0_42, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_fast_pdf) ), 0);
   G__memfunc_setup("vavilov_fast_cdf",1696,G__G__MathMore_99_0_43, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_fast_cdf) ), 0);
   G__memfunc_setup("vavilov_fast_cdf_c",1890,G__G__MathMore_99_0_44, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_fast_cdf_c) ), 0);
   G__memfunc_setup("vavilov_fast_quantile",2262,G__G__MathMore_99_0_45, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_fast_quantile) ), 0);
   G__memfunc_setup("vavilov_fast_quantile_c",2456,G__G__MathMore_99_0_46, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::vavilov_fast_quantile_c) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathMore(void) {
   /* ROOT::MathMore */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathMore));
   G__memfunc_setup("chisquared_quantile",2027,G__G__MathMore_100_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::MathMore::chisquared_quantile) ), 0);
   G__memfunc_setup("gamma_quantile",1477,G__G__MathMore_100_0_2, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - alpha "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::MathMore::gamma_quantile) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLPolynomial(void) {
   /* ROOT::Math::Polynomial */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial));
   G__memfunc_setup("Polynomial",1060,G__G__MathMore_113_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 1, 1, 1, 0, "h - - 0 '0' n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Polynomial",1060,G__G__MathMore_113_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Polynomial",1060,G__G__MathMore_113_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Polynomial",1060,G__G__MathMore_113_0_4, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 4, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c d - - 0 - d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Polynomial",1060,G__G__MathMore_113_0_5, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 5, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c d - - 0 - d "
"d - - 0 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindRoots",920,G__G__MathMore_113_0_6, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR), G__defined_typename("vector<std::complex<double> >"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindRealRoots",1308,G__G__MathMore_113_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), G__defined_typename("vector<double>"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNumRoots",1224,G__G__MathMore_113_0_8, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR), G__defined_typename("vector<std::complex<double> >"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Order",508,G__G__MathMore_113_0_9, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), G__defined_typename("ROOT::Math::IGenFunction"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x d - - 1 - f "
"d - - 1 - df", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoParameterDerivative",2151,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 8, 
"d - - 0 - x D - - 10 - p "
"h - - 0 - ipar", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("Polynomial", 1060, G__G__MathMore_113_0_15, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Polynomial' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Polynomial", 1186, G__G__MathMore_113_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_113_0_17, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Polynomial' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR(void) {
   /* ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR));
   G__memfunc_setup("Parameters",1044,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameters",1344,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPar",369,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>", 5430, G__G__MathMore_114_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_114_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLDerivator(void) {
   /* ROOT::Math::Derivator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator));
   G__memfunc_setup("Derivator",944,G__G__MathMore_125_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivator",944,G__G__MathMore_125_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivator",944,G__G__MathMore_125_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator), -1, 0, 2, 5, 1, 0, 
"Y - 'ROOT::Math::Derivator::GSLFuncPointer' 11 - f Y - - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivator",944,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Derivator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Derivator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_125_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_125_0_7, 121, -1, -1, 0, 2, 1, 1, 0, 
"Y - 'ROOT::Math::Derivator::GSLFuncPointer' 11 - f Y - - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_125_0_8, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x d - - 0 '1E-8' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EvalCentral",1105,G__G__MathMore_125_0_9, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x d - - 0 '1E-8' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EvalForward",1117,G__G__MathMore_125_0_10, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x d - - 0 '1E-8' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EvalBackward",1191,G__G__MathMore_125_0_11, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x d - - 0 '1E-8' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_125_0_12, 100, -1, -1, 0, 3, 3, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction&, double, double))(&ROOT::Math::Derivator::Eval) ), 0);
   G__memfunc_setup("EvalCentral",1105,G__G__MathMore_125_0_13, 100, -1, -1, 0, 3, 3, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction&, double, double))(&ROOT::Math::Derivator::EvalCentral) ), 0);
   G__memfunc_setup("EvalForward",1117,G__G__MathMore_125_0_14, 100, -1, -1, 0, 3, 3, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction&, double, double))(&ROOT::Math::Derivator::EvalForward) ), 0);
   G__memfunc_setup("EvalBackward",1191,G__G__MathMore_125_0_15, 100, -1, -1, 0, 3, 3, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction&, double, double))(&ROOT::Math::Derivator::EvalBackward) ), 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_125_0_16, 100, -1, -1, 0, 4, 3, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f D - - 10 - x "
"h - - 0 '0' icoord d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IMultiGenFunction&, const double*, unsigned int, double))(&ROOT::Math::Derivator::Eval) ), 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_125_0_17, 100, -1, -1, 0, 5, 3, 1, 0, 
"u 'ROOT::Math::IParametricFunctionOneDim' 'ROOT::Math::IParamFunction' 1 - f d - - 0 - x "
"D - - 10 - p h - - 0 '0' ipar "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(ROOT::Math::IParamFunction&, double, const double*, unsigned int, double))(&ROOT::Math::Derivator::Eval) ), 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_125_0_18, 100, -1, -1, 0, 5, 3, 1, 0, 
"u 'ROOT::Math::IParametricFunctionMultiDim' 'ROOT::Math::IParamMultiFunction' 1 - f D - - 10 - x "
"D - - 10 - p h - - 0 '0' ipar "
"d - - 0 '1E-8' h", (char*)NULL, (void*) G__func2void( (double (*)(ROOT::Math::IParamMultiFunction&, const double*, const double*, unsigned int, double))(&ROOT::Math::Derivator::Eval) ), 0);
   G__memfunc_setup("Status",644,G__G__MathMore_125_0_19, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,G__G__MathMore_125_0_20, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathMore_125_0_21, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Derivator", 1070, G__G__MathMore_125_0_22, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLInterpolator(void) {
   /* ROOT::Math::Interpolator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator));
   G__memfunc_setup("Interpolator",1283,G__G__MathMore_129_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator), -1, 0, 2, 1, 1, 0, 
"h - - 0 '0' ndata i 'ROOT::Math::Interpolation::Type' - 0 'Interpolation::kCSPLINE' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolator",1283,G__G__MathMore_129_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator), -1, 0, 3, 1, 1, 0, 
"u 'vector<double,allocator<double> >' 'vector<double>' 11 - x u 'vector<double,allocator<double> >' 'vector<double>' 11 - y "
"i 'ROOT::Math::Interpolation::Type' - 0 'Interpolation::kCSPLINE' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Interpolator",1283,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Interpolator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Interpolator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathMore_129_0_5, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' 'vector<double>' 11 - x u 'vector<double,allocator<double> >' 'vector<double>' 11 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathMore_129_0_6, 103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - ndata D - - 10 - x "
"D - - 10 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eval",392,G__G__MathMore_129_0_7, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Deriv",506,G__G__MathMore_129_0_8, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Deriv2",556,G__G__MathMore_129_0_9, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integ",503,G__G__MathMore_129_0_10, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_129_0_11, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeGet",706,G__G__MathMore_129_0_12, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Interpolator", 1409, G__G__MathMore_129_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRootFinder(void) {
   /* ROOT::Math::GSLRootFinder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder));
   G__memfunc_setup("GSLRootFinder",1250,G__G__MathMore_133_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLRootFinder",1250,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLRootFinder' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLRootFinder' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_133_0_6, 103, -1, -1, 0, 4, 1, 1, 0, 
"Y - 'ROOT::Math::GSLRootFinder::GSLFuncPointer' 0 - f Y - - 0 - params "
"d - - 0 - xlow d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterate",718,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Root",420,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Solve",521,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-8' absTol "
"d - - 0 '1E-10' relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSolver",935,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "U 'ROOT::Math::GSLRootFSolver' - 0 - s", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FreeSolver",1021,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRootFinder", 1376, G__G__MathMore_133_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRootFinderDeriv(void) {
   /* ROOT::Math::GSLRootFinderDeriv */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv));
   G__memfunc_setup("GSLRootFinderDeriv",1756,G__G__MathMore_136_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLRootFinderDeriv",1756,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLRootFinderDeriv' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLRootFinderDeriv' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - d - - 0 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - f d - - 0 - xstart", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_136_0_6, 103, -1, -1, 0, 5, 1, 1, 0, 
"Y - 'ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer' 0 - f Y - 'ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer' 0 - df "
"Y - 'ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer' 0 - fdf Y - - 0 - p "
"d - - 0 - Root", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterate",718,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Root",420,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Solve",521,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-8' absTol "
"d - - 0 '1E-10' relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSolver",935,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "U 'ROOT::Math::GSLRootFdFSolver' - 0 - s", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FreeSolver",1021,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRootFinderDeriv", 1882, G__G__MathMore_136_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRoots(void) {
   /* ROOT::Math::Roots */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRoots));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLBisection(void) {
   /* ROOT::Math::Roots::Bisection */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection));
   G__memfunc_setup("Bisection",928,G__G__MathMore_138_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Bisection",928,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Bisection' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Bisection' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Bisection", 1054, G__G__MathMore_138_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLFalsePos(void) {
   /* ROOT::Math::Roots::FalsePos */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos));
   G__memfunc_setup("FalsePos",797,G__G__MathMore_139_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FalsePos",797,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::FalsePos' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::FalsePos' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FalsePos", 923, G__G__MathMore_139_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLBrent(void) {
   /* ROOT::Math::Roots::Brent */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent));
   G__memfunc_setup("Brent",507,G__G__MathMore_140_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Brent",507,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Brent' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Brent' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Brent", 633, G__G__MathMore_140_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLNewton(void) {
   /* ROOT::Math::Roots::Newton */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton));
   G__memfunc_setup("Newton",635,G__G__MathMore_141_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Newton",635,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Newton' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Newton' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Newton", 761, G__G__MathMore_141_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLSecant(void) {
   /* ROOT::Math::Roots::Secant */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant));
   G__memfunc_setup("Secant",606,G__G__MathMore_142_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Secant",606,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Secant' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Secant' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Secant", 732, G__G__MathMore_142_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootscLcLSteffenson(void) {
   /* ROOT::Math::Roots::Steffenson */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson));
   G__memfunc_setup("Steffenson",1051,G__G__MathMore_143_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Steffenson",1051,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Steffenson' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Roots::Steffenson' - 11 - -", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Steffenson", 1177, G__G__MathMore_143_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegration(void) {
   /* ROOT::Math::Integration */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegration));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLIntegrator(void) {
   /* ROOT::Math::GSLIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator));
   G__memfunc_setup("GSLIntegrator",1285,G__G__MathMore_158_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 0, 3, 1, 1, 0, 
"d - - 0 '1.E-9' absTol d - - 0 '1E-6' relTol "
"k - 'size_t' 0 '1000' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLIntegrator",1285,G__G__MathMore_158_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 0, 4, 1, 1, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 10 - type d - - 0 '1.E-9' absTol "
"d - - 0 '1E-6' relTol k - 'size_t' 0 '1000' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLIntegrator",1285,G__G__MathMore_158_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 0, 5, 1, 1, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 10 - type i 'ROOT::Math::Integration::GKRule' - 10 - rule "
"d - - 0 '1.E-9' absTol d - - 0 '1E-6' relTol "
"k - 'size_t' 0 '1000' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLIntegrator",1285,G__G__MathMore_158_0_4, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 0, 5, 1, 1, 0, 
"C - - 10 - type i - - 0 - rule "
"d - - 0 - absTol d - - 0 - relTol "
"k - 'size_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLIntegrator",1285,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLIntegrator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLIntegrator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_158_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_9, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_10, 100, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralCauchy",1427,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathMore_158_0_12, 100, -1, -1, 0, 4, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathMore_158_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathMore_158_0_14, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_15, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralUp",1019,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralLow",1128,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_21, 100, -1, -1, 0, 4, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p "
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_22, 100, -1, -1, 0, 2, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathMore_158_0_23, 100, -1, -1, 0, 3, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p "
"d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathMore_158_0_24, 100, -1, -1, 0, 3, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p "
"d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_158_0_25, 100, -1, -1, 0, 3, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p "
"u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NEval",470,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTolerance", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTolerance", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetIntegrationRule",1864,G__G__MathMore_158_0_32, 121, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::Integration::GKRule' - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorOneDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetType",706,G__G__MathMore_158_0_35, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTypeName",1091,G__G__MathMore_158_0_36, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CheckFunction",1316,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLIntegrator", 1411, G__G__MathMore_158_0_38, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVegasParameters(void) {
   /* ROOT::Math::VegasParameters */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters));
   G__memfunc_setup("VegasParameters",1546,G__G__MathMore_161_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VegasParameters",1546,G__G__MathMore_161_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultValues",1633,G__G__MathMore_161_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathMore_161_0_4, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathMore_161_0_5, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VegasParameters", 1546, G__G__MathMore_161_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VegasParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VegasParameters", 1672, G__G__MathMore_161_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_161_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VegasParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMiserParameters(void) {
   /* ROOT::Math::MiserParameters */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters));
   G__memfunc_setup("MiserParameters",1556,G__G__MathMore_162_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters), -1, 0, 1, 1, 1, 0, "k - 'size_t' 0 '10' dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultValues",1633,G__G__MathMore_162_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'size_t' 0 '10' dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MiserParameters",1556,G__G__MathMore_162_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters), -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IOptions' - 11 - opt k - 'size_t' 0 '10' dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathMore_162_0_4, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IOptions' - 11 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathMore_162_0_5, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MiserParameters", 1556, G__G__MathMore_162_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MiserParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MiserParameters", 1682, G__G__MathMore_162_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_162_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::MiserParameters' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLMCIntegrator(void) {
   /* ROOT::Math::GSLMCIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator));
   G__memfunc_setup("GSLMCIntegrator",1429,G__G__MathMore_167_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator), -1, 0, 4, 5, 1, 0, 
"i 'ROOT::Math::IntegrationMultiDim::Type' - 0 'MCIntegration::kVEGAS' type d - - 0 '0' absTol "
"d - - 0 '0' relTol h - - 0 '0' calls", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLMCIntegrator",1429,G__G__MathMore_167_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator), -1, 0, 4, 1, 1, 0, 
"C - - 10 - type d - - 0 - absTol "
"d - - 0 - relTol h - - 0 - calls", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLMCIntegrator",1429,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLMCIntegrator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLMCIntegrator' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_167_0_6, 121, -1, -1, 0, 3, 1, 1, 0, 
"Y - 'ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer' 0 - f h - - 0 - dim "
"Y - - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_167_0_7, 100, -1, -1, 0, 5, 1, 1, 0, 
"Y - 'ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer' 11 - f h - - 0 - dim "
"D - - 0 - a D - - 0 - b "
"Y - - 0 '0' p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - a D - - 10 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NEval",470,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTolerance", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTolerance", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetOptions",1048,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IntegratorMultiDimOptions' - 11 - opt", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetGenerator",1235,G__G__MathMore_167_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::GSLRngWrapper' - 0 - r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetType",718,G__G__MathMore_167_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::IntegrationMultiDim::Type' - 0 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTypeName",1103,G__G__MathMore_167_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - typeName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMode",689,G__G__MathMore_167_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::MCIntegration::Mode' - 0 - mode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetParameters",1344,G__G__MathMore_167_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VegasParameters' - 11 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetParameters",1344,G__G__MathMore_167_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MiserParameters' - 11 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sigma",497,G__G__MathMore_167_0_22, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSqr",586,G__G__MathMore_167_0_23, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetType",706,G__G__MathMore_167_0_24, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTypeName",1091,G__G__MathMore_167_0_25, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Options",748,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ExtraOptions",1264,G__G__MathMore_167_0_27, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CheckFunction",1316,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoInitialize",1221,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLMCIntegrator", 1555, G__G__MathMore_167_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMinim1D(void) {
   /* ROOT::Math::Minim1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1D));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLMinimizer1D(void) {
   /* ROOT::Math::GSLMinimizer1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D));
   G__memfunc_setup("GSLMinimizer1D",1295,G__G__MathMore_172_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D), -1, 0, 1, 5, 1, 0, "i 'ROOT::Math::Minim1D::Type' - 0 'Minim1D::kBRENT' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLMinimizer1D",1295,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLMinimizer1D' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLMinimizer1D' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathMore_172_0_4, 121, -1, -1, 0, 5, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - params "
"d - - 0 - xmin d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterate",718,G__G__MathMore_172_0_5, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("XMinimum",820,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XLower",609,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XUpper",612,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValMinimum",1093,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValLower",882,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValUpper",885,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 - maxIter d - - 0 - absTol "
"d - - 0 - relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("TestInterval",1253,G__G__MathMore_172_0_16, 105, -1, -1, 0, 4, 3, 1, 0, 
"d - - 0 - xlow d - - 0 - xup "
"d - - 0 - epsAbs d - - 0 - epsRel", (char*)NULL, (void*) G__func2void( (int (*)(double, double, double, double))(&ROOT::Math::GSLMinimizer1D::TestInterval) ), 0);
   // automatic destructor
   G__memfunc_setup("~GSLMinimizer1D", 1421, G__G__MathMore_172_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLChebyshev(void) {
   /* ROOT::Math::Chebyshev */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev));
   G__memfunc_setup("Chebyshev",929,G__G__MathMore_174_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 4, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Chebyshev",929,G__G__MathMore_174_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 5, 1, 1, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - p "
"d - - 0 - a d - - 0 - b "
"k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Chebyshev",929,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 1, 1, 4, 0, "k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Chebyshev",929,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::Chebyshev' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Chebyshev' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathMore_174_0_6, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EvalErr",689,G__G__MathMore_174_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_pairlEdoublecOdoublegR), -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathMore_174_0_8, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EvalErr",689,G__G__MathMore_174_0_9, 117, G__get_linked_tagnum(&G__G__MathMoreLN_pairlEdoublecOdoublegR), -1, 0, 2, 1, 1, 8, 
"d - - 0 - x k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Deriv",506,G__G__MathMore_174_0_10, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathMore_174_0_11, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Initialize",1042,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 2, 0, 
"Y - 'ROOT::Math::GSLFuncPointer' 0 - f Y - - 0 - params "
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Chebyshev", 1055, G__G__MathMore_174_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRandomEngine(void) {
   /* ROOT::Math::GSLRandomEngine */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine));
   G__memfunc_setup("GSLRandomEngine",1437,G__G__MathMore_176_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLRandomEngine",1437,G__G__MathMore_176_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine), -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::GSLRngWrapper' - 0 - rng", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Initialize",1042,G__G__MathMore_176_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Terminate",937,G__G__MathMore_176_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathMore_176_0_5, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmInt",700,G__G__MathMore_176_0_6, 104, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RandomArray",1120,G__G__MathMore_176_0_7, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 0 - begin D - - 0 - end", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__MathMore_176_0_8, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Size",411,G__G__MathMore_176_0_9, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_176_0_10, 121, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian",827,G__G__MathMore_176_0_11, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianZig",1125,G__G__MathMore_176_0_12, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianRatio",1338,G__G__MathMore_176_0_13, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_176_0_14, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - a d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_176_0_15, 121, -1, -1, 0, 5, 1, 1, 8, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exponential",1159,G__G__MathMore_176_0_16, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Cauchy",605,G__G__MathMore_176_0_17, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_176_0_18, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_176_0_19, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_176_0_20, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_176_0_21, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_176_0_22, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_176_0_23, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dir2D",405,G__G__MathMore_176_0_24, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - - 1 - x d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Dir3D",406,G__G__MathMore_176_0_25, 121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_176_0_26, 104, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_176_0_27, 104, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - p h - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_176_0_28, 104, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - p d - - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_176_0_29, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 8, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetType",718,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "U 'ROOT::Math::GSLRngWrapper' - 0 - r", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRandomEngine", 1437, G__G__MathMore_176_0_31, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRandomEngine' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRandomEngine", 1563, G__G__MathMore_176_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_176_0_33, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRandomEngine' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngMT(void) {
   /* ROOT::Math::GSLRngMT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT));
   G__memfunc_setup("GSLRngMT",686,G__G__MathMore_181_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngMT", 686, G__G__MathMore_181_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngMT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngMT", 812, G__G__MathMore_181_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_181_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngMT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLux(void) {
   /* ROOT::Math::GSLRngRanLux */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux));
   G__memfunc_setup("GSLRngRanLux",1127,G__G__MathMore_182_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngRanLux", 1127, G__G__MathMore_182_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLux' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngRanLux", 1253, G__G__MathMore_182_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_182_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLux' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxS1(void) {
   /* ROOT::Math::GSLRngRanLuxS1 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1));
   G__memfunc_setup("GSLRngRanLuxS1",1259,G__G__MathMore_183_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngRanLuxS1", 1259, G__G__MathMore_183_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngRanLuxS1", 1385, G__G__MathMore_183_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_183_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxS2(void) {
   /* ROOT::Math::GSLRngRanLuxS2 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2));
   G__memfunc_setup("GSLRngRanLuxS2",1260,G__G__MathMore_184_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngRanLuxS2", 1260, G__G__MathMore_184_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngRanLuxS2", 1386, G__G__MathMore_184_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_184_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxD1(void) {
   /* ROOT::Math::GSLRngRanLuxD1 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1));
   G__memfunc_setup("GSLRngRanLuxD1",1244,G__G__MathMore_185_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngRanLuxD1", 1244, G__G__MathMore_185_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngRanLuxD1", 1370, G__G__MathMore_185_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_185_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxD2(void) {
   /* ROOT::Math::GSLRngRanLuxD2 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2));
   G__memfunc_setup("GSLRngRanLuxD2",1245,G__G__MathMore_186_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngRanLuxD2", 1245, G__G__MathMore_186_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngRanLuxD2", 1371, G__G__MathMore_186_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_186_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngTaus(void) {
   /* ROOT::Math::GSLRngTaus */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus));
   G__memfunc_setup("GSLRngTaus",938,G__G__MathMore_187_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngTaus", 938, G__G__MathMore_187_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngTaus' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngTaus", 1064, G__G__MathMore_187_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_187_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngTaus' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLRngGFSR4(void) {
   /* ROOT::Math::GSLRngGFSR4 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4));
   G__memfunc_setup("GSLRngGFSR4",883,G__G__MathMore_188_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLRngGFSR4", 883, G__G__MathMore_188_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngGFSR4' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLRngGFSR4", 1009, G__G__MathMore_188_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_188_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLRngGFSR4' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLKelvinFunctions(void) {
   /* ROOT::Math::KelvinFunctions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions));
   G__memfunc_setup("Ber",281,G__G__MathMore_194_0_1, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Ber) ), 0);
   G__memfunc_setup("Bei",272,G__G__MathMore_194_0_2, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Bei) ), 0);
   G__memfunc_setup("Ker",290,G__G__MathMore_194_0_3, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Ker) ), 0);
   G__memfunc_setup("Kei",281,G__G__MathMore_194_0_4, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Kei) ), 0);
   G__memfunc_setup("DBer",349,G__G__MathMore_194_0_5, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::DBer) ), 0);
   G__memfunc_setup("DBei",340,G__G__MathMore_194_0_6, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::DBei) ), 0);
   G__memfunc_setup("DKer",358,G__G__MathMore_194_0_7, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::DKer) ), 0);
   G__memfunc_setup("DKei",349,G__G__MathMore_194_0_8, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::DKei) ), 0);
   G__memfunc_setup("F1",119,G__G__MathMore_194_0_9, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::F1) ), 0);
   G__memfunc_setup("F2",120,G__G__MathMore_194_0_10, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::F2) ), 0);
   G__memfunc_setup("G1",120,G__G__MathMore_194_0_11, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::G1) ), 0);
   G__memfunc_setup("G2",121,G__G__MathMore_194_0_12, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::G2) ), 0);
   G__memfunc_setup("M",77,G__G__MathMore_194_0_13, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::M) ), 0);
   G__memfunc_setup("Theta",502,G__G__MathMore_194_0_14, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Theta) ), 0);
   G__memfunc_setup("N",78,G__G__MathMore_194_0_15, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::N) ), 0);
   G__memfunc_setup("Phi",289,G__G__MathMore_194_0_16, 100, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::KelvinFunctions::Phi) ), 0);
   // automatic default constructor
   G__memfunc_setup("KelvinFunctions", 1570, G__G__MathMore_194_0_17, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("KelvinFunctions", 1570, G__G__MathMore_194_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::KelvinFunctions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~KelvinFunctions", 1696, G__G__MathMore_194_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_194_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::KelvinFunctions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLMinimizer(void) {
   /* ROOT::Math::GSLMinimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer));
   G__memfunc_setup("GSLMinimizer",1178,G__G__MathMore_207_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer), -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::EGSLMinimizerType' - 0 'ROOT::Math::kConjugateFR' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLMinimizer",1178,G__G__MathMore_207_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer), -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLMinimizer",1178,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLMinimizer' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLMinimizer' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' 'ROOT::Math::IMultiGradFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,(G__InterfaceMethod) NULL,103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLowerLimitedVariable",2339,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetUpperLimitedVariable",2342,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,(G__InterfaceMethod) NULL,103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFixedVariable",1602,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValue",1615,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ivar d - - 0 - val", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValues",1730,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinValue",801,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Edm",278,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", "not impl. }", (void*) NULL, 1);
   G__memfunc_setup("X",88,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinGradient",1106,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NFree",464,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ProvidesError",1366,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Errors",637,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CovMatrix",925,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - - h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ObjFunction",1121,G__G__MathMore_207_0_25, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim), G__defined_typename("ROOT::Math::IMultiGradFunction"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TransformFunction",1794,G__G__MathMore_207_0_26, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimTransformFunction), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLMinimizer", 1304, G__G__MathMore_207_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLLSResidualFunc(void) {
   /* ROOT::Math::LSResidualFunc */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc));
   G__memfunc_setup("LSResidualFunc",1380,G__G__MathMore_230_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LSResidualFunc",1380,G__G__MathMore_230_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc), -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>' 'ROOT::Math::FitMethodFunction' 11 - func h - - 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LSResidualFunc",1380,G__G__MathMore_230_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::LSResidualFunc' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathMore_230_0_4, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::LSResidualFunc' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::IMultiGenFunction"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Gradient",814,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - g", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - g", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x h - - 0 - icoord", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~LSResidualFunc", 1506, G__G__MathMore_230_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLNLSMinimizer(void) {
   /* ROOT::Math::GSLNLSMinimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer));
   G__memfunc_setup("GSLNLSMinimizer",1415,G__G__MathMore_231_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer), -1, 0, 1, 1, 1, 0, "i - - 0 '0' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLNLSMinimizer",1415,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLNLSMinimizer' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLNLSMinimizer' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' 'ROOT::Math::IMultiGradFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,(G__InterfaceMethod) NULL,103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLowerLimitedVariable",2339,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetUpperLimitedVariable",2342,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,(G__InterfaceMethod) NULL,103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFixedVariable",1602,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValue",1615,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ivar d - - 0 - val", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValues",1730,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinValue",801,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Edm",278,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", "not impl. }", (void*) NULL, 1);
   G__memfunc_setup("X",88,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinGradient",1106,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NFree",464,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ProvidesError",1366,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Errors",637,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CovMatrix",925,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - - h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CovMatrixStatus",1569,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~GSLNLSMinimizer", 1541, G__G__MathMore_231_0_25, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLSimAnFunc(void) {
   /* ROOT::Math::GSLSimAnFunc */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc));
   G__memfunc_setup("GSLSimAnFunc",1098,G__G__MathMore_236_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLSimAnFunc",1098,G__G__MathMore_236_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func D - - 10 - x "
"D - - 10 - scale", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLSimAnFunc",1098,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 0, 0, 1, 2, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FastCopy",809,G__G__MathMore_236_0_4, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLSimAnFunc' - 11 - f", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Clone",497,G__G__MathMore_236_0_5, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Energy",618,G__G__MathMore_236_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Step",412,G__G__MathMore_236_0_7, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::GSLRandomEngine' - 11 - r d - - 0 - maxstep", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Distance",811,G__G__MathMore_236_0_8, 100, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::GSLSimAnFunc' - 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G__MathMore_236_0_9, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetX",388,G__G__MathMore_236_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NDim",360,G__G__MathMore_236_0_11, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__G__MathMore_236_0_12, 100, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__G__MathMore_236_0_13, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), G__defined_typename("vector<double>"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Scale",488,G__G__MathMore_236_0_14, 100, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetX",388,G__G__MathMore_236_0_15, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - i d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLSimAnFunc", 1098, G__G__MathMore_236_0_16, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLSimAnFunc' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLSimAnFunc", 1224, G__G__MathMore_236_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLSimAnParams(void) {
   /* ROOT::Math::GSLSimAnParams */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams));
   G__memfunc_setup("GSLSimAnParams",1314,G__G__MathMore_237_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GSLSimAnParams", 1314, G__G__MathMore_237_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GSLSimAnParams' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLSimAnParams", 1440, G__G__MathMore_237_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_237_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GSLSimAnParams' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLSimAnnealing(void) {
   /* ROOT::Math::GSLSimAnnealing */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing));
   G__memfunc_setup("GSLSimAnnealing",1436,G__G__MathMore_238_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLSimAnnealing",1436,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLSimAnnealing' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLSimAnnealing' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Solve",521,G__G__MathMore_238_0_4, 105, -1, -1, 0, 5, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func D - - 10 - x0 "
"D - - 10 - scale D - - 0 - xmin "
"g - - 0 'false' debug", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Solve",521,G__G__MathMore_238_0_5, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::GSLSimAnFunc' - 1 - func g - - 0 'false' debug", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Params",612,G__G__MathMore_238_0_6, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Params",612,G__G__MathMore_238_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GSLSimAnnealing", 1562, G__G__MathMore_238_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGSLSimAnMinimizer(void) {
   /* ROOT::Math::GSLSimAnMinimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer));
   G__memfunc_setup("GSLSimAnMinimizer",1650,G__G__MathMore_239_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer), -1, 0, 1, 1, 1, 0, "i - - 0 '0' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GSLSimAnMinimizer",1650,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::GSLSimAnMinimizer' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::GSLSimAnMinimizer' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' 'ROOT::Math::IMultiGradFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,(G__InterfaceMethod) NULL,103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFixedVariable",1602,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLowerLimitedVariable",2339,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetUpperLimitedVariable",2342,(G__InterfaceMethod) NULL,103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,(G__InterfaceMethod) NULL,103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValue",1615,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ivar d - - 0 - val", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValues",1730,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinValue",801,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Edm",278,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", "not impl. }", (void*) NULL, 1);
   G__memfunc_setup("X",88,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("MinGradient",1106,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", "not impl.  ", (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", "not yet ipl.  ", (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NFree",464,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ProvidesError",1366,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Errors",637,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CovMatrix",925,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - - h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~GSLSimAnMinimizer", 1776, G__G__MathMore_239_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilov(void) {
   /* ROOT::Math::Vavilov */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov));
   G__memfunc_setup("Pdf",282,G__G__MathMore_240_0_2, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Pdf",282,G__G__MathMore_240_0_3, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Cdf",269,G__G__MathMore_240_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Cdf",269,G__G__MathMore_240_0_5, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Cdf_c",463,G__G__MathMore_240_0_6, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Cdf_c",463,G__G__MathMore_240_0_7, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Quantile",835,G__G__MathMore_240_0_8, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Quantile",835,G__G__MathMore_240_0_9, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Quantile_c",1029,G__G__MathMore_240_0_10, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Quantile_c",1029,G__G__MathMore_240_0_11, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetKappaBeta2",1223,G__G__MathMore_240_0_12, 121, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetLambdaMin",1157,G__G__MathMore_240_0_13, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetLambdaMax",1159,G__G__MathMore_240_0_14, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetKappa",781,G__G__MathMore_240_0_15, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetBeta2",718,G__G__MathMore_240_0_16, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Mode",389,G__G__MathMore_240_0_17, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Mode",389,G__G__MathMore_240_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Mean",385,G__G__MathMore_240_0_19, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Variance",809,G__G__MathMore_240_0_20, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Skewness",851,G__G__MathMore_240_0_21, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Kurtosis",868,G__G__MathMore_240_0_22, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Mean",385,G__G__MathMore_240_0_23, 100, -1, -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::Vavilov::Mean) ), 0);
   G__memfunc_setup("Variance",809,G__G__MathMore_240_0_24, 100, -1, -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::Vavilov::Variance) ), 0);
   G__memfunc_setup("Skewness",851,G__G__MathMore_240_0_25, 100, -1, -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::Vavilov::Skewness) ), 0);
   G__memfunc_setup("Kurtosis",868,G__G__MathMore_240_0_26, 100, -1, -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::Vavilov::Kurtosis) ), 0);
   // automatic destructor
   G__memfunc_setup("~Vavilov", 869, G__G__MathMore_240_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_240_0_28, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Vavilov' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilovAccurate(void) {
   /* ROOT::Math::VavilovAccurate */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate));
   G__memfunc_setup("VavilovAccurate",1551,G__G__MathMore_241_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate), -1, 0, 4, 1, 1, 0, 
"d - - 0 '1' kappa d - - 0 '1' beta2 "
"d - - 0 '5E-4' epsilonPM d - - 0 '1E-5' epsilon", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pdf",282,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Pdf",282,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf",269,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf",269,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf_c",463,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf_c",463,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile",835,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile",835,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile_c",1029,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile_c",1029,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetKappaBeta2",1223,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Set",300,G__G__MathMore_241_0_13, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2 "
"d - - 0 '5E-4' epsilonPM d - - 0 '1E-5' epsilon", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLambdaMin",1157,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetLambdaMax",1159,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetKappa",781,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBeta2",718,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Mode",389,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Mode",389,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetEpsilonPM",1175,G__G__MathMore_241_0_20, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetEpsilon",1018,G__G__MathMore_241_0_21, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNTerms",889,G__G__MathMore_241_0_22, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetInstance",1109,G__G__MathMore_241_0_23, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (ROOT::Math::VavilovAccurate* (*)())(&ROOT::Math::VavilovAccurate::GetInstance) ), 0);
   G__memfunc_setup("GetInstance",1109,G__G__MathMore_241_0_24, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate), -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (ROOT::Math::VavilovAccurate* (*)(double, double))(&ROOT::Math::VavilovAccurate::GetInstance) ), 0);
   G__memfunc_setup("InitQuantile",1239,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("G116f1",374,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("G116f2",375,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rzero",530,(G__InterfaceMethod) NULL, 105, -1, -1, 0, 6, 1, 4, 8, 
"d - - 0 - a d - - 0 - b "
"d - - 1 - x0 d - - 0 - eps "
"i - - 0 - mxf 1 - 'double (*)(double)const' 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("E1plLog",628,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 3, 4, 0, "d - - 0 - x", "Calculates log(|x|)+E_1(x)", (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VavilovAccurate", 1551, G__G__MathMore_241_0_30, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurate' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VavilovAccurate", 1677, G__G__MathMore_241_0_31, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_241_0_32, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurate' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilovAccuratePdf(void) {
   /* ROOT::Math::VavilovAccuratePdf */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf));
   G__memfunc_setup("VavilovAccuratePdf",1833,G__G__MathMore_243_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VavilovAccuratePdf",1833,G__G__MathMore_243_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf), -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Parameters",1044,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameters",1344,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPar",369,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterName",1314,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("VavilovAccuratePdf", 1833, G__G__MathMore_243_0_10, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccuratePdf' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VavilovAccuratePdf", 1959, G__G__MathMore_243_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_243_0_12, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccuratePdf' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilovAccurateCdf(void) {
   /* ROOT::Math::VavilovAccurateCdf */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf));
   G__memfunc_setup("VavilovAccurateCdf",1820,G__G__MathMore_244_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VavilovAccurateCdf",1820,G__G__MathMore_244_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf), -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Parameters",1044,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameters",1344,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPar",369,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterName",1314,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("VavilovAccurateCdf", 1820, G__G__MathMore_244_0_10, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurateCdf' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VavilovAccurateCdf", 1946, G__G__MathMore_244_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_244_0_12, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurateCdf' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilovAccurateQuantile(void) {
   /* ROOT::Math::VavilovAccurateQuantile */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile));
   G__memfunc_setup("VavilovAccurateQuantile",2386,G__G__MathMore_245_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VavilovAccurateQuantile",2386,G__G__MathMore_245_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile), -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Parameters",1044,(G__InterfaceMethod) NULL,68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameters",1344,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NPar",369,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterName",1314,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("VavilovAccurateQuantile", 2386, G__G__MathMore_245_0_10, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurateQuantile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VavilovAccurateQuantile", 2512, G__G__MathMore_245_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_245_0_12, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VavilovAccurateQuantile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVavilovFast(void) {
   /* ROOT::Math::VavilovFast */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast));
   G__memfunc_setup("VavilovFast",1141,G__G__MathMore_246_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast), -1, 0, 2, 1, 1, 0, 
"d - - 0 '1' kappa d - - 0 '1' beta2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pdf",282,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Pdf",282,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf",269,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf",269,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf_c",463,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Cdf_c",463,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile",835,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile",835,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile_c",1029,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - z", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Quantile_c",1029,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - kappa "
"d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetKappaBeta2",1223,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetLambdaMin",1157,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetLambdaMax",1159,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetKappa",781,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetBeta2",718,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetInstance",1109,G__G__MathMore_246_0_17, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (ROOT::Math::VavilovFast* (*)())(&ROOT::Math::VavilovFast::GetInstance) ), 0);
   G__memfunc_setup("GetInstance",1109,G__G__MathMore_246_0_18, 85, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast), -1, 0, 2, 3, 1, 0, 
"d - - 0 - kappa d - - 0 - beta2", (char*)NULL, (void*) G__func2void( (ROOT::Math::VavilovFast* (*)(double, double))(&ROOT::Math::VavilovFast::GetInstance) ), 0);
   // automatic copy constructor
   G__memfunc_setup("VavilovFast", 1141, G__G__MathMore_246_0_19, (int) ('i'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::VavilovFast' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VavilovFast", 1267, G__G__MathMore_246_0_20, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_246_0_21, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VavilovFast' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngMT> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngMT>",2367,G__G__MathMore_247_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngMT>",2367,G__G__MathMore_247_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngMT>",2367,G__G__MathMore_247_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngMT' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_247_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_247_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_247_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_247_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_247_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_247_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_247_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_247_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_247_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_247_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_247_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_247_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_247_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_247_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_247_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_247_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_247_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_247_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_247_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_247_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_247_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_247_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_247_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_247_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_247_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngMT>", 2367, G__G__MathMore_247_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngMT>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngMT>", 2493, G__G__MathMore_247_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_247_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngMT>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngTaus> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngTaus>",2619,G__G__MathMore_248_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngTaus>",2619,G__G__MathMore_248_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngTaus>",2619,G__G__MathMore_248_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngTaus' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_248_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_248_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_248_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_248_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_248_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_248_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_248_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_248_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_248_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_248_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_248_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_248_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_248_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_248_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_248_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_248_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_248_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_248_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_248_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_248_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_248_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_248_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_248_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_248_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_248_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngTaus>", 2619, G__G__MathMore_248_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngTaus>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngTaus>", 2745, G__G__MathMore_248_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_248_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngTaus>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLux> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLux>",2808,G__G__MathMore_249_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLux>",2808,G__G__MathMore_249_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLux>",2808,G__G__MathMore_249_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngRanLux' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_249_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_249_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_249_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_249_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_249_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_249_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_249_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_249_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_249_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_249_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_249_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_249_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_249_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_249_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_249_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_249_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_249_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_249_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_249_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_249_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_249_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_249_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_249_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_249_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_249_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLux>", 2808, G__G__MathMore_249_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLux>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngRanLux>", 2934, G__G__MathMore_249_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_249_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLux>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS1>",2940,G__G__MathMore_250_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS1>",2940,G__G__MathMore_250_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS1>",2940,G__G__MathMore_250_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS1' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_250_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_250_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_250_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_250_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_250_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_250_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_250_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_250_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_250_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_250_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_250_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_250_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_250_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_250_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_250_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_250_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_250_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_250_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_250_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_250_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_250_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_250_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_250_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_250_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_250_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS1>", 2940, G__G__MathMore_250_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngRanLuxS1>", 3066, G__G__MathMore_250_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_250_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS2>",2941,G__G__MathMore_251_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS2>",2941,G__G__MathMore_251_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS2>",2941,G__G__MathMore_251_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngRanLuxS2' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_251_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_251_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_251_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_251_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_251_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_251_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_251_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_251_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_251_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_251_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_251_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_251_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_251_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_251_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_251_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_251_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_251_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_251_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_251_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_251_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_251_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_251_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_251_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_251_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_251_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxS2>", 2941, G__G__MathMore_251_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngRanLuxS2>", 3067, G__G__MathMore_251_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_251_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD1>",2925,G__G__MathMore_252_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD1>",2925,G__G__MathMore_252_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD1>",2925,G__G__MathMore_252_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD1' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_252_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_252_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_252_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_252_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_252_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_252_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_252_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_252_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_252_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_252_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_252_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_252_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_252_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_252_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_252_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_252_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_252_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_252_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_252_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_252_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_252_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_252_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_252_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_252_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_252_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD1>", 2925, G__G__MathMore_252_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngRanLuxD1>", 3051, G__G__MathMore_252_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_252_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD2>",2926,G__G__MathMore_253_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD2>",2926,G__G__MathMore_253_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD2>",2926,G__G__MathMore_253_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngRanLuxD2' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_253_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_253_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_253_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_253_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_253_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_253_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_253_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_253_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_253_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_253_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_253_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_253_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_253_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_253_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_253_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_253_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_253_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_253_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_253_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_253_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_253_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_253_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_253_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_253_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_253_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngRanLuxD2>", 2926, G__G__MathMore_253_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngRanLuxD2>", 3052, G__G__MathMore_253_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_253_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR(void) {
   /* ROOT::Math::Random<ROOT::Math::GSLRngGFSR4> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR));
   G__memfunc_setup("Random<ROOT::Math::GSLRngGFSR4>",2564,G__G__MathMore_254_0_1, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngGFSR4>",2564,G__G__MathMore_254_0_2, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR), -1, 0, 1, 5, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Random<ROOT::Math::GSLRngGFSR4>",2564,G__G__MathMore_254_0_3, 105, G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR), -1, 0, 1, 5, 1, 0, "u 'ROOT::Math::GSLRngGFSR4' - 11 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Uniform",736,G__G__MathMore_254_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 '1.0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,G__G__MathMore_254_0_5, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RndmArray",912,G__G__MathMore_254_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - - 0 - n D - - 0 - array", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__MathMore_254_0_7, 117, G__get_linked_tagnum(&G__G__MathMoreLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EngineSize",1009,G__G__MathMore_254_0_8, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSeed",685,G__G__MathMore_254_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaus",400,G__G__MathMore_254_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausBM",543,G__G__MathMore_254_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GausR",482,G__G__MathMore_254_0_12, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GaussianTail",1221,G__G__MathMore_254_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gaussian2D",945,G__G__MathMore_254_0_14, 121, -1, -1, 0, 5, 1, 1, 0, 
"d - - 0 - sigmaX d - - 0 - sigmaY "
"d - - 0 - rho d - - 1 - x "
"d - - 1 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Exp",301,G__G__MathMore_254_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tau", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BreitWigner",1122,G__G__MathMore_254_0_16, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0.' mean d - - 0 '1' gamma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Landau",597,G__G__MathMore_254_0_17, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' mean d - - 0 '1' sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__G__MathMore_254_0_18, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LogNormal",907,G__G__MathMore_254_0_19, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - zeta d - - 0 - sigma", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ChiSquare",901,G__G__MathMore_254_0_20, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FDist",474,G__G__MathMore_254_0_21, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - nu1 d - - 0 - nu2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("tDist",520,G__G__MathMore_254_0_22, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - nu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Circle",594,G__G__MathMore_254_0_23, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sphere",615,G__G__MathMore_254_0_24, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - - 1 - x d - - 1 - y "
"d - - 1 - z d - - 0 '1' r", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Poisson",747,G__G__MathMore_254_0_25, 104, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - mu", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathMore_254_0_26, 104, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - ntot d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NegativeBinomial",1630,G__G__MathMore_254_0_27, 104, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - n d - - 0 - prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Multinomial",1163,G__G__MathMore_254_0_28, 117, G__get_linked_tagnum(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("vector<unsigned int>"), 0, 2, 1, 1, 0, 
"h - - 0 - ntot u 'vector<double,allocator<double> >' 'vector<double>' 11 - p", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Random<ROOT::Math::GSLRngGFSR4>", 2564, G__G__MathMore_254_0_29, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Random<ROOT::Math::GSLRngGFSR4>", 2690, G__G__MathMore_254_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathMore_254_0_31, (int) ('u'), G__get_linked_tagnum(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__MathMore() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_PdfFuncMathMore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_QuantFuncMathMore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_SpecFuncMathMore=0",1,(char*)NULL);
}

static void G__cpp_setup_global2() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__MathMore() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__MathMore() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__MathMoreLN_type_info = { "type_info" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_TNamed = { "TNamed" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_TVirtualIsAProxy = { "TVirtualIsAProxy" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLTInitBehavior = { "ROOT::TInitBehavior" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathMore = { "ROOT::MathMore" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim = { "ROOT::Math::IBaseFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim = { "ROOT::Math::IGradientFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim = { "ROOT::Math::IBaseFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim = { "ROOT::Math::IGradientFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientMultiDim = { "ROOT::Math::IGradientMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientOneDim = { "ROOT::Math::IGradientOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim = { "ROOT::Math::IParametricFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim = { "ROOT::Math::IParametricGradFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim = { "ROOT::Math::IParametricFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim = { "ROOT::Math::IParametricGradFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam = { "ROOT::Math::IBaseParam" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial = { "ROOT::Math::Polynomial" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR = { "ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<double,allocator<double> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR = { "vector<complex<double>,allocator<complex<double> > >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<complex<double>,allocator<complex<double> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLDerivator = { "ROOT::Math::GSLDerivator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator = { "ROOT::Math::Derivator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolation = { "ROOT::Math::Interpolation" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolationcLcLType = { "ROOT::Math::Interpolation::Type" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLInterpolator = { "ROOT::Math::GSLInterpolator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator = { "ROOT::Math::Interpolator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod = { "ROOT::Math::IRootFinderMethod" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFSolver = { "ROOT::Math::GSLRootFSolver" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper = { "ROOT::Math::GSLFunctionWrapper" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder = { "ROOT::Math::GSLRootFinder" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFdFSolver = { "ROOT::Math::GSLRootFdFSolver" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionDerivWrapper = { "ROOT::Math::GSLFunctionDerivWrapper" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv = { "ROOT::Math::GSLRootFinderDeriv" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRoots = { "ROOT::Math::Roots" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection = { "ROOT::Math::Roots::Bisection" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos = { "ROOT::Math::Roots::FalsePos" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent = { "ROOT::Math::Roots::Brent" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton = { "ROOT::Math::Roots::Newton" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant = { "ROOT::Math::Roots::Secant" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson = { "ROOT::Math::Roots::Steffenson" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDim = { "ROOT::Math::IntegrationOneDim" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType = { "ROOT::Math::IntegrationOneDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDim = { "ROOT::Math::IntegrationMultiDim" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType = { "ROOT::Math::IntegrationMultiDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions = { "ROOT::Math::IOptions" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions = { "ROOT::Math::IntegratorOneDimOptions" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions = { "ROOT::Math::IntegratorMultiDimOptions" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegrator = { "ROOT::Math::VirtualIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim = { "ROOT::Math::VirtualIntegratorOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim = { "ROOT::Math::VirtualIntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegration = { "ROOT::Math::Integration" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule = { "ROOT::Math::Integration::GKRule" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrationWorkspace = { "ROOT::Math::GSLIntegrationWorkspace" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator = { "ROOT::Math::GSLIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegration = { "ROOT::Math::MCIntegration" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegrationcLcLMode = { "ROOT::Math::MCIntegration::Mode" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters = { "ROOT::Math::VegasParameters" , 115 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters = { "ROOT::Math::MiserParameters" , 115 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrationWorkspace = { "ROOT::Math::GSLMCIntegrationWorkspace" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMonteFunctionWrapper = { "ROOT::Math::GSLMonteFunctionWrapper" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngWrapper = { "ROOT::Math::GSLRngWrapper" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator = { "ROOT::Math::GSLMCIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLIMinimizer1D = { "ROOT::Math::IMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1D = { "ROOT::Math::Minim1D" , 110 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1DcLcLType = { "ROOT::Math::Minim1D::Type" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSL1DMinimizerWrapper = { "ROOT::Math::GSL1DMinimizerWrapper" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D = { "ROOT::Math::GSLMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLChebSeries = { "ROOT::Math::GSLChebSeries" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev = { "ROOT::Math::Chebyshev" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_pairlEdoublecOdoublegR = { "pair<double,double>" , 115 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine = { "ROOT::Math::GSLRandomEngine" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned int,allocator<unsigned int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT = { "ROOT::Math::GSLRngMT" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux = { "ROOT::Math::GSLRngRanLux" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1 = { "ROOT::Math::GSLRngRanLuxS1" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2 = { "ROOT::Math::GSLRngRanLuxS2" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1 = { "ROOT::Math::GSLRngRanLuxD1" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2 = { "ROOT::Math::GSLRngRanLuxD2" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus = { "ROOT::Math::GSLRngTaus" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4 = { "ROOT::Math::GSLRngGFSR4" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions = { "ROOT::Math::KelvinFunctions" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer = { "ROOT::Math::Minimizer" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType = { "ROOT::Math::EMinimVariableType" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType = { "ROOT::Math::EGSLMinimizerType" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiMinimizer = { "ROOT::Math::GSLMultiMinimizer" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLMinimTransformFunction = { "ROOT::Math::MinimTransformFunction" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer = { "ROOT::Math::GSLMinimizer" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR = { "vector<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<string,allocator<string> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR = { "vector<ROOT::Math::EMinimVariableType,allocator<ROOT::Math::EMinimVariableType> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::Math::EMinimVariableType,allocator<ROOT::Math::EMinimVariableType> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR = { "map<unsigned int,pair<double,double>,less<unsigned int>,allocator<pair<const unsigned int,pair<double,double> > > >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiFit = { "ROOT::Math::GSLMultiFit" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc = { "ROOT::Math::LSResidualFunc" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer = { "ROOT::Math::GSLNLSMinimizer" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR = { "vector<ROOT::Math::LSResidualFunc,allocator<ROOT::Math::LSResidualFunc> >" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::Math::LSResidualFunc,allocator<ROOT::Math::LSResidualFunc> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc = { "ROOT::Math::GSLSimAnFunc" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams = { "ROOT::Math::GSLSimAnParams" , 115 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing = { "ROOT::Math::GSLSimAnnealing" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer = { "ROOT::Math::GSLSimAnMinimizer" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov = { "ROOT::Math::Vavilov" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate = { "ROOT::Math::VavilovAccurate" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratecLcLdA = { "ROOT::Math::VavilovAccurate::$" , 101 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf = { "ROOT::Math::VavilovAccuratePdf" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf = { "ROOT::Math::VavilovAccurateCdf" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile = { "ROOT::Math::VavilovAccurateQuantile" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast = { "ROOT::Math::VavilovFast" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR = { "ROOT::Math::Random<ROOT::Math::GSLRngMT>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR = { "ROOT::Math::Random<ROOT::Math::GSLRngTaus>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR = { "ROOT::Math::Random<ROOT::Math::GSLRngRanLux>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR = { "ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR = { "ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR = { "ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR = { "ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>" , 99 , -1 };
G__linked_taginfo G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR = { "ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__MathMore() {
  G__G__MathMoreLN_type_info.tagnum = -1 ;
  G__G__MathMoreLN_TClass.tagnum = -1 ;
  G__G__MathMoreLN_TNamed.tagnum = -1 ;
  G__G__MathMoreLN_TVirtualIsAProxy.tagnum = -1 ;
  G__G__MathMoreLN_ROOT.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLTInitBehavior.tagnum = -1 ;
  G__G__MathMoreLN_string.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMath.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathMore.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLDerivator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolation.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolationcLcLType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLInterpolator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFSolver.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFdFSolver.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionDerivWrapper.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRoots.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegrator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegration.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrationWorkspace.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegration.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegrationcLcLMode.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrationWorkspace.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMonteFunctionWrapper.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngWrapper.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLIMinimizer1D.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1D.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1DcLcLType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSL1DMinimizerWrapper.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLChebSeries.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev.tagnum = -1 ;
  G__G__MathMoreLN_pairlEdoublecOdoublegR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiMinimizer.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLMinimTransformFunction.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiFit.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer.tagnum = -1 ;
  G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR.tagnum = -1 ;
  G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratecLcLdA.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR.tagnum = -1 ;
  G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__MathMore() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_type_info);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_TClass);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_TNamed);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_TVirtualIsAProxy);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOT),0,-1,0,(char*)NULL,G__setup_memvarROOT,G__setup_memfuncROOT);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLTInitBehavior);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_string);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMath),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMath,G__setup_memfuncROOTcLcLMath);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathMore),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathMore,G__setup_memfuncROOTcLcLMathMore);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIGradientOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIBaseParam);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLPolynomial),sizeof(ROOT::Math::Polynomial),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLPolynomial,G__setup_memfuncROOTcLcLMathcLcLPolynomial);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR),sizeof(ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>),-1,263427,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR,G__setup_memfuncROOTcLcLMathcLcLParamFunctionlEROOTcLcLMathcLcLIParametricGradFunctionOneDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEcomplexlEdoublegRcOallocatorlEcomplexlEdoublegRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLDerivator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLDerivator),sizeof(ROOT::Math::Derivator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLDerivator,G__setup_memfuncROOTcLcLMathcLcLDerivator);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolation);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolationcLcLType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLInterpolator);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLInterpolator),sizeof(ROOT::Math::Interpolator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLInterpolator,G__setup_memfuncROOTcLcLMathcLcLInterpolator);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIRootFinderMethod);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFSolver);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionWrapper);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinder),sizeof(ROOT::Math::GSLRootFinder),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRootFinder,G__setup_memfuncROOTcLcLMathcLcLGSLRootFinder);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFdFSolver);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLFunctionDerivWrapper);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRootFinderDeriv),sizeof(ROOT::Math::GSLRootFinderDeriv),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRootFinderDeriv,G__setup_memfuncROOTcLcLMathcLcLGSLRootFinderDeriv);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRoots),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRoots,G__setup_memfuncROOTcLcLMathcLcLRoots);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBisection),sizeof(ROOT::Math::Roots::Bisection),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLBisection,G__setup_memfuncROOTcLcLMathcLcLRootscLcLBisection);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLFalsePos),sizeof(ROOT::Math::Roots::FalsePos),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLFalsePos,G__setup_memfuncROOTcLcLMathcLcLRootscLcLFalsePos);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLBrent),sizeof(ROOT::Math::Roots::Brent),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLBrent,G__setup_memfuncROOTcLcLMathcLcLRootscLcLBrent);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLNewton),sizeof(ROOT::Math::Roots::Newton),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLNewton,G__setup_memfuncROOTcLcLMathcLcLRootscLcLNewton);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSecant),sizeof(ROOT::Math::Roots::Secant),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLSecant,G__setup_memfuncROOTcLcLMathcLcLRootscLcLSecant);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRootscLcLSteffenson),sizeof(ROOT::Math::Roots::Steffenson),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootscLcLSteffenson,G__setup_memfuncROOTcLcLMathcLcLRootscLcLSteffenson);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIOptions);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorOneDimOptions);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegratorMultiDimOptions);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegrator);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegration),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegration,G__setup_memfuncROOTcLcLMathcLcLIntegration);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIntegrationcLcLGKRule);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrationWorkspace);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLIntegrator),sizeof(ROOT::Math::GSLIntegrator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLIntegrator,G__setup_memfuncROOTcLcLMathcLcLGSLIntegrator);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegration);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMCIntegrationcLcLMode);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVegasParameters),sizeof(ROOT::Math::VegasParameters),-1,297216,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVegasParameters,G__setup_memfuncROOTcLcLMathcLcLVegasParameters);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMiserParameters),sizeof(ROOT::Math::MiserParameters),-1,297216,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMiserParameters,G__setup_memfuncROOTcLcLMathcLcLMiserParameters);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrationWorkspace);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMonteFunctionWrapper);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngWrapper);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMCIntegrator),sizeof(ROOT::Math::GSLMCIntegrator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLMCIntegrator,G__setup_memfuncROOTcLcLMathcLcLGSLMCIntegrator);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLIMinimizer1D);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1D),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMinim1D,G__setup_memfuncROOTcLcLMathcLcLMinim1D);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinim1DcLcLType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSL1DMinimizerWrapper);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer1D),sizeof(ROOT::Math::GSLMinimizer1D),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLMinimizer1D,G__setup_memfuncROOTcLcLMathcLcLGSLMinimizer1D);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLChebSeries);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLChebyshev),sizeof(ROOT::Math::Chebyshev),-1,298496,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLChebyshev,G__setup_memfuncROOTcLcLMathcLcLChebyshev);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_pairlEdoublecOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRandomEngine),sizeof(ROOT::Math::GSLRandomEngine),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRandomEngine,G__setup_memfuncROOTcLcLMathcLcLGSLRandomEngine);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngMT),sizeof(ROOT::Math::GSLRngMT),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngMT,G__setup_memfuncROOTcLcLMathcLcLGSLRngMT);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLux),sizeof(ROOT::Math::GSLRngRanLux),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngRanLux,G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLux);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS1),sizeof(ROOT::Math::GSLRngRanLuxS1),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxS1,G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxS1);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxS2),sizeof(ROOT::Math::GSLRngRanLuxS2),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxS2,G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxS2);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD1),sizeof(ROOT::Math::GSLRngRanLuxD1),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxD1,G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxD1);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngRanLuxD2),sizeof(ROOT::Math::GSLRngRanLuxD2),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngRanLuxD2,G__setup_memfuncROOTcLcLMathcLcLGSLRngRanLuxD2);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngTaus),sizeof(ROOT::Math::GSLRngTaus),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngTaus,G__setup_memfuncROOTcLcLMathcLcLGSLRngTaus);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLRngGFSR4),sizeof(ROOT::Math::GSLRngGFSR4),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLRngGFSR4,G__setup_memfuncROOTcLcLMathcLcLGSLRngGFSR4);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLKelvinFunctions),sizeof(ROOT::Math::KelvinFunctions),-1,263168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLKelvinFunctions,G__setup_memfuncROOTcLcLMathcLcLKelvinFunctions);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimizer);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLEMinimVariableType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLEGSLMinimizerType);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiMinimizer);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLMinimTransformFunction);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMinimizer),sizeof(ROOT::Math::GSLMinimizer),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLMinimizer,G__setup_memfuncROOTcLcLMathcLcLGSLMinimizer);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEstringcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLEMinimVariableTypecOallocatorlEROOTcLcLMathcLcLEMinimVariableTypegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_maplEunsignedsPintcOpairlEdoublecOdoublegRcOlesslEunsignedsPintgRcOallocatorlEpairlEconstsPunsignedsPintcOpairlEdoublecOdoublegRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLMultiFit);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLLSResidualFunc),sizeof(ROOT::Math::LSResidualFunc),-1,101120,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLLSResidualFunc,G__setup_memfuncROOTcLcLMathcLcLLSResidualFunc);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLNLSMinimizer),sizeof(ROOT::Math::GSLNLSMinimizer),-1,69376,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLNLSMinimizer,G__setup_memfuncROOTcLcLMathcLcLGSLNLSMinimizer);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_vectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLSResidualFunccOallocatorlEROOTcLcLMathcLcLLSResidualFuncgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnFunc),sizeof(ROOT::Math::GSLSimAnFunc),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLSimAnFunc,G__setup_memfuncROOTcLcLMathcLcLGSLSimAnFunc);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnParams),sizeof(ROOT::Math::GSLSimAnParams),-1,262400,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLSimAnParams,G__setup_memfuncROOTcLcLMathcLcLGSLSimAnParams);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnnealing),sizeof(ROOT::Math::GSLSimAnnealing),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLSimAnnealing,G__setup_memfuncROOTcLcLMathcLcLGSLSimAnnealing);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLGSLSimAnMinimizer),sizeof(ROOT::Math::GSLSimAnMinimizer),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGSLSimAnMinimizer,G__setup_memfuncROOTcLcLMathcLcLGSLSimAnMinimizer);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilov),sizeof(ROOT::Math::Vavilov),-1,263439,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilov,G__setup_memfuncROOTcLcLMathcLcLVavilov);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurate),sizeof(ROOT::Math::VavilovAccurate),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilovAccurate,G__setup_memfuncROOTcLcLMathcLcLVavilovAccurate);
   G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratecLcLdA);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccuratePdf),sizeof(ROOT::Math::VavilovAccuratePdf),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilovAccuratePdf,G__setup_memfuncROOTcLcLMathcLcLVavilovAccuratePdf);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateCdf),sizeof(ROOT::Math::VavilovAccurateCdf),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilovAccurateCdf,G__setup_memfuncROOTcLcLMathcLcLVavilovAccurateCdf);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovAccurateQuantile),sizeof(ROOT::Math::VavilovAccurateQuantile),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilovAccurateQuantile,G__setup_memfuncROOTcLcLMathcLcLVavilovAccurateQuantile);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLVavilovFast),sizeof(ROOT::Math::VavilovFast),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVavilovFast,G__setup_memfuncROOTcLcLMathcLcLVavilovFast);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngMT>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngMTgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngTaus>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngTausgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLux>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS1gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxS2gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD1gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngRanLuxD2gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G__MathMoreLN_ROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR),sizeof(ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR,G__setup_memfuncROOTcLcLMathcLcLRandomlEROOTcLcLMathcLcLGSLRngGFSR4gR);
}
extern "C" void G__cpp_setupG__MathMore(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__MathMore()");
  G__set_cpp_environmentG__MathMore();
  G__cpp_setup_tagtableG__MathMore();

  G__cpp_setup_inheritanceG__MathMore();

  G__cpp_setup_typetableG__MathMore();

  G__cpp_setup_memvarG__MathMore();

  G__cpp_setup_memfuncG__MathMore();
  G__cpp_setup_globalG__MathMore();
  G__cpp_setup_funcG__MathMore();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__MathMore();
  return;
}
class G__cpp_setup_initG__MathMore {
  public:
    G__cpp_setup_initG__MathMore() { G__add_setup_func("G__MathMore",(G__incsetup)(&G__cpp_setupG__MathMore)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__MathMore() { G__remove_setup_func("G__MathMore"); }
};
G__cpp_setup_initG__MathMore G__cpp_setup_initializerG__MathMore;

