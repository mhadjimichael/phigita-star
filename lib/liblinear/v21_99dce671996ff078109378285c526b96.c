/* Generated by critcl on Wed Jan 04 02:43:03 +0000 2012
 * source: /web/servers/service-phgt-0/lib/liblinear/tcl/module-liblinear.tcl
 * binary: /web/local-data/critcl/module-liblinear_pic.o
 */
#include "tcl.h"

/* ---------------------------------------------------------------------- */

#line 1 "module-liblinear.tcl"

    #include "ns.h"
    #include "linear.h"
    #include <string.h>



/* ---------------------------------------------------------------------- */

#line 1 "module-liblinear.tcl"

	#define __MIN__(x,y) ((x)<(y)?(x):(y))

	/* Data Manipulation Commands */
	static struct parameter* ll_parameter_AllocData();
	static void         ll_parameter_CopyData_Area(struct parameter *copyPtr, struct parameter *dataPtr, int n);
	static void         ll_parameter_CopyData(struct parameter *copyPtr, struct parameter *dataPtr);
	static void         ll_parameter_InitData(struct parameter *dataPtr);
	static void         ll_parameter_ClearData(struct parameter *dataPtr);
	static Tcl_Obj*     ll_parameter_Tcl_Obj(struct parameter *dataPtr);
	static int          ll_parameter_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr, struct parameter *dataPtr);
	static Tcl_Obj*     ll_parameter_AllocObj(Tcl_Interp *interp);

	/* Manage Tcl Object Types */
	static void ll_parameter_FreeInternalRepProc(Tcl_Obj *objPtr);
	static void ll_parameter_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr);
	static void ll_parameter_UpdateStringProc(Tcl_Obj *objPtr);
	static int  ll_parameter_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr);

	/* Create our Tcl hash table to store our handle look-ups.
	 * We keep track of all of our handles in a hash table so that
	 * we can always go back to something and look up our data should
	 * we lose the pointer to our struct.
	 */

	static Tcl_HashTable ll_parameter_HashTable;   /* TODO: Replace with critbit tree.  */
	static Tcl_Mutex     ll_parameter_HashTableMutex;
	static int           ll_parameter_ModuleInitialized;

	/* Now, we want to define a struct that will hold our data.  The first
	 * three fields are Tcl-related and make it really easy for us to circle
	 * back and find our related pieces.
	 */

	typedef struct ll_parameter_InternalStruct {
	    Tcl_Interp    *interp;  /* The Tcl interpreter where we were created.  */
	    Tcl_Obj       *objPtr;  /*   The object that contains our string rep.  */
	    Tcl_HashEntry *hashPtr; /* The pointer to our entry in the hash table. */
	    struct parameter   *dataPtr; /* Our native data.                            */

	    int epoch;
	    int refCount;

	} ll_parameter_InternalType;

	static char ll_parameter_name[] = "ll_parameter";

	static Tcl_ObjType ll_parameter_ObjType = {
	    ll_parameter_name,                          /* name */
	    ll_parameter_FreeInternalRepProc,                  /* freeIntRepProc */
	    ll_parameter_DupInternalRepProc,                   /* dupIntRepProc */
	    ll_parameter_UpdateStringProc,                     /* updateStringProc */
	    ll_parameter_SetFromAnyProc                        /* setFromAnyProc */
	};


	static void ll_parameter_InitData(struct parameter *dataPtr) {
	    /* Init Data Code */
	    memset(dataPtr,0,sizeof(struct parameter));
	}

	static struct parameter *ll_parameter_AllocData() {
	    struct parameter *dataPtr /* dataPtr */ = (struct parameter *)Tcl_Alloc(sizeof(struct parameter));
	    ll_parameter_InitData(dataPtr);
	    return  dataPtr /* dataPtr */  ;
	}

	static void ll_parameter_CopyData_Area(struct parameter *copyPtr /* copyPtr */, struct parameter *dataPtr /* dataPtr */, int  n /* n */ ) {
	    
	    int i;
	    for(i=0; i<n; i++) {
		ll_parameter_CopyData(&(copyPtr[i]), &(dataPtr[i]));
	    }
	
	}

	static void ll_parameter_CopyData(struct parameter *copyPtr /* copyPtr */, struct parameter *dataPtr /* dataPtr */ ) {

	    /* Copy Data Code */
	    
	
	 copyPtr->solver_type=dataPtr->solver_type;
	 copyPtr->eps=dataPtr->eps;
	 copyPtr->C=dataPtr->C;
	 copyPtr->nr_weight=dataPtr->nr_weight;
	 copyPtr->weight_label = (int*) Tcl_Alloc(dataPtr->nr_weight * sizeof(int));
	 memcpy(copyPtr->weight_label, dataPtr->weight_label, dataPtr->nr_weight * sizeof(int));
	 copyPtr->weight = (double*) Tcl_Alloc(dataPtr->nr_weight * sizeof(double));
	 memcpy(copyPtr->weight, dataPtr->weight, dataPtr->nr_weight * sizeof(double));

	    // Ns_Log(Notice,"data dataPtr=%s",Tcl_GetString(ll_parameter_Tcl_Obj(copyPtr)));
	    // Ns_Log(Notice,"target copyPtr=%s",Tcl_GetString(ll_parameter_Tcl_Obj(dataPtr)));
	}

	static void ll_parameter_ClearData(struct parameter *dataPtr /* dataPtr */) {
	    /* Clear Data Code */
	    
	    int i;
	    /* No clear needed for solver_type */
	    /* No clear needed for eps */
	    /* No clear needed for C */
	    /* No clear needed for nr_weight */
	    for(i=dataPtr->nr_weight - 1; i>=0; i--) {
	        Tcl_Free((char *) &dataPtr->weight_label[i]); /* HERE - HERE - HERE - HERE - HERE - HERE: clear_from_defs proc*/
	    }
	    for(i=dataPtr->nr_weight - 1; i>=0; i--) {
	        Tcl_Free((char *) &dataPtr->weight[i]); /* HERE - HERE - HERE - HERE - HERE - HERE: clear_from_defs proc*/
	    }
	    Tcl_Free((char *) dataPtr /* dataPtr */)  ;
	}

	/* Get Tcl_Obj From Data */
	static Tcl_Obj* /* listPtr */ ll_parameter_Tcl_Obj(struct parameter *dataPtr /* dataPtr */) {
	    /* New Tcl Object From Data */
	    
	Tcl_Obj *listPtr = Tcl_NewListObj(0,NULL);
	Tcl_Obj *listPtr_L0;
	int i;
	int llength_i;


	 /* int solver_type */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->solver_type));

	 /* double eps */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewDoubleObj(dataPtr->eps));

	 /* double C */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewDoubleObj(dataPtr->C));

	 /* int nr_weight */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->nr_weight));

	 /* int* weight_label */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->nr_weight; i++) {
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, Tcl_NewIntObj(dataPtr->weight_label[i]));
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 /* double* weight */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->nr_weight; i++) {
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, Tcl_NewDoubleObj(dataPtr->weight[i]));
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 return listPtr; /* listPtr */
	}

	static int ll_parameter_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr /* listPtr */, struct parameter *dataPtr /* dataPtr */) {
	    /* Get Data From Tcl Obj */
	    
	Tcl_Obj *listPtr_Elem_L0;
	Tcl_Obj *listPtr_Elem_L1;
	int i;
	int listPtr_LLength;
	int llength_i;

 listPtr_LLength=0;
 if (Tcl_ListObjLength(interp, listPtr, &listPtr_LLength) != TCL_OK) { return TCL_ERROR; }
 if ( listPtr_LLength != 6 ) { return TCL_ERROR; }

	    /* int solver_type */
	    Ns_Log(Notice,"getting int solver_type");
	    Tcl_ListObjIndex(interp, listPtr, 0, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"solver_type listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->solver_type));

	    /* double eps */
	    Ns_Log(Notice,"getting double eps");
	    Tcl_ListObjIndex(interp, listPtr, 1, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"eps listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetDoubleFromObj(interp,listPtr_Elem_L0,&(dataPtr->eps));

	    /* double C */
	    Ns_Log(Notice,"getting double C");
	    Tcl_ListObjIndex(interp, listPtr, 2, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"C listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetDoubleFromObj(interp,listPtr_Elem_L0,&(dataPtr->C));

	    /* int nr_weight */
	    Ns_Log(Notice,"getting int nr_weight");
	    Tcl_ListObjIndex(interp, listPtr, 3, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"nr_weight listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->nr_weight));

	    /* int* weight_label */
	    Ns_Log(Notice,"getting int* weight_label");
	    Tcl_ListObjIndex(interp, listPtr, 4, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"weight_label listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->weight_label = (int*) Tcl_Alloc(dataPtr->nr_weight * sizeof(int));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->nr_weight; i++) {
 Ns_Log(Notice,"weight_label i = %d dataPtr->nr_weight = %d",i,dataPtr->nr_weight);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 Tcl_GetIntFromObj(interp,listPtr_Elem_L1,&(dataPtr->weight_label[i]));
	 }

	    /* double* weight */
	    Ns_Log(Notice,"getting double* weight");
	    Tcl_ListObjIndex(interp, listPtr, 5, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"weight listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->weight = (double*) Tcl_Alloc(dataPtr->nr_weight * sizeof(double));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->nr_weight; i++) {
 Ns_Log(Notice,"weight i = %d dataPtr->nr_weight = %d",i,dataPtr->nr_weight);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 Tcl_GetDoubleFromObj(interp,listPtr_Elem_L1,&(dataPtr->weight[i]));
	 }
	    return TCL_OK;
	}

	static Tcl_Obj *ll_parameter_AllocObj(Tcl_Interp *interp) {

	    Tcl_Obj *objPtr = Tcl_NewObj();

	    /* TODO: Check why SetFromAnyProc is called whenever we invoke ll_parameter_AllocObj 
 	     * Perhaps, we should just call SetFromAnyProc here and get over with it;
	     */

	    ll_parameter_InternalType *internal = (ll_parameter_InternalType *)Tcl_Alloc(sizeof(ll_parameter_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = (struct parameter *)ll_parameter_AllocData();
	    internal->objPtr = objPtr;
	    internal->hashPtr = NULL;
	    internal->refCount = 0;

	    objPtr->bytes = NULL;
	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_parameter_ObjType;

	    return objPtr;

	}

	static void ll_parameter_FreeInternalRepProc(Tcl_Obj *objPtr)
	{
	    ll_parameter_InternalType *internal = (ll_parameter_InternalType *)objPtr->internalRep.otherValuePtr;
	    ll_parameter_ClearData((struct parameter *)internal->dataPtr);
	    Tcl_Free((char *)internal);
	    objPtr->typePtr = NULL;
	}

	static void ll_parameter_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr)
	{
	    ll_parameter_InternalType *internal = (ll_parameter_InternalType *)srcPtr->internalRep.otherValuePtr;
	    dupPtr->internalRep.otherValuePtr = Tcl_Alloc(sizeof(ll_parameter_InternalType));
	    ll_parameter_InternalType *internal2 = (ll_parameter_InternalType *)dupPtr->internalRep.otherValuePtr;
	    ll_parameter_CopyData((struct parameter *) internal2->dataPtr,(struct parameter *)internal->dataPtr);
	    dupPtr->typePtr = &ll_parameter_ObjType;
	}

	static void ll_parameter_UpdateStringProc(Tcl_Obj *objPtr)
	{
	    char *str;
	    Tcl_Obj *listPtr;
	    ll_parameter_InternalType *internal = (ll_parameter_InternalType *) objPtr->internalRep.otherValuePtr;
	    listPtr = ll_parameter_Tcl_Obj(internal->dataPtr);
	    str = Tcl_GetStringFromObj(listPtr, &objPtr->length);
	    objPtr->bytes = Tcl_Alloc(objPtr->length+1);
	    memcpy(objPtr->bytes, str, objPtr->length+1);
	    Tcl_IncrRefCount(listPtr);
	    Tcl_DecrRefCount(listPtr);
	}

	static int  ll_parameter_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr)
	{

	    /* TODO: Make sure this works without causing any unwanted side-effects. */
	    /* TODO: this is not quite right - revisit
	     * if (objPtr->typePtr == &ll_parameter_ObjType) {
	     *	 return TCL_OK;
	     * }
	     */

	    Tcl_Obj *listPtr = Tcl_DuplicateObj(objPtr);
	    int count;
	    int i;


	    Tcl_IncrRefCount(listPtr);
	    if (Tcl_ListObjLength(interp, listPtr, &count) != TCL_OK)
	    {
		Tcl_DecrRefCount(listPtr);
		return TCL_ERROR;
	    }


	    if (objPtr->typePtr && objPtr->typePtr->freeIntRepProc) 
	    {
		objPtr->typePtr->freeIntRepProc(objPtr);
	    }

	    ll_parameter_InternalType *internal;
	    internal = (ll_parameter_InternalType *)Tcl_Alloc(sizeof(ll_parameter_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = ll_parameter_AllocData();

	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_parameter_ObjType;
	    return ll_parameter_GetDataFromObj(interp,listPtr,internal->dataPtr);

	}


	/***********************************************************************/

	static int ll_parameter_RegisterShared (const char *key, Tcl_Obj *objPtr)
	{
	    Tcl_HashEntry *entryPtr;
	    int refCount, newEntry;

	    Tcl_MutexLock(&ll_parameter_HashTableMutex);
	    refCount = ++objPtr->refCount;
	    entryPtr = Tcl_CreateHashEntry(&ll_parameter_HashTable, (char*)key /* internal */, &newEntry);
	    if (newEntry) {
		Tcl_SetHashValue(entryPtr, (ClientData)objPtr);
		//internal->hashPtr = entryPtr;
	    }
	    Tcl_MutexUnlock(&ll_parameter_HashTableMutex);

	    /*
	    * DBG(fprintf(stderr, "--> ll_parameter_RegisterShared: ll_parameter data %p %s "
	     *		"shared table now with refcount of %d\n", objPtr,
	     *		newEntry ? "entered into" : "already in", refCount));
	     */
	    return 0;
	}


	/* see tDOM's tcldom_returnDocumentObj for more details */

	int ll_parameter_ReturnHandle (Tcl_Interp  *interp, Tcl_Obj *objPtr, int setVariable, Tcl_Obj *varNameObj)
	{
	    char        objCmdName[80], *varName;
	    Tcl_CmdInfo cmdInfo;
	    //ll_parameter_InternalType *internal = (ll_parameter_InternalType *) objPtr->internalRep.otherValuePtr;

	    if (objPtr /* internal->dataPtr */ == NULL) {
		if (setVariable) {
		    varName = Tcl_GetString(varNameObj);
		    Tcl_UnsetVar(interp, varName, 0);
		    Tcl_SetVar  (interp, varName, "", 0);
		}
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp), (""), -1);
		return TCL_OK;
	    }

	    sprintf((objCmdName), "__ll_parameter__%p", (objPtr));

	    if (setVariable) {
		varName = Tcl_GetString(varNameObj);
		Tcl_SetVar(interp, varName, objCmdName, 0);
	    }

	    // HERE - FIX: 
	    ll_parameter_RegisterShared(objCmdName,objPtr);



	    /* Set Result */
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), (objCmdName), -1);
	    return TCL_OK;
	}

	/***********************************************************************/

	static
	int ll_parameter_CreateCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{
	    int         setVariable = 0;
	    Tcl_Obj     *objPtr;
	    Tcl_Obj     *newObjName = NULL;


	    //CheckArgs(2,3,1,"?newObjVar?");

	    if (objc == 2) {
		newObjName = objv[1];
		setVariable = 1;
	    }

	    objPtr = ll_parameter_AllocObj(interp);
	    if (objPtr == NULL) {
		return TCL_ERROR;
	    }

	    return ll_parameter_ReturnHandle(interp, objPtr, setVariable, newObjName);
	}

	static Tcl_Obj *ll_parameter_GetObjFromHandle(Tcl_Interp *interp, Tcl_HashTable *ht, Tcl_Obj *objVar)
	{

	    Tcl_Obj *handle = Tcl_ObjGetVar2(interp, objVar, NULL, TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1);
	    Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(ht,(char *)Tcl_GetString(handle));
	    if (entryPtr == NULL) {
		//Tcl_AddErrorInfo(interp,"no such handle");
		return NULL;
	    }
	    return /* Tcl_Obj *objPtr = */ (Tcl_Obj *) Tcl_GetHashValue(entryPtr);

	}

	static
	int ll_parameter_SetCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{


	    //CheckArgs(2,3,1,"docElemName ?newObjVar?");

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "varName list");
		return TCL_ERROR;
	    }

	    Tcl_Obj *objPtr = (Tcl_Obj *) ll_parameter_GetObjFromHandle(interp, &ll_parameter_HashTable,objv[1]);
	    if (objPtr==NULL) {
		Tcl_AddErrorInfo(interp,"no such handle");
		return TCL_ERROR;
	    }

	    ll_parameter_InternalType *internal = (ll_parameter_InternalType *) objPtr->internalRep.otherValuePtr;

	    if ( objPtr == NULL ) {
		Tcl_AddErrorInfo(interp,"no such object found (objPtr is NULL)");
		return TCL_ERROR;
	    }

	    ll_parameter_GetDataFromObj(interp,objv[2],internal->dataPtr);
	    Tcl_SetObjResult(interp,objPtr);
	    return TCL_OK;

	}

	/*----------------------------------------------------------------------------
	|   Exit Handler: ll_parameter_ExitHandler
	|
	|   Activated in application exit handler to delete shared document table
	|   Table entries are deleted by the object command deletion callbacks,
	|   so at this time, table should be empty. If not, we will leave some
	|   memory leaks. This is not fatal, though: we're exiting the app anyway.
	|   This is a private function to this file. 
	\---------------------------------------------------------------------------*/

	static void ll_parameter_ExitHandler(ClientData unused)
	{
	    Tcl_MutexLock(&ll_parameter_HashTableMutex);
	    Tcl_DeleteHashTable(&ll_parameter_HashTable);
	    Tcl_MutexUnlock(&ll_parameter_HashTableMutex);
	}

	/*----------------------------------------------------------------------------
	|   Initialize Module
	|   Activated at module load to initialize shared object handles table.
	|   This is exported since we need it in HERE: tdominit.c.
	\---------------------------------------------------------------------------*/


	void ll_parameter_InitModule()
	{
	    Tcl_MutexLock(&ll_parameter_HashTableMutex);
	    if (!ll_parameter_ModuleInitialized) {
		//Tcl_InitHashTable(&ll_parameter_HashTable, TCL_ONE_WORD_KEYS);
		Tcl_InitHashTable(&ll_parameter_HashTable, TCL_STRING_KEYS);
		Tcl_CreateExitHandler(ll_parameter_ExitHandler, NULL);
		ll_parameter_ModuleInitialized = 1;
	    }
	    Tcl_MutexUnlock(&ll_parameter_HashTableMutex);
	}


    

/* ---------------------------------------------------------------------- */

#line 1 "module-liblinear.tcl"

	#define __MIN__(x,y) ((x)<(y)?(x):(y))

	/* Data Manipulation Commands */
	static struct feature_node* ll_feature_node_AllocData();
	static void         ll_feature_node_CopyData_Area(struct feature_node *copyPtr, struct feature_node *dataPtr, int n);
	static void         ll_feature_node_CopyData(struct feature_node *copyPtr, struct feature_node *dataPtr);
	static void         ll_feature_node_InitData(struct feature_node *dataPtr);
	static void         ll_feature_node_ClearData(struct feature_node *dataPtr);
	static Tcl_Obj*     ll_feature_node_Tcl_Obj(struct feature_node *dataPtr);
	static int          ll_feature_node_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr, struct feature_node *dataPtr);
	static Tcl_Obj*     ll_feature_node_AllocObj(Tcl_Interp *interp);

	/* Manage Tcl Object Types */
	static void ll_feature_node_FreeInternalRepProc(Tcl_Obj *objPtr);
	static void ll_feature_node_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr);
	static void ll_feature_node_UpdateStringProc(Tcl_Obj *objPtr);
	static int  ll_feature_node_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr);

	/* Create our Tcl hash table to store our handle look-ups.
	 * We keep track of all of our handles in a hash table so that
	 * we can always go back to something and look up our data should
	 * we lose the pointer to our struct.
	 */

	static Tcl_HashTable ll_feature_node_HashTable;   /* TODO: Replace with critbit tree.  */
	static Tcl_Mutex     ll_feature_node_HashTableMutex;
	static int           ll_feature_node_ModuleInitialized;

	/* Now, we want to define a struct that will hold our data.  The first
	 * three fields are Tcl-related and make it really easy for us to circle
	 * back and find our related pieces.
	 */

	typedef struct ll_feature_node_InternalStruct {
	    Tcl_Interp    *interp;  /* The Tcl interpreter where we were created.  */
	    Tcl_Obj       *objPtr;  /*   The object that contains our string rep.  */
	    Tcl_HashEntry *hashPtr; /* The pointer to our entry in the hash table. */
	    struct feature_node   *dataPtr; /* Our native data.                            */

	    int epoch;
	    int refCount;

	} ll_feature_node_InternalType;

	static char ll_feature_node_name[] = "ll_feature_node";

	static Tcl_ObjType ll_feature_node_ObjType = {
	    ll_feature_node_name,                          /* name */
	    ll_feature_node_FreeInternalRepProc,                  /* freeIntRepProc */
	    ll_feature_node_DupInternalRepProc,                   /* dupIntRepProc */
	    ll_feature_node_UpdateStringProc,                     /* updateStringProc */
	    ll_feature_node_SetFromAnyProc                        /* setFromAnyProc */
	};


	static void ll_feature_node_InitData(struct feature_node *dataPtr) {
	    /* Init Data Code */
	    memset(dataPtr,0,sizeof(struct feature_node));
	}

	static struct feature_node *ll_feature_node_AllocData() {
	    struct feature_node *dataPtr /* dataPtr */ = (struct feature_node *)Tcl_Alloc(sizeof(struct feature_node));
	    ll_feature_node_InitData(dataPtr);
	    return  dataPtr /* dataPtr */  ;
	}

	static void ll_feature_node_CopyData_Area(struct feature_node *copyPtr /* copyPtr */, struct feature_node *dataPtr /* dataPtr */, int  n /* n */ ) {
	    
	    memcpy(copyPtr,dataPtr, n * sizeof(struct feature_node));
	
	}

	static void ll_feature_node_CopyData(struct feature_node *copyPtr /* copyPtr */, struct feature_node *dataPtr /* dataPtr */ ) {

	    /* Copy Data Code */
	    
	
	 copyPtr->index=dataPtr->index;
	 copyPtr->value=dataPtr->value;

	    // Ns_Log(Notice,"data dataPtr=%s",Tcl_GetString(ll_feature_node_Tcl_Obj(copyPtr)));
	    // Ns_Log(Notice,"target copyPtr=%s",Tcl_GetString(ll_feature_node_Tcl_Obj(dataPtr)));
	}

	static void ll_feature_node_ClearData(struct feature_node *dataPtr /* dataPtr */) {
	    /* Clear Data Code */
	    
	    /* No clear needed for index */
	    /* No clear needed for value */
	    Tcl_Free((char *) dataPtr /* dataPtr */)  ;
	}

	/* Get Tcl_Obj From Data */
	static Tcl_Obj* /* listPtr */ ll_feature_node_Tcl_Obj(struct feature_node *dataPtr /* dataPtr */) {
	    /* New Tcl Object From Data */
	    
	Tcl_Obj *listPtr = Tcl_NewListObj(0,NULL);


	 /* int index */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->index));

	 /* double value */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewDoubleObj(dataPtr->value));

	 return listPtr; /* listPtr */
	}

	static int ll_feature_node_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr /* listPtr */, struct feature_node *dataPtr /* dataPtr */) {
	    /* Get Data From Tcl Obj */
	    
	Tcl_Obj *listPtr_Elem_L0;
	int listPtr_LLength;

 listPtr_LLength=0;
 if (Tcl_ListObjLength(interp, listPtr, &listPtr_LLength) != TCL_OK) { return TCL_ERROR; }
 if ( listPtr_LLength != 2 ) { return TCL_ERROR; }

	    /* int index */
	    Ns_Log(Notice,"getting int index");
	    Tcl_ListObjIndex(interp, listPtr, 0, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"index listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->index));

	    /* double value */
	    Ns_Log(Notice,"getting double value");
	    Tcl_ListObjIndex(interp, listPtr, 1, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"value listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetDoubleFromObj(interp,listPtr_Elem_L0,&(dataPtr->value));
	    return TCL_OK;
	}

	static Tcl_Obj *ll_feature_node_AllocObj(Tcl_Interp *interp) {

	    Tcl_Obj *objPtr = Tcl_NewObj();

	    /* TODO: Check why SetFromAnyProc is called whenever we invoke ll_feature_node_AllocObj 
 	     * Perhaps, we should just call SetFromAnyProc here and get over with it;
	     */

	    ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *)Tcl_Alloc(sizeof(ll_feature_node_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = (struct feature_node *)ll_feature_node_AllocData();
	    internal->objPtr = objPtr;
	    internal->hashPtr = NULL;
	    internal->refCount = 0;

	    objPtr->bytes = NULL;
	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_feature_node_ObjType;

	    return objPtr;

	}

	static void ll_feature_node_FreeInternalRepProc(Tcl_Obj *objPtr)
	{
	    ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *)objPtr->internalRep.otherValuePtr;
	    ll_feature_node_ClearData((struct feature_node *)internal->dataPtr);
	    Tcl_Free((char *)internal);
	    objPtr->typePtr = NULL;
	}

	static void ll_feature_node_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr)
	{
	    ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *)srcPtr->internalRep.otherValuePtr;
	    dupPtr->internalRep.otherValuePtr = Tcl_Alloc(sizeof(ll_feature_node_InternalType));
	    ll_feature_node_InternalType *internal2 = (ll_feature_node_InternalType *)dupPtr->internalRep.otherValuePtr;
	    ll_feature_node_CopyData((struct feature_node *) internal2->dataPtr,(struct feature_node *)internal->dataPtr);
	    dupPtr->typePtr = &ll_feature_node_ObjType;
	}

	static void ll_feature_node_UpdateStringProc(Tcl_Obj *objPtr)
	{
	    char *str;
	    Tcl_Obj *listPtr;
	    ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *) objPtr->internalRep.otherValuePtr;
	    listPtr = ll_feature_node_Tcl_Obj(internal->dataPtr);
	    str = Tcl_GetStringFromObj(listPtr, &objPtr->length);
	    objPtr->bytes = Tcl_Alloc(objPtr->length+1);
	    memcpy(objPtr->bytes, str, objPtr->length+1);
	    Tcl_IncrRefCount(listPtr);
	    Tcl_DecrRefCount(listPtr);
	}

	static int  ll_feature_node_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr)
	{

	    /* TODO: Make sure this works without causing any unwanted side-effects. */
	    /* TODO: this is not quite right - revisit
	     * if (objPtr->typePtr == &ll_feature_node_ObjType) {
	     *	 return TCL_OK;
	     * }
	     */

	    Tcl_Obj *listPtr = Tcl_DuplicateObj(objPtr);
	    int count;
	    int i;


	    Tcl_IncrRefCount(listPtr);
	    if (Tcl_ListObjLength(interp, listPtr, &count) != TCL_OK)
	    {
		Tcl_DecrRefCount(listPtr);
		return TCL_ERROR;
	    }


	    if (objPtr->typePtr && objPtr->typePtr->freeIntRepProc) 
	    {
		objPtr->typePtr->freeIntRepProc(objPtr);
	    }

	    ll_feature_node_InternalType *internal;
	    internal = (ll_feature_node_InternalType *)Tcl_Alloc(sizeof(ll_feature_node_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = ll_feature_node_AllocData();

	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_feature_node_ObjType;
	    return ll_feature_node_GetDataFromObj(interp,listPtr,internal->dataPtr);

	}


	/***********************************************************************/

	static int ll_feature_node_RegisterShared (const char *key, Tcl_Obj *objPtr)
	{
	    Tcl_HashEntry *entryPtr;
	    int refCount, newEntry;

	    Tcl_MutexLock(&ll_feature_node_HashTableMutex);
	    refCount = ++objPtr->refCount;
	    entryPtr = Tcl_CreateHashEntry(&ll_feature_node_HashTable, (char*)key /* internal */, &newEntry);
	    if (newEntry) {
		Tcl_SetHashValue(entryPtr, (ClientData)objPtr);
		//internal->hashPtr = entryPtr;
	    }
	    Tcl_MutexUnlock(&ll_feature_node_HashTableMutex);

	    /*
	    * DBG(fprintf(stderr, "--> ll_feature_node_RegisterShared: ll_feature_node data %p %s "
	     *		"shared table now with refcount of %d\n", objPtr,
	     *		newEntry ? "entered into" : "already in", refCount));
	     */
	    return 0;
	}


	/* see tDOM's tcldom_returnDocumentObj for more details */

	int ll_feature_node_ReturnHandle (Tcl_Interp  *interp, Tcl_Obj *objPtr, int setVariable, Tcl_Obj *varNameObj)
	{
	    char        objCmdName[80], *varName;
	    Tcl_CmdInfo cmdInfo;
	    //ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *) objPtr->internalRep.otherValuePtr;

	    if (objPtr /* internal->dataPtr */ == NULL) {
		if (setVariable) {
		    varName = Tcl_GetString(varNameObj);
		    Tcl_UnsetVar(interp, varName, 0);
		    Tcl_SetVar  (interp, varName, "", 0);
		}
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp), (""), -1);
		return TCL_OK;
	    }

	    sprintf((objCmdName), "__ll_feature_node__%p", (objPtr));

	    if (setVariable) {
		varName = Tcl_GetString(varNameObj);
		Tcl_SetVar(interp, varName, objCmdName, 0);
	    }

	    // HERE - FIX: 
	    ll_feature_node_RegisterShared(objCmdName,objPtr);



	    /* Set Result */
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), (objCmdName), -1);
	    return TCL_OK;
	}

	/***********************************************************************/

	static
	int ll_feature_node_CreateCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{
	    int         setVariable = 0;
	    Tcl_Obj     *objPtr;
	    Tcl_Obj     *newObjName = NULL;


	    //CheckArgs(2,3,1,"?newObjVar?");

	    if (objc == 2) {
		newObjName = objv[1];
		setVariable = 1;
	    }

	    objPtr = ll_feature_node_AllocObj(interp);
	    if (objPtr == NULL) {
		return TCL_ERROR;
	    }

	    return ll_feature_node_ReturnHandle(interp, objPtr, setVariable, newObjName);
	}

	static Tcl_Obj *ll_feature_node_GetObjFromHandle(Tcl_Interp *interp, Tcl_HashTable *ht, Tcl_Obj *objVar)
	{

	    Tcl_Obj *handle = Tcl_ObjGetVar2(interp, objVar, NULL, TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1);
	    Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(ht,(char *)Tcl_GetString(handle));
	    if (entryPtr == NULL) {
		//Tcl_AddErrorInfo(interp,"no such handle");
		return NULL;
	    }
	    return /* Tcl_Obj *objPtr = */ (Tcl_Obj *) Tcl_GetHashValue(entryPtr);

	}

	static
	int ll_feature_node_SetCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{


	    //CheckArgs(2,3,1,"docElemName ?newObjVar?");

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "varName list");
		return TCL_ERROR;
	    }

	    Tcl_Obj *objPtr = (Tcl_Obj *) ll_feature_node_GetObjFromHandle(interp, &ll_feature_node_HashTable,objv[1]);
	    if (objPtr==NULL) {
		Tcl_AddErrorInfo(interp,"no such handle");
		return TCL_ERROR;
	    }

	    ll_feature_node_InternalType *internal = (ll_feature_node_InternalType *) objPtr->internalRep.otherValuePtr;

	    if ( objPtr == NULL ) {
		Tcl_AddErrorInfo(interp,"no such object found (objPtr is NULL)");
		return TCL_ERROR;
	    }

	    ll_feature_node_GetDataFromObj(interp,objv[2],internal->dataPtr);
	    Tcl_SetObjResult(interp,objPtr);
	    return TCL_OK;

	}

	/*----------------------------------------------------------------------------
	|   Exit Handler: ll_feature_node_ExitHandler
	|
	|   Activated in application exit handler to delete shared document table
	|   Table entries are deleted by the object command deletion callbacks,
	|   so at this time, table should be empty. If not, we will leave some
	|   memory leaks. This is not fatal, though: we're exiting the app anyway.
	|   This is a private function to this file. 
	\---------------------------------------------------------------------------*/

	static void ll_feature_node_ExitHandler(ClientData unused)
	{
	    Tcl_MutexLock(&ll_feature_node_HashTableMutex);
	    Tcl_DeleteHashTable(&ll_feature_node_HashTable);
	    Tcl_MutexUnlock(&ll_feature_node_HashTableMutex);
	}

	/*----------------------------------------------------------------------------
	|   Initialize Module
	|   Activated at module load to initialize shared object handles table.
	|   This is exported since we need it in HERE: tdominit.c.
	\---------------------------------------------------------------------------*/


	void ll_feature_node_InitModule()
	{
	    Tcl_MutexLock(&ll_feature_node_HashTableMutex);
	    if (!ll_feature_node_ModuleInitialized) {
		//Tcl_InitHashTable(&ll_feature_node_HashTable, TCL_ONE_WORD_KEYS);
		Tcl_InitHashTable(&ll_feature_node_HashTable, TCL_STRING_KEYS);
		Tcl_CreateExitHandler(ll_feature_node_ExitHandler, NULL);
		ll_feature_node_ModuleInitialized = 1;
	    }
	    Tcl_MutexUnlock(&ll_feature_node_HashTableMutex);
	}


    

/* ---------------------------------------------------------------------- */

#line 1 "module-liblinear.tcl"

	#define __MIN__(x,y) ((x)<(y)?(x):(y))

	/* Data Manipulation Commands */
	static struct problem* ll_problem_AllocData();
	static void         ll_problem_CopyData_Area(struct problem *copyPtr, struct problem *dataPtr, int n);
	static void         ll_problem_CopyData(struct problem *copyPtr, struct problem *dataPtr);
	static void         ll_problem_InitData(struct problem *dataPtr);
	static void         ll_problem_ClearData(struct problem *dataPtr);
	static Tcl_Obj*     ll_problem_Tcl_Obj(struct problem *dataPtr);
	static int          ll_problem_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr, struct problem *dataPtr);
	static Tcl_Obj*     ll_problem_AllocObj(Tcl_Interp *interp);

	/* Manage Tcl Object Types */
	static void ll_problem_FreeInternalRepProc(Tcl_Obj *objPtr);
	static void ll_problem_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr);
	static void ll_problem_UpdateStringProc(Tcl_Obj *objPtr);
	static int  ll_problem_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr);

	/* Create our Tcl hash table to store our handle look-ups.
	 * We keep track of all of our handles in a hash table so that
	 * we can always go back to something and look up our data should
	 * we lose the pointer to our struct.
	 */

	static Tcl_HashTable ll_problem_HashTable;   /* TODO: Replace with critbit tree.  */
	static Tcl_Mutex     ll_problem_HashTableMutex;
	static int           ll_problem_ModuleInitialized;

	/* Now, we want to define a struct that will hold our data.  The first
	 * three fields are Tcl-related and make it really easy for us to circle
	 * back and find our related pieces.
	 */

	typedef struct ll_problem_InternalStruct {
	    Tcl_Interp    *interp;  /* The Tcl interpreter where we were created.  */
	    Tcl_Obj       *objPtr;  /*   The object that contains our string rep.  */
	    Tcl_HashEntry *hashPtr; /* The pointer to our entry in the hash table. */
	    struct problem   *dataPtr; /* Our native data.                            */

	    int epoch;
	    int refCount;

	} ll_problem_InternalType;

	static char ll_problem_name[] = "ll_problem";

	static Tcl_ObjType ll_problem_ObjType = {
	    ll_problem_name,                          /* name */
	    ll_problem_FreeInternalRepProc,                  /* freeIntRepProc */
	    ll_problem_DupInternalRepProc,                   /* dupIntRepProc */
	    ll_problem_UpdateStringProc,                     /* updateStringProc */
	    ll_problem_SetFromAnyProc                        /* setFromAnyProc */
	};


	static void ll_problem_InitData(struct problem *dataPtr) {
	    /* Init Data Code */
	    memset(dataPtr,0,sizeof(struct problem));
	}

	static struct problem *ll_problem_AllocData() {
	    struct problem *dataPtr /* dataPtr */ = (struct problem *)Tcl_Alloc(sizeof(struct problem));
	    ll_problem_InitData(dataPtr);
	    return  dataPtr /* dataPtr */  ;
	}

	static void ll_problem_CopyData_Area(struct problem *copyPtr /* copyPtr */, struct problem *dataPtr /* dataPtr */, int  n /* n */ ) {
	    
	    int i;
	    for(i=0; i<n; i++) {
		ll_problem_CopyData(&(copyPtr[i]), &(dataPtr[i]));
	    }
	
	}

	static void ll_problem_CopyData(struct problem *copyPtr /* copyPtr */, struct problem *dataPtr /* dataPtr */ ) {

	    /* Copy Data Code */
	    
	int i;
	int j_max;
	
	 copyPtr->l=dataPtr->l;
	 copyPtr->n=dataPtr->n;
	 copyPtr->y = (int*) Tcl_Alloc(dataPtr->l * sizeof(int));
	 memcpy(copyPtr->y, dataPtr->y, dataPtr->l * sizeof(int));
	 copyPtr->x = (struct feature_node**) Tcl_Alloc(dataPtr->l * sizeof(struct feature_node*));
	 for(i=0; i < dataPtr->l; i++) {
		 j_max=0; while (dataPtr->x[i][j_max].index != -1) { j_max++; };
		 copyPtr->x[i] = (struct feature_node*) Tcl_Alloc((__MIN__(dataPtr->n,1+j_max)) * sizeof(struct feature_node));
		 ll_feature_node_CopyData_Area(copyPtr->x[i],dataPtr->x[i],(__MIN__(dataPtr->n,1+j_max)));
	 }
	 copyPtr->bias=dataPtr->bias;

	    // Ns_Log(Notice,"data dataPtr=%s",Tcl_GetString(ll_problem_Tcl_Obj(copyPtr)));
	    // Ns_Log(Notice,"target copyPtr=%s",Tcl_GetString(ll_problem_Tcl_Obj(dataPtr)));
	}

	static void ll_problem_ClearData(struct problem *dataPtr /* dataPtr */) {
	    /* Clear Data Code */
	    
	    int j;
	    int i;
	    /* No clear needed for l */
	    /* No clear needed for n */
	    for(i=dataPtr->l - 1; i>=0; i--) {
	        Tcl_Free((char *) &dataPtr->y[i]); /* HERE - HERE - HERE - HERE - HERE - HERE: clear_from_defs proc*/
	    }
	    for(i=dataPtr->l - 1; i>=0; i--) {
	        for(j=dataPtr->n - 1; j>=0; j--) {
	            ll_feature_node_ClearData(dataPtr->x[i*dataPtr->l + j]);
	        }
	    }
	    /* No clear needed for bias */
	    Tcl_Free((char *) dataPtr /* dataPtr */)  ;
	}

	/* Get Tcl_Obj From Data */
	static Tcl_Obj* /* listPtr */ ll_problem_Tcl_Obj(struct problem *dataPtr /* dataPtr */) {
	    /* New Tcl Object From Data */
	    
	Tcl_Obj *listPtr = Tcl_NewListObj(0,NULL);
	Tcl_Obj *listPtr_L0;
	Tcl_Obj *listPtr_L1;
	int i;
	int j;
	int llength_i;
	int llength_j;


	 /* int l */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->l));

	 /* int n */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->n));

	 /* int* y */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->l; i++) {
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, Tcl_NewIntObj(dataPtr->y[i]));
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 /* struct feature_node** x */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->l; i++) {
		 listPtr_L1 = Tcl_NewListObj(0,NULL);
		 for(j=0;  (j < dataPtr->n) && ( dataPtr->x[i][j - 1 ].index != -1 ); j++) {
			 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L1, ll_feature_node_Tcl_Obj(&(dataPtr->x[i][j])));
		 }
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, listPtr_L1); 
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 /* double bias */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewDoubleObj(dataPtr->bias));

	 return listPtr; /* listPtr */
	}

	static int ll_problem_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr /* listPtr */, struct problem *dataPtr /* dataPtr */) {
	    /* Get Data From Tcl Obj */
	    
	Tcl_Obj *listPtr_Elem_L0;
	Tcl_Obj *listPtr_Elem_L1;
	Tcl_Obj *listPtr_Elem_L2;
	int i;
	int j;
	int listPtr_LLength;
	int llength_i;
	int llength_j;

 listPtr_LLength=0;
 if (Tcl_ListObjLength(interp, listPtr, &listPtr_LLength) != TCL_OK) { return TCL_ERROR; }
 if ( listPtr_LLength != 5 ) { return TCL_ERROR; }

	    /* int l */
	    Ns_Log(Notice,"getting int l");
	    Tcl_ListObjIndex(interp, listPtr, 0, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"l listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->l));

	    /* int n */
	    Ns_Log(Notice,"getting int n");
	    Tcl_ListObjIndex(interp, listPtr, 1, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"n listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->n));

	    /* int* y */
	    Ns_Log(Notice,"getting int* y");
	    Tcl_ListObjIndex(interp, listPtr, 2, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"y listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->y = (int*) Tcl_Alloc(dataPtr->l * sizeof(int));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->l; i++) {
 Ns_Log(Notice,"y i = %d dataPtr->l = %d",i,dataPtr->l);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 Tcl_GetIntFromObj(interp,listPtr_Elem_L1,&(dataPtr->y[i]));
	 }

	    /* struct feature_node** x */
	    Ns_Log(Notice,"getting struct feature_node** x");
	    Tcl_ListObjIndex(interp, listPtr, 3, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"x listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->x = (struct feature_node**) Tcl_Alloc(dataPtr->l * sizeof(struct feature_node*));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->l; i++) {
 Ns_Log(Notice,"x i = %d dataPtr->l = %d",i,dataPtr->l);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 dataPtr->x[i] = (struct feature_node*) Tcl_Alloc(dataPtr->n * sizeof(struct feature_node));
		 if (Tcl_ListObjLength(interp, listPtr_Elem_L1, &llength_j) != TCL_OK) { return TCL_ERROR; }
		 for(j=0; j < llength_j; j++) {
 Ns_Log(Notice,"x j = %d llength_j = %d",j,llength_j);
			 Tcl_ListObjIndex(interp, listPtr_Elem_L1, j, (Tcl_Obj **)&listPtr_Elem_L2);
 Ns_Log(Notice,"listPtr_Elem_L2=%s ", Tcl_GetString(listPtr_Elem_L2));
			 Ns_Log(Notice,"ll_feature_node inline=%s",Tcl_GetString(listPtr_Elem_L2));
			 ll_feature_node_GetDataFromObj(interp,listPtr_Elem_L2,&(dataPtr->x[i][j]));
		 } 
	 }

	    /* double bias */
	    Ns_Log(Notice,"getting double bias");
	    Tcl_ListObjIndex(interp, listPtr, 4, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"bias listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetDoubleFromObj(interp,listPtr_Elem_L0,&(dataPtr->bias));
	    return TCL_OK;
	}

	static Tcl_Obj *ll_problem_AllocObj(Tcl_Interp *interp) {

	    Tcl_Obj *objPtr = Tcl_NewObj();

	    /* TODO: Check why SetFromAnyProc is called whenever we invoke ll_problem_AllocObj 
 	     * Perhaps, we should just call SetFromAnyProc here and get over with it;
	     */

	    ll_problem_InternalType *internal = (ll_problem_InternalType *)Tcl_Alloc(sizeof(ll_problem_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = (struct problem *)ll_problem_AllocData();
	    internal->objPtr = objPtr;
	    internal->hashPtr = NULL;
	    internal->refCount = 0;

	    objPtr->bytes = NULL;
	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_problem_ObjType;

	    return objPtr;

	}

	static void ll_problem_FreeInternalRepProc(Tcl_Obj *objPtr)
	{
	    ll_problem_InternalType *internal = (ll_problem_InternalType *)objPtr->internalRep.otherValuePtr;
	    ll_problem_ClearData((struct problem *)internal->dataPtr);
	    Tcl_Free((char *)internal);
	    objPtr->typePtr = NULL;
	}

	static void ll_problem_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr)
	{
	    ll_problem_InternalType *internal = (ll_problem_InternalType *)srcPtr->internalRep.otherValuePtr;
	    dupPtr->internalRep.otherValuePtr = Tcl_Alloc(sizeof(ll_problem_InternalType));
	    ll_problem_InternalType *internal2 = (ll_problem_InternalType *)dupPtr->internalRep.otherValuePtr;
	    ll_problem_CopyData((struct problem *) internal2->dataPtr,(struct problem *)internal->dataPtr);
	    dupPtr->typePtr = &ll_problem_ObjType;
	}

	static void ll_problem_UpdateStringProc(Tcl_Obj *objPtr)
	{
	    char *str;
	    Tcl_Obj *listPtr;
	    ll_problem_InternalType *internal = (ll_problem_InternalType *) objPtr->internalRep.otherValuePtr;
	    listPtr = ll_problem_Tcl_Obj(internal->dataPtr);
	    str = Tcl_GetStringFromObj(listPtr, &objPtr->length);
	    objPtr->bytes = Tcl_Alloc(objPtr->length+1);
	    memcpy(objPtr->bytes, str, objPtr->length+1);
	    Tcl_IncrRefCount(listPtr);
	    Tcl_DecrRefCount(listPtr);
	}

	static int  ll_problem_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr)
	{

	    /* TODO: Make sure this works without causing any unwanted side-effects. */
	    /* TODO: this is not quite right - revisit
	     * if (objPtr->typePtr == &ll_problem_ObjType) {
	     *	 return TCL_OK;
	     * }
	     */

	    Tcl_Obj *listPtr = Tcl_DuplicateObj(objPtr);
	    int count;
	    int i;


	    Tcl_IncrRefCount(listPtr);
	    if (Tcl_ListObjLength(interp, listPtr, &count) != TCL_OK)
	    {
		Tcl_DecrRefCount(listPtr);
		return TCL_ERROR;
	    }


	    if (objPtr->typePtr && objPtr->typePtr->freeIntRepProc) 
	    {
		objPtr->typePtr->freeIntRepProc(objPtr);
	    }

	    ll_problem_InternalType *internal;
	    internal = (ll_problem_InternalType *)Tcl_Alloc(sizeof(ll_problem_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = ll_problem_AllocData();

	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_problem_ObjType;
	    return ll_problem_GetDataFromObj(interp,listPtr,internal->dataPtr);

	}


	/***********************************************************************/

	static int ll_problem_RegisterShared (const char *key, Tcl_Obj *objPtr)
	{
	    Tcl_HashEntry *entryPtr;
	    int refCount, newEntry;

	    Tcl_MutexLock(&ll_problem_HashTableMutex);
	    refCount = ++objPtr->refCount;
	    entryPtr = Tcl_CreateHashEntry(&ll_problem_HashTable, (char*)key /* internal */, &newEntry);
	    if (newEntry) {
		Tcl_SetHashValue(entryPtr, (ClientData)objPtr);
		//internal->hashPtr = entryPtr;
	    }
	    Tcl_MutexUnlock(&ll_problem_HashTableMutex);

	    /*
	    * DBG(fprintf(stderr, "--> ll_problem_RegisterShared: ll_problem data %p %s "
	     *		"shared table now with refcount of %d\n", objPtr,
	     *		newEntry ? "entered into" : "already in", refCount));
	     */
	    return 0;
	}


	/* see tDOM's tcldom_returnDocumentObj for more details */

	int ll_problem_ReturnHandle (Tcl_Interp  *interp, Tcl_Obj *objPtr, int setVariable, Tcl_Obj *varNameObj)
	{
	    char        objCmdName[80], *varName;
	    Tcl_CmdInfo cmdInfo;
	    //ll_problem_InternalType *internal = (ll_problem_InternalType *) objPtr->internalRep.otherValuePtr;

	    if (objPtr /* internal->dataPtr */ == NULL) {
		if (setVariable) {
		    varName = Tcl_GetString(varNameObj);
		    Tcl_UnsetVar(interp, varName, 0);
		    Tcl_SetVar  (interp, varName, "", 0);
		}
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp), (""), -1);
		return TCL_OK;
	    }

	    sprintf((objCmdName), "__ll_problem__%p", (objPtr));

	    if (setVariable) {
		varName = Tcl_GetString(varNameObj);
		Tcl_SetVar(interp, varName, objCmdName, 0);
	    }

	    // HERE - FIX: 
	    ll_problem_RegisterShared(objCmdName,objPtr);



	    /* Set Result */
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), (objCmdName), -1);
	    return TCL_OK;
	}

	/***********************************************************************/

	static
	int ll_problem_CreateCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{
	    int         setVariable = 0;
	    Tcl_Obj     *objPtr;
	    Tcl_Obj     *newObjName = NULL;


	    //CheckArgs(2,3,1,"?newObjVar?");

	    if (objc == 2) {
		newObjName = objv[1];
		setVariable = 1;
	    }

	    objPtr = ll_problem_AllocObj(interp);
	    if (objPtr == NULL) {
		return TCL_ERROR;
	    }

	    return ll_problem_ReturnHandle(interp, objPtr, setVariable, newObjName);
	}

	static Tcl_Obj *ll_problem_GetObjFromHandle(Tcl_Interp *interp, Tcl_HashTable *ht, Tcl_Obj *objVar)
	{

	    Tcl_Obj *handle = Tcl_ObjGetVar2(interp, objVar, NULL, TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1);
	    Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(ht,(char *)Tcl_GetString(handle));
	    if (entryPtr == NULL) {
		//Tcl_AddErrorInfo(interp,"no such handle");
		return NULL;
	    }
	    return /* Tcl_Obj *objPtr = */ (Tcl_Obj *) Tcl_GetHashValue(entryPtr);

	}

	static
	int ll_problem_SetCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{


	    //CheckArgs(2,3,1,"docElemName ?newObjVar?");

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "varName list");
		return TCL_ERROR;
	    }

	    Tcl_Obj *objPtr = (Tcl_Obj *) ll_problem_GetObjFromHandle(interp, &ll_problem_HashTable,objv[1]);
	    if (objPtr==NULL) {
		Tcl_AddErrorInfo(interp,"no such handle");
		return TCL_ERROR;
	    }

	    ll_problem_InternalType *internal = (ll_problem_InternalType *) objPtr->internalRep.otherValuePtr;

	    if ( objPtr == NULL ) {
		Tcl_AddErrorInfo(interp,"no such object found (objPtr is NULL)");
		return TCL_ERROR;
	    }

	    ll_problem_GetDataFromObj(interp,objv[2],internal->dataPtr);
	    Tcl_SetObjResult(interp,objPtr);
	    return TCL_OK;

	}

	/*----------------------------------------------------------------------------
	|   Exit Handler: ll_problem_ExitHandler
	|
	|   Activated in application exit handler to delete shared document table
	|   Table entries are deleted by the object command deletion callbacks,
	|   so at this time, table should be empty. If not, we will leave some
	|   memory leaks. This is not fatal, though: we're exiting the app anyway.
	|   This is a private function to this file. 
	\---------------------------------------------------------------------------*/

	static void ll_problem_ExitHandler(ClientData unused)
	{
	    Tcl_MutexLock(&ll_problem_HashTableMutex);
	    Tcl_DeleteHashTable(&ll_problem_HashTable);
	    Tcl_MutexUnlock(&ll_problem_HashTableMutex);
	}

	/*----------------------------------------------------------------------------
	|   Initialize Module
	|   Activated at module load to initialize shared object handles table.
	|   This is exported since we need it in HERE: tdominit.c.
	\---------------------------------------------------------------------------*/


	void ll_problem_InitModule()
	{
	    Tcl_MutexLock(&ll_problem_HashTableMutex);
	    if (!ll_problem_ModuleInitialized) {
		//Tcl_InitHashTable(&ll_problem_HashTable, TCL_ONE_WORD_KEYS);
		Tcl_InitHashTable(&ll_problem_HashTable, TCL_STRING_KEYS);
		Tcl_CreateExitHandler(ll_problem_ExitHandler, NULL);
		ll_problem_ModuleInitialized = 1;
	    }
	    Tcl_MutexUnlock(&ll_problem_HashTableMutex);
	}


    

/* ---------------------------------------------------------------------- */

#line 1 "module-liblinear.tcl"

	#define __MIN__(x,y) ((x)<(y)?(x):(y))

	/* Data Manipulation Commands */
	static struct model* ll_model_AllocData();
	static void         ll_model_CopyData_Area(struct model *copyPtr, struct model *dataPtr, int n);
	static void         ll_model_CopyData(struct model *copyPtr, struct model *dataPtr);
	static void         ll_model_InitData(struct model *dataPtr);
	static void         ll_model_ClearData(struct model *dataPtr);
	static Tcl_Obj*     ll_model_Tcl_Obj(struct model *dataPtr);
	static int          ll_model_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr, struct model *dataPtr);
	static Tcl_Obj*     ll_model_AllocObj(Tcl_Interp *interp);

	/* Manage Tcl Object Types */
	static void ll_model_FreeInternalRepProc(Tcl_Obj *objPtr);
	static void ll_model_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr);
	static void ll_model_UpdateStringProc(Tcl_Obj *objPtr);
	static int  ll_model_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr);

	/* Create our Tcl hash table to store our handle look-ups.
	 * We keep track of all of our handles in a hash table so that
	 * we can always go back to something and look up our data should
	 * we lose the pointer to our struct.
	 */

	static Tcl_HashTable ll_model_HashTable;   /* TODO: Replace with critbit tree.  */
	static Tcl_Mutex     ll_model_HashTableMutex;
	static int           ll_model_ModuleInitialized;

	/* Now, we want to define a struct that will hold our data.  The first
	 * three fields are Tcl-related and make it really easy for us to circle
	 * back and find our related pieces.
	 */

	typedef struct ll_model_InternalStruct {
	    Tcl_Interp    *interp;  /* The Tcl interpreter where we were created.  */
	    Tcl_Obj       *objPtr;  /*   The object that contains our string rep.  */
	    Tcl_HashEntry *hashPtr; /* The pointer to our entry in the hash table. */
	    struct model   *dataPtr; /* Our native data.                            */

	    int epoch;
	    int refCount;

	} ll_model_InternalType;

	static char ll_model_name[] = "ll_model";

	static Tcl_ObjType ll_model_ObjType = {
	    ll_model_name,                          /* name */
	    ll_model_FreeInternalRepProc,                  /* freeIntRepProc */
	    ll_model_DupInternalRepProc,                   /* dupIntRepProc */
	    ll_model_UpdateStringProc,                     /* updateStringProc */
	    ll_model_SetFromAnyProc                        /* setFromAnyProc */
	};


	static void ll_model_InitData(struct model *dataPtr) {
	    /* Init Data Code */
	    memset(dataPtr,0,sizeof(struct model));
	}

	static struct model *ll_model_AllocData() {
	    struct model *dataPtr /* dataPtr */ = (struct model *)Tcl_Alloc(sizeof(struct model));
	    ll_model_InitData(dataPtr);
	    return  dataPtr /* dataPtr */  ;
	}

	static void ll_model_CopyData_Area(struct model *copyPtr /* copyPtr */, struct model *dataPtr /* dataPtr */, int  n /* n */ ) {
	    
	    int i;
	    for(i=0; i<n; i++) {
		ll_model_CopyData(&(copyPtr[i]), &(dataPtr[i]));
	    }
	
	}

	static void ll_model_CopyData(struct model *copyPtr /* copyPtr */, struct model *dataPtr /* dataPtr */ ) {

	    /* Copy Data Code */
	    
	
	 ll_parameter_CopyData_Area(&(copyPtr->param),&(dataPtr->param),1);
	 copyPtr->nr_class=dataPtr->nr_class;
	 copyPtr->nr_feature=dataPtr->nr_feature;
	 copyPtr->w = (double*) Tcl_Alloc(dataPtr->nr_feature * dataPtr->nr_class * sizeof(double));
	 memcpy(copyPtr->w, dataPtr->w, dataPtr->nr_feature * dataPtr->nr_class * sizeof(double));
	 copyPtr->label = (int*) Tcl_Alloc(dataPtr->nr_class * sizeof(int));
	 memcpy(copyPtr->label, dataPtr->label, dataPtr->nr_class * sizeof(int));
	 copyPtr->bias=dataPtr->bias;

	    // Ns_Log(Notice,"data dataPtr=%s",Tcl_GetString(ll_model_Tcl_Obj(copyPtr)));
	    // Ns_Log(Notice,"target copyPtr=%s",Tcl_GetString(ll_model_Tcl_Obj(dataPtr)));
	}

	static void ll_model_ClearData(struct model *dataPtr /* dataPtr */) {
	    /* Clear Data Code */
	    
	    int j;
	    int i;

	    ll_parameter_ClearData(&dataPtr->param);;
	    /* No clear needed for nr_class */
	    /* No clear needed for nr_feature */
	    for(i=dataPtr->nr_feature - 1; i>=0; i--) {
	        for(j=dataPtr->nr_class - 1; j>=0; j--) {
	            Tcl_Free((char *) &dataPtr->w[i*dataPtr->nr_feature + j]); /* HERE - HERE - HERE - HERE - HERE - HERE: clear_from_defs proc*/
	        }
	    }
	    for(i=dataPtr->nr_class - 1; i>=0; i--) {
	        Tcl_Free((char *) &dataPtr->label[i]); /* HERE - HERE - HERE - HERE - HERE - HERE: clear_from_defs proc*/
	    }
	    /* No clear needed for bias */
	    Tcl_Free((char *) dataPtr /* dataPtr */)  ;
	}

	/* Get Tcl_Obj From Data */
	static Tcl_Obj* /* listPtr */ ll_model_Tcl_Obj(struct model *dataPtr /* dataPtr */) {
	    /* New Tcl Object From Data */
	    
	Tcl_Obj *listPtr = Tcl_NewListObj(0,NULL);
	Tcl_Obj *listPtr_L0;
	Tcl_Obj *listPtr_L1;
	int i;
	int j;
	int llength_i;
	int llength_j;


	 /* struct parameter param */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, ll_parameter_Tcl_Obj(&(dataPtr->param)));

	 /* int nr_class */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->nr_class));

	 /* int nr_feature */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewIntObj(dataPtr->nr_feature));

	 /* double* w */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->nr_feature; i++) {
		 listPtr_L1 = Tcl_NewListObj(0,NULL);
		 for(j=0; j < dataPtr->nr_class; j++) {
			 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L1, Tcl_NewDoubleObj(dataPtr->w[(i * (dataPtr->nr_class)) + j]));
		 }
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, listPtr_L1); 
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 /* int* label */
	 listPtr_L0 = Tcl_NewListObj(0,NULL);
	 for(i=0; i < dataPtr->nr_class; i++) {
		 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr_L0, Tcl_NewIntObj(dataPtr->label[i]));
	 }
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, listPtr_L0);

	 /* double bias */
	 Tcl_ListObjAppendElement(NULL, (Tcl_Obj *) listPtr, Tcl_NewDoubleObj(dataPtr->bias));

	 return listPtr; /* listPtr */
	}

	static int ll_model_GetDataFromObj(Tcl_Interp *interp, Tcl_Obj *listPtr /* listPtr */, struct model *dataPtr /* dataPtr */) {
	    /* Get Data From Tcl Obj */
	    
	Tcl_Obj *listPtr_Elem_L0;
	Tcl_Obj *listPtr_Elem_L1;
	Tcl_Obj *listPtr_Elem_L2;
	Tcl_Obj *tmpObjPtr;
	int i;
	int j;
	int listPtr_LLength;
	int llength_i;
	int llength_j;

 listPtr_LLength=0;
 if (Tcl_ListObjLength(interp, listPtr, &listPtr_LLength) != TCL_OK) { return TCL_ERROR; }
 if ( listPtr_LLength != 6 ) { return TCL_ERROR; }

	    /* struct parameter param */
	    Ns_Log(Notice,"getting struct parameter param");
	    Tcl_ListObjIndex(interp, listPtr, 0, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"param listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 tmpObjPtr = ll_parameter_GetObjFromHandle(interp,&ll_parameter_HashTable,listPtr_Elem_L0);
	 ll_parameter_InternalType *internal = (ll_parameter_InternalType *) tmpObjPtr->internalRep.otherValuePtr;
	 ll_parameter_CopyData(&(dataPtr->param),internal->dataPtr);

	    /* int nr_class */
	    Ns_Log(Notice,"getting int nr_class");
	    Tcl_ListObjIndex(interp, listPtr, 1, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"nr_class listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->nr_class));

	    /* int nr_feature */
	    Ns_Log(Notice,"getting int nr_feature");
	    Tcl_ListObjIndex(interp, listPtr, 2, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"nr_feature listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetIntFromObj(interp,listPtr_Elem_L0,&(dataPtr->nr_feature));

	    /* double* w */
	    Ns_Log(Notice,"getting double* w");
	    Tcl_ListObjIndex(interp, listPtr, 3, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"w listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->w = (double*) Tcl_Alloc(dataPtr->nr_feature * dataPtr->nr_class * sizeof(double));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->nr_feature; i++) {
 Ns_Log(Notice,"w i = %d dataPtr->nr_feature = %d",i,dataPtr->nr_feature);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 if (Tcl_ListObjLength(interp, listPtr_Elem_L1, &llength_j) != TCL_OK) { return TCL_ERROR; }
		 for(j=0; j < dataPtr->nr_class; j++) {
 Ns_Log(Notice,"w j = %d dataPtr->nr_class = %d",j,dataPtr->nr_class);
			 Tcl_ListObjIndex(interp, listPtr_Elem_L1, j, (Tcl_Obj **)&listPtr_Elem_L2);
 Ns_Log(Notice,"listPtr_Elem_L2=%s ", Tcl_GetString(listPtr_Elem_L2));
			 Tcl_GetDoubleFromObj(interp,listPtr_Elem_L2,&(dataPtr->w[(i * (dataPtr->nr_class)) + j]));
		 } 
	 }

	    /* int* label */
	    Ns_Log(Notice,"getting int* label");
	    Tcl_ListObjIndex(interp, listPtr, 4, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"label listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	 dataPtr->label = (int*) Tcl_Alloc(dataPtr->nr_class * sizeof(int));
	 if (Tcl_ListObjLength(interp, listPtr_Elem_L0, &llength_i) != TCL_OK) { return TCL_ERROR; }
	 for(i=0; i < dataPtr->nr_class; i++) {
 Ns_Log(Notice,"label i = %d dataPtr->nr_class = %d",i,dataPtr->nr_class);
		 Tcl_ListObjIndex(interp, listPtr_Elem_L0, i, (Tcl_Obj **)&listPtr_Elem_L1);
 Ns_Log(Notice,"listPtr_Elem_L1=%s ", Tcl_GetString(listPtr_Elem_L1));
		 Tcl_GetIntFromObj(interp,listPtr_Elem_L1,&(dataPtr->label[i]));
	 }

	    /* double bias */
	    Ns_Log(Notice,"getting double bias");
	    Tcl_ListObjIndex(interp, listPtr, 5, (Tcl_Obj **)&listPtr_Elem_L0);
	    Ns_Log(Notice,"bias listPtr_Elem_L0 = %s", Tcl_GetString(listPtr_Elem_L0));
	    Tcl_GetDoubleFromObj(interp,listPtr_Elem_L0,&(dataPtr->bias));
	    return TCL_OK;
	}

	static Tcl_Obj *ll_model_AllocObj(Tcl_Interp *interp) {

	    Tcl_Obj *objPtr = Tcl_NewObj();

	    /* TODO: Check why SetFromAnyProc is called whenever we invoke ll_model_AllocObj 
 	     * Perhaps, we should just call SetFromAnyProc here and get over with it;
	     */

	    ll_model_InternalType *internal = (ll_model_InternalType *)Tcl_Alloc(sizeof(ll_model_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = (struct model *)ll_model_AllocData();
	    internal->objPtr = objPtr;
	    internal->hashPtr = NULL;
	    internal->refCount = 0;

	    objPtr->bytes = NULL;
	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_model_ObjType;

	    return objPtr;

	}

	static void ll_model_FreeInternalRepProc(Tcl_Obj *objPtr)
	{
	    ll_model_InternalType *internal = (ll_model_InternalType *)objPtr->internalRep.otherValuePtr;
	    ll_model_ClearData((struct model *)internal->dataPtr);
	    Tcl_Free((char *)internal);
	    objPtr->typePtr = NULL;
	}

	static void ll_model_DupInternalRepProc(Tcl_Obj *srcPtr, Tcl_Obj *dupPtr)
	{
	    ll_model_InternalType *internal = (ll_model_InternalType *)srcPtr->internalRep.otherValuePtr;
	    dupPtr->internalRep.otherValuePtr = Tcl_Alloc(sizeof(ll_model_InternalType));
	    ll_model_InternalType *internal2 = (ll_model_InternalType *)dupPtr->internalRep.otherValuePtr;
	    ll_model_CopyData((struct model *) internal2->dataPtr,(struct model *)internal->dataPtr);
	    dupPtr->typePtr = &ll_model_ObjType;
	}

	static void ll_model_UpdateStringProc(Tcl_Obj *objPtr)
	{
	    char *str;
	    Tcl_Obj *listPtr;
	    ll_model_InternalType *internal = (ll_model_InternalType *) objPtr->internalRep.otherValuePtr;
	    listPtr = ll_model_Tcl_Obj(internal->dataPtr);
	    str = Tcl_GetStringFromObj(listPtr, &objPtr->length);
	    objPtr->bytes = Tcl_Alloc(objPtr->length+1);
	    memcpy(objPtr->bytes, str, objPtr->length+1);
	    Tcl_IncrRefCount(listPtr);
	    Tcl_DecrRefCount(listPtr);
	}

	static int  ll_model_SetFromAnyProc(Tcl_Interp *interp, Tcl_Obj *objPtr)
	{

	    /* TODO: Make sure this works without causing any unwanted side-effects. */
	    /* TODO: this is not quite right - revisit
	     * if (objPtr->typePtr == &ll_model_ObjType) {
	     *	 return TCL_OK;
	     * }
	     */

	    Tcl_Obj *listPtr = Tcl_DuplicateObj(objPtr);
	    int count;
	    int i;


	    Tcl_IncrRefCount(listPtr);
	    if (Tcl_ListObjLength(interp, listPtr, &count) != TCL_OK)
	    {
		Tcl_DecrRefCount(listPtr);
		return TCL_ERROR;
	    }


	    if (objPtr->typePtr && objPtr->typePtr->freeIntRepProc) 
	    {
		objPtr->typePtr->freeIntRepProc(objPtr);
	    }

	    ll_model_InternalType *internal;
	    internal = (ll_model_InternalType *)Tcl_Alloc(sizeof(ll_model_InternalType));
	    internal->interp = interp;
	    internal->dataPtr = ll_model_AllocData();

	    objPtr->internalRep.otherValuePtr = internal;
	    objPtr->typePtr = &ll_model_ObjType;
	    return ll_model_GetDataFromObj(interp,listPtr,internal->dataPtr);

	}


	/***********************************************************************/

	static int ll_model_RegisterShared (const char *key, Tcl_Obj *objPtr)
	{
	    Tcl_HashEntry *entryPtr;
	    int refCount, newEntry;

	    Tcl_MutexLock(&ll_model_HashTableMutex);
	    refCount = ++objPtr->refCount;
	    entryPtr = Tcl_CreateHashEntry(&ll_model_HashTable, (char*)key /* internal */, &newEntry);
	    if (newEntry) {
		Tcl_SetHashValue(entryPtr, (ClientData)objPtr);
		//internal->hashPtr = entryPtr;
	    }
	    Tcl_MutexUnlock(&ll_model_HashTableMutex);

	    /*
	    * DBG(fprintf(stderr, "--> ll_model_RegisterShared: ll_model data %p %s "
	     *		"shared table now with refcount of %d\n", objPtr,
	     *		newEntry ? "entered into" : "already in", refCount));
	     */
	    return 0;
	}


	/* see tDOM's tcldom_returnDocumentObj for more details */

	int ll_model_ReturnHandle (Tcl_Interp  *interp, Tcl_Obj *objPtr, int setVariable, Tcl_Obj *varNameObj)
	{
	    char        objCmdName[80], *varName;
	    Tcl_CmdInfo cmdInfo;
	    //ll_model_InternalType *internal = (ll_model_InternalType *) objPtr->internalRep.otherValuePtr;

	    if (objPtr /* internal->dataPtr */ == NULL) {
		if (setVariable) {
		    varName = Tcl_GetString(varNameObj);
		    Tcl_UnsetVar(interp, varName, 0);
		    Tcl_SetVar  (interp, varName, "", 0);
		}
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp), (""), -1);
		return TCL_OK;
	    }

	    sprintf((objCmdName), "__ll_model__%p", (objPtr));

	    if (setVariable) {
		varName = Tcl_GetString(varNameObj);
		Tcl_SetVar(interp, varName, objCmdName, 0);
	    }

	    // HERE - FIX: 
	    ll_model_RegisterShared(objCmdName,objPtr);



	    /* Set Result */
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), (objCmdName), -1);
	    return TCL_OK;
	}

	/***********************************************************************/

	static
	int ll_model_CreateCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{
	    int         setVariable = 0;
	    Tcl_Obj     *objPtr;
	    Tcl_Obj     *newObjName = NULL;


	    //CheckArgs(2,3,1,"?newObjVar?");

	    if (objc == 2) {
		newObjName = objv[1];
		setVariable = 1;
	    }

	    objPtr = ll_model_AllocObj(interp);
	    if (objPtr == NULL) {
		return TCL_ERROR;
	    }

	    return ll_model_ReturnHandle(interp, objPtr, setVariable, newObjName);
	}

	static Tcl_Obj *ll_model_GetObjFromHandle(Tcl_Interp *interp, Tcl_HashTable *ht, Tcl_Obj *objVar)
	{

	    Tcl_Obj *handle = Tcl_ObjGetVar2(interp, objVar, NULL, TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1);
	    Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(ht,(char *)Tcl_GetString(handle));
	    if (entryPtr == NULL) {
		//Tcl_AddErrorInfo(interp,"no such handle");
		return NULL;
	    }
	    return /* Tcl_Obj *objPtr = */ (Tcl_Obj *) Tcl_GetHashValue(entryPtr);

	}

	static
	int ll_model_SetCmd (ClientData  clientData, Tcl_Interp *interp, int objc, Tcl_Obj * const objv[] )
	{


	    //CheckArgs(2,3,1,"docElemName ?newObjVar?");

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "varName list");
		return TCL_ERROR;
	    }

	    Tcl_Obj *objPtr = (Tcl_Obj *) ll_model_GetObjFromHandle(interp, &ll_model_HashTable,objv[1]);
	    if (objPtr==NULL) {
		Tcl_AddErrorInfo(interp,"no such handle");
		return TCL_ERROR;
	    }

	    ll_model_InternalType *internal = (ll_model_InternalType *) objPtr->internalRep.otherValuePtr;

	    if ( objPtr == NULL ) {
		Tcl_AddErrorInfo(interp,"no such object found (objPtr is NULL)");
		return TCL_ERROR;
	    }

	    ll_model_GetDataFromObj(interp,objv[2],internal->dataPtr);
	    Tcl_SetObjResult(interp,objPtr);
	    return TCL_OK;

	}

	/*----------------------------------------------------------------------------
	|   Exit Handler: ll_model_ExitHandler
	|
	|   Activated in application exit handler to delete shared document table
	|   Table entries are deleted by the object command deletion callbacks,
	|   so at this time, table should be empty. If not, we will leave some
	|   memory leaks. This is not fatal, though: we're exiting the app anyway.
	|   This is a private function to this file. 
	\---------------------------------------------------------------------------*/

	static void ll_model_ExitHandler(ClientData unused)
	{
	    Tcl_MutexLock(&ll_model_HashTableMutex);
	    Tcl_DeleteHashTable(&ll_model_HashTable);
	    Tcl_MutexUnlock(&ll_model_HashTableMutex);
	}

	/*----------------------------------------------------------------------------
	|   Initialize Module
	|   Activated at module load to initialize shared object handles table.
	|   This is exported since we need it in HERE: tdominit.c.
	\---------------------------------------------------------------------------*/


	void ll_model_InitModule()
	{
	    Tcl_MutexLock(&ll_model_HashTableMutex);
	    if (!ll_model_ModuleInitialized) {
		//Tcl_InitHashTable(&ll_model_HashTable, TCL_ONE_WORD_KEYS);
		Tcl_InitHashTable(&ll_model_HashTable, TCL_STRING_KEYS);
		Tcl_CreateExitHandler(ll_model_ExitHandler, NULL);
		ll_model_ModuleInitialized = 1;
	    }
	    Tcl_MutexUnlock(&ll_model_HashTableMutex);
	}


    

/* ---------------------------------------------------------------------- */

#define ns_ll_train "ll_train"
#line 1 "module-liblinear.tcl/ll_train"
static int
c_ll_train(Tcl_Interp* interp, Tcl_Obj* objPtr1, Tcl_Obj* objPtr2)
{

    Tcl_Obj* problemObj = ll_problem_GetObjFromHandle(interp,&ll_problem_HashTable,objPtr1);
    Tcl_Obj* paramObj = ll_parameter_GetObjFromHandle(interp,&ll_parameter_HashTable,objPtr2);

    ll_problem_InternalType *internal1 = (ll_problem_InternalType *) problemObj->internalRep.otherValuePtr;
    struct problem* problem = (struct problem *) internal1->dataPtr;

    ll_parameter_InternalType *internal2 = (ll_parameter_InternalType *) paramObj->internalRep.otherValuePtr;
    struct parameter* param = (struct parameter *) internal2->dataPtr;

    struct model *model = train(problem,param);
    Tcl_Obj* modelObj = ll_model_Tcl_Obj(model);

    Tcl_SetObjResult(interp,modelObj);
    return TCL_OK;
}

static int
tcl_ll_train(ClientData cd, Tcl_Interp *ip, int oc, Tcl_Obj *CONST ov[])
{
  Tcl_Obj* _objPtr1;
  Tcl_Obj* _objPtr2;
  int rv;
  if (oc != 3) {
    Tcl_WrongNumArgs(ip, 1, ov, "objPtr1 objPtr2");
    return TCL_ERROR;
  }

  _objPtr1 = ov[1];
  _objPtr2 = ov[2];

  rv = c_ll_train(ip, _objPtr1, _objPtr2);

  return rv;
}

/* ---------------------------------------------------------------------- */

#define ns_ll_predict "ll_predict"
#line 1 "module-liblinear.tcl/ll_predict"
static int
c_ll_predict(Tcl_Interp* interp, Tcl_Obj* objPtr, Tcl_Obj* listPtr)
{
    Tcl_Obj* modelObj = ll_model_GetObjFromHandle(interp,&ll_model_HashTable,objPtr);

    ll_model_InternalType *internal = (ll_model_InternalType *) modelObj->internalRep.otherValuePtr;
    struct model *model = (struct model *) internal->dataPtr;

    // predict

    int nr_class=get_nr_class(model);
    double *prob_estimates=NULL;
    int j, n;
    int nr_feature=get_nr_feature(model);


    fprintf(stderr,"nr_class=%d nr_feature=%d\n",nr_class, nr_feature);

    if(model->bias>=0) {
	n=nr_feature+1;
    } else {
	n=nr_feature;
    }


    // TODO: flag_predict_probability

    int i=0;
    int listLength=0;
    Tcl_ListObjLength(interp,listPtr,&listLength);
    int inst_max_index = 0;
    struct feature_node *x = (struct feature_node *) Tcl_Alloc((listLength+2)*sizeof(struct feature_node));
    for(i=0; i<listLength; ++i) {
				 Tcl_Obj *elemListPtr;
				 Tcl_Obj *indexPtr;
				 Tcl_Obj *valuePtr;

			       Tcl_ListObjIndex(interp,listPtr,i,&elemListPtr);
			       Tcl_ListObjIndex(interp,elemListPtr,i,&indexPtr);
			       Tcl_ListObjIndex(interp,elemListPtr,i,&valuePtr);

			       Tcl_GetIntFromObj(interp,indexPtr,&(x[i].index));
			       Tcl_GetDoubleFromObj(interp,valuePtr,&(x[i].value));

	if (x[i].index <= inst_max_index) {
	    // Tcl_AppendError
	    return TCL_ERROR;
	} else {
	    inst_max_index = x[i].index;
	}

	// feature indices larger than those in training are not used
	if(x[i].index <= nr_feature)
	++i;

    }
    
    if(model->bias>=0)
    {
	x[i].index = n;
	x[i].value = model->bias;
	i++;
    }
    x[i].index = -1;


    int predict_label = predict(model,x);

    Tcl_Free((char *) x);

    return predict_label;
}

static int
tcl_ll_predict(ClientData cd, Tcl_Interp *ip, int oc, Tcl_Obj *CONST ov[])
{
  Tcl_Obj* _objPtr;
  Tcl_Obj* _listPtr;
  int rv;
  if (oc != 3) {
    Tcl_WrongNumArgs(ip, 1, ov, "objPtr listPtr");
    return TCL_ERROR;
  }

  _objPtr = ov[1];
  _listPtr = ov[2];

  rv = c_ll_predict(ip, _objPtr, _listPtr);

  Tcl_SetObjResult(ip, Tcl_NewIntObj(rv));
  return TCL_OK;
}

/* ---------------------------------------------------------------------- */

#define ns_ll_save_model "ll_save_model"
#line 1 "module-liblinear.tcl/ll_save_model"
static int
c_ll_save_model(Tcl_Interp* interp, Tcl_Obj* filenameObj, Tcl_Obj* objPtr)
{
    Tcl_Obj* modelObj = ll_model_GetObjFromHandle(interp,&ll_model_HashTable,objPtr);

    ll_model_InternalType *internal = (ll_model_InternalType *) modelObj->internalRep.otherValuePtr;
    struct model *model = (struct model *) internal->dataPtr;
	
    const char *model_file_name = Tcl_GetString(filenameObj);
    save_model(model_file_name,model);

    Tcl_SetObjResult(interp,modelObj);
    return TCL_OK;
}

static int
tcl_ll_save_model(ClientData cd, Tcl_Interp *ip, int oc, Tcl_Obj *CONST ov[])
{
  Tcl_Obj* _filenameObj;
  Tcl_Obj* _objPtr;
  int rv;
  if (oc != 3) {
    Tcl_WrongNumArgs(ip, 1, ov, "filenameObj objPtr");
    return TCL_ERROR;
  }

  _filenameObj = ov[1];
  _objPtr = ov[2];

  rv = c_ll_save_model(ip, _filenameObj, _objPtr);

  return rv;
}

/* ---------------------------------------------------------------------- */

#define ns_ll_load_model "ll_load_model"
#line 1 "module-liblinear.tcl/ll_load_model"
static int
c_ll_load_model(Tcl_Interp* interp, Tcl_Obj* newObjName, Tcl_Obj* filenameObj)
{

    const char *model_file_name = Tcl_GetString(filenameObj);
    struct model *model = (struct model *) load_model(model_file_name);

    Tcl_Obj* modelObj = ll_model_Tcl_Obj(model);

    ll_model_InternalType *internal = (ll_model_InternalType *) modelObj->internalRep.otherValuePtr;
    struct model *model2 = (struct model *) internal->dataPtr;
    fprintf(stderr,"nr_class=%d nr_feature=%d\n",get_nr_class(model2), get_nr_feature(model2));


    if (modelObj == NULL) {
	return TCL_ERROR;
    }
    int setVariable = 1;
    return ll_model_ReturnHandle(interp, modelObj, setVariable, newObjName);
}

static int
tcl_ll_load_model(ClientData cd, Tcl_Interp *ip, int oc, Tcl_Obj *CONST ov[])
{
  Tcl_Obj* _newObjName;
  Tcl_Obj* _filenameObj;
  int rv;
  if (oc != 3) {
    Tcl_WrongNumArgs(ip, 1, ov, "newObjName filenameObj");
    return TCL_ERROR;
  }

  _newObjName = ov[1];
  _filenameObj = ov[2];

  rv = c_ll_load_model(ip, _newObjName, _filenameObj);

  return rv;
}

/* ---------------------------------------------------------------------- */

# line 1 "MyInitTclStubs"

#if USE_TCL_STUBS
  TclStubs *tclStubsPtr;
  TclPlatStubs *tclPlatStubsPtr;
  struct TclIntStubs *tclIntStubsPtr;
  struct TclIntPlatStubs *tclIntPlatStubsPtr;

  static int
  MyInitTclStubs (Tcl_Interp *ip)
  {
    typedef struct {
      char *result;
      Tcl_FreeProc *freeProc;
      int errorLine;
      TclStubs *stubTable;
    } HeadOfInterp;

    HeadOfInterp *hoi = (HeadOfInterp*) ip;

    if (hoi->stubTable == NULL || hoi->stubTable->magic != TCL_STUB_MAGIC) {
      Tcl_SetResult(ip, "This extension requires Tk stubs-support.", TCL_STATIC);
	//ip->result = "This extension requires stubs-support.";
      //ip->freeProc = TCL_STATIC;
      return 0;
    }

    tclStubsPtr = hoi->stubTable;

    if (Tcl_PkgRequire(ip, "Tcl", "8.1", 0) == NULL) {
      tclStubsPtr = NULL;
      return 0;
    }

    if (tclStubsPtr->hooks != NULL) {
	tclPlatStubsPtr = tclStubsPtr->hooks->tclPlatStubs;
	tclIntStubsPtr = tclStubsPtr->hooks->tclIntStubs;
	tclIntPlatStubsPtr = tclStubsPtr->hooks->tclIntPlatStubs;
    }

    return 1;
  }
#endif

#ifdef __cplusplus
extern "C" {
#endif
      




DLLEXPORT int
Module_Init(Tcl_Interp *ip)
{
#if USE_TCL_STUBS
  if (!MyInitTclStubs(ip)) return TCL_ERROR;
#endif

	ll_parameter_InitModule();
	Tcl_CreateObjCommand(ip, "::ll_parameter::create", ll_parameter_CreateCmd, NULL, NULL);
	Tcl_CreateObjCommand(ip, "::ll_parameter::set", ll_parameter_SetCmd, NULL, NULL);
	//Tcl_CreateObjCommand(ip, "::ll_parameter::info", ll_parameter_InfoCmd, NULL, NULL);
	Tcl_RegisterObjType(&ll_parameter_ObjType); 
    

	ll_feature_node_InitModule();
	Tcl_CreateObjCommand(ip, "::ll_feature_node::create", ll_feature_node_CreateCmd, NULL, NULL);
	Tcl_CreateObjCommand(ip, "::ll_feature_node::set", ll_feature_node_SetCmd, NULL, NULL);
	//Tcl_CreateObjCommand(ip, "::ll_feature_node::info", ll_feature_node_InfoCmd, NULL, NULL);
	Tcl_RegisterObjType(&ll_feature_node_ObjType); 
    

	ll_problem_InitModule();
	Tcl_CreateObjCommand(ip, "::ll_problem::create", ll_problem_CreateCmd, NULL, NULL);
	Tcl_CreateObjCommand(ip, "::ll_problem::set", ll_problem_SetCmd, NULL, NULL);
	//Tcl_CreateObjCommand(ip, "::ll_problem::info", ll_problem_InfoCmd, NULL, NULL);
	Tcl_RegisterObjType(&ll_problem_ObjType); 
    

	ll_model_InitModule();
	Tcl_CreateObjCommand(ip, "::ll_model::create", ll_model_CreateCmd, NULL, NULL);
	Tcl_CreateObjCommand(ip, "::ll_model::set", ll_model_SetCmd, NULL, NULL);
	//Tcl_CreateObjCommand(ip, "::ll_model::info", ll_model_InfoCmd, NULL, NULL);
	Tcl_RegisterObjType(&ll_model_ObjType); 
    
 
  Tcl_CreateObjCommand(ip, ns_ll_load_model, tcl_ll_load_model, NULL, 0);
  Tcl_CreateObjCommand(ip, ns_ll_predict, tcl_ll_predict, NULL, 0);
  Tcl_CreateObjCommand(ip, ns_ll_save_model, tcl_ll_save_model, NULL, 0);
  Tcl_CreateObjCommand(ip, ns_ll_train, tcl_ll_train, NULL, 0);
  return TCL_OK;
}
#ifdef __cplusplus
}
#endif
