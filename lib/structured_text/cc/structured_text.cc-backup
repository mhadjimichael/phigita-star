#include "structured_text.h"


void st_init(st_md_t *md) {
  int i;
  for (i = 0; i < MAX_ARGS; ++i)
    md->ptr[i] = NULL;

}

// is_traling_char
// is_leading_char





inline int is_space(const char *ch) {
  return (*ch == ' '  || 
	  *ch == '\t');
}

inline int is_newline(const char *ch) {
  return (*ch == '\r' || *ch == '\n');
}

inline int is_space_or_newline(const char *ch) {
  return (is_space(ch) || is_newline(ch));
}

inline int is_invisible_char(const char *ch) {
  return is_space_or_newline(ch);
}


inline int is_boundary_char(const char *ch, const char *end) {
  return (is_space_or_newline(ch) || 
	  *ch == ',' ||
	  *ch == '.' ||
	  *ch == ':' ||
	  *ch == ';' ||
	  *ch == '!' ||
	  *ch == '?' ||
	  ch == end);
}

inline int is_markup_symbol(const char *ch) {
  return (*ch == '*'  ||
	  *ch == '\'' ||
	  *ch == '"' ||
	  *ch == '_'  ||
	  *ch == '='  ||
	  *ch == '$');
}


inline bool is_math_symbol(const char *ch) {
  return ((*ch >= 'a' && *ch <= 'z') ||
	  (*ch >= '0' && *ch <= '9') ||
	  (*ch >= '<' && *ch <= '>') ||
	  (*ch >= '(' && *ch <= '/') ||
	  (*ch == '^') ||
	  (*ch == '\\'));


}


const char *find_char(const char *begin, const char *end, char ch) {
  return (const char *) memchr(begin,ch,end-begin);
  /*
  while (begin != end && *begin != ch) ++begin;
  if (begin != end)
    return begin;
  else
    return NULL;
  */
}

const char *rfind_char(const char *begin, const char *end, char ch) {
  return (const char *) memrchr(begin,ch,end-begin);
}


const char *find_char_neq(const char *begin, const char *end, char ch) {
  while (begin != end && *begin == ch) ++begin;
  if (begin != end)
    return begin;
  else
    return NULL;
}

const char *next_boundary(const char *ch, const char *end) {
  const char *stop = ch + 1000; // max lookahead 1000 chars
  stop = stop < end ? stop : end;
  while (ch != stop)
    if (is_boundary_char(ch,end))
      return ch;
    else
      ++ch;

  return ch;
}

const char *match_href(const char *ch, const char *end) {

  if ( ch+7 >= end) return NULL;
  
  if ('h' == *ch       &&
      't' == *(ch + 1) &&
      't' == *(ch + 2) &&
      'p' == *(ch + 3) &&
      ':' == *(ch + 4) &&
      '/' == *(ch + 5) &&
      '/' == *(ch + 6)) {

    const char *boundary = ch+7;
    while (boundary && boundary != end && !is_space_or_newline(boundary)) boundary++;

    //while (boundary && boundary+1 < end && !is_space_or_newline(boundary)) {
    //  boundary = next_boundary(boundary+1, end);
    //}
    //  printf("%td ~~~ %.*s ~~~",boundary-ch, boundary-ch,ch);
    while (boundary && is_boundary_char(boundary,end)) --boundary;

    return boundary+1;
  }
  return NULL;
}


const char *match_spaces(const char *begin, const char *end) {
  const char *p = begin;
  while (p!=end && *p == ' ') ++p;
  return p;
}

int only_spaces(const char *begin, const char *end) {
  const char *p = begin;
  while (p!=end)
    if (*p != ' ')
      return 0;
    else
      ++p;
  return 1;
}


const char *match_divider(const char *begin, const char *end, const char **stop_of_curr) {

  while (begin < end && is_space(begin))
    ++begin;

  const char *p = begin;
  while (p!=end && *p == '-') 
    ++p;

  if (p-begin>=5) {
    *stop_of_curr=begin;
    return p;
  }
  return NULL;
}

const char *match_integer(const char *begin, const char *end, st_md_t *md) {
  const char *ch = begin;
  while (ch != end && *ch >= '0' && *ch <= '9') {
    ++ch;
  }
  if (ch != begin) 
    return ch;
  else
    return NULL;
}

const char *match_image(const char *begin, const char *last_char, st_md_t *md) {
  const char *end = last_char + 1;
  if (begin+7 >= end) return 0;
  if ( '{' == *begin     &&
       'i' == *(begin+1) &&
       'm' == *(begin+2) &&
       'a' == *(begin+3) &&
       'g' == *(begin+4) &&
       'e' == *(begin+5) &&
       ':' == *(begin+6) ) {



    const char *ch;
    if (ch=match_integer(begin+7,end,md)) {
      md->ptr[0] = ch;
      //printf("HERE: %.*s\n",10,ch);
      //++ch;
      //if(md->ptr[2] = find_char(ch,end,'}')) 
      if (last_char && *last_char == '}' && (md->ptr[2]=last_char)) {
	md->ptr[1] = find_char(ch,md->ptr[2],'|');
	return md->ptr[2]+1;
      } else {
	md->ptr[0] = NULL;
	md->ptr[1] = NULL;
	md->ptr[2] = NULL;
      }
    }
  }
  return NULL;
}


const char *match_video(const char *begin, const char *last_char, st_md_t *md) {
  const char *end = last_char + 1;

  if (begin+7 >= end) return 0;
  if ( '{' == *begin     &&
       'v' == *(begin+1) &&
       'i' == *(begin+2) &&
       'd' == *(begin+3) &&
       'e' == *(begin+4) &&
       'o' == *(begin+5) &&
       ':' == *(begin+6) ) {

    // {video:abc123_456def.youtube center | hello world}
    //        ^begin+7             ^ptr[0] ^ptr[1]      ^ptr[2]

    //if(md->ptr[2] = find_char(begin+7,end,'}'))
    if (last_char && *last_char == '}' && (md->ptr[2]=last_char)) {
      md->ptr[1] = find_char(begin+7,md->ptr[2],'|');
      const char *ch = md->ptr[1];
      if (!ch) ch = md->ptr[2];
      if (!(md->ptr[0] = find_char(begin+7,ch,' '))) {
	md->ptr[0] = ch; // TODO: check if -1 not sure
      }

      //printf("HERE: %p %p %p\n",md->ptr[0],md->ptr[1],md->ptr[2]);

      return md->ptr[2]+1;
    } else {
      md->ptr[0] = NULL;
      md->ptr[1] = NULL;
      md->ptr[2] = NULL;
    }
  }
  return NULL;
}


bool match_heading(const char *begin, const char *end, const char **stop_of_curr) {
  const char *p = begin;
  if (*p == '=' && *(p+1) == '=') {
    p = end-1;
    while (p>begin && is_space_or_newline(p))
      --p;

    //printf("HERE: %.*sX%d char(%c)\n",p-begin,begin,is_invisible_char(p),*p);

    // TODO: also check that it contains no newline between the open/close markers

    if (p > begin+4 && *(p-1) == '=' && *p == '=') {
      *stop_of_curr = p-1;
      return true;
    }
  }
  return false;
}


const char *match_equation(const char *begin, const char *end) {
  if (begin == end) return NULL;

  while (begin != end && is_math_symbol(begin)) ++begin;
  if (begin != end)
    return NULL;
  else
    return end;
}

void transform_image(const char *p, st_md_t *md, std::string& html) {

  std::string image_id(p+7,(int)(md->ptr[0]-(p+7)));

  html += "<__image__ id=\"" + image_id + "\"";

  const char *inner_text_end = md->ptr[2];
  if (md->ptr[1]) {
    html += " caption=\"" +  std::string(md->ptr[1]+1,(int)(md->ptr[2]-(md->ptr[1]+1)))  + "\"";
    
    inner_text_end = md->ptr[1];
  }

  if (!only_spaces(md->ptr[0],inner_text_end)) {
    html += " align=\"" + std::string(md->ptr[0],(int)(inner_text_end-md->ptr[0])) + "\""; 
			     
  }

  html += " />";

  md->ptr[0] = NULL;
  md->ptr[1] = NULL;
  md->ptr[2] = NULL;
}



void transform_video(const char *p, st_md_t *md, std::string& html) {

  std::string clip_id(p+7,(int)(md->ptr[0]-(p+7)));

  html += "<__video__ id=\"" + clip_id + "\"";

  const char *inner_text_end = md->ptr[2];
  if (md->ptr[1]) {
    html += " caption=\"" +  std::string(md->ptr[1]+1,(int)(md->ptr[2]-(md->ptr[1]+1)))  + "\"";
    
    inner_text_end = md->ptr[1];
  }

  if (!only_spaces(md->ptr[0],inner_text_end)) {
    html += " align=\"" + std::string(md->ptr[0],(int)(inner_text_end-md->ptr[0])) + "\""; 
			     
  }

  html += " />";

  md->ptr[0] = NULL;
  md->ptr[1] = NULL;
  md->ptr[2] = NULL;
}





int compute_para_indent(const char *begin, const char *end) {

  int count, result = INT_MAX;
  const char *p = begin;
  while (p < end) {
    count = 0;
    while (p < end-2 && is_space(p)) {
      count += (*p == '\t' ? 4 : 1);
      ++p;
    }

    /* Check that it's not a blank line by checking that there exists a visible
     * character after the spaces-indent. 
     */
    if (*p != '\n' && *p != '\r')
      if (count < result)
	result = count;

    /* advance to the next line of the paragraph */
    if (p=find_char(p,end,'\n')) 
      ++p;
    else
      break;
  }
  return result;
}


const char *find_next_para(const char *begin, const char *end_of_text) {

  //*end_of_curr = end_of_text;

  if (!begin) return NULL;

  const char *p1 = begin, *p2 = NULL;

  while (p1!=end_of_text 
	 && (p1 = find_char(p1,end_of_text,'\n')) 
	 && (p2 = find_char(p1+1,end_of_text,'\n'))) {

    while (p1 != end_of_text && is_invisible_char(p1)) ++p1;

    if (p1>=p2) {
      //if (*end_of_curr == end_of_text) *end_of_curr = p1;  // first newline
      while(!is_newline(p1)) --p1;  // find last newline
      return p1+1;  // first character after the last newline
    } else {
      p1=p2;
    }

  }

  return end_of_text;

}


// copies quoted HTML to given string
std::string quotehtml(const char *begin, const char *end) {
  std::string out;

  const char *ch = begin;
  while (ch != end && ch != '\0') {
    switch(*ch) {
    case '<':
      out += "&lt;";
      break;
    case '>':
      out += "&gt;";
      break;
    case '&':
      out += "&amp;";
      break;
    default:
      out += *ch;
      break;
    }
    ++ch;
  }
  return out;
}


std::string quotehtml(const std::string& text) {
  const char *begin = text.data();
  const char *end = begin+text.size();
  return quotehtml(begin,end);
}

std::string quotehtml(const char *text) {
  const char *begin = text;
  const char *end = begin+strlen(text);
  return quotehtml(begin,end);
}

structured_text::structured_text(const char *text) : text_(quotehtml(text)) {
  //printf("text length=%zd\n",text_.size());
}

inline void change_state_pointer(const char *q, const char *p, std::string& output) {
  if (q) output += std::string(q,p-q);
}


int trailing_markup(const char *ch, const char *end) {
  if (ch+1 == end)
    return (*ch == '*') ? ITALIC 
      : (*ch == '_') ? UNDERLINE
      : (*ch == '$') ? EQUATION
      : (*ch == '}') ? INCLUDELET
      : NONE;
  else
    return (*ch == '"'  && *(ch+1) == ':') ? HREF_TEXT
      : (*ch == ':'  && *(ch+1) == '/') ? HREF_NOTEXT
      : (*ch == '*'  && *(ch+1) == '*'  && is_boundary_char(ch+2,end)) ? BOLD
      : (*ch == '\'' && *(ch+1) == '\'' && is_boundary_char(ch+2,end)) ? HIGHLIGHT
      : (*ch == '='  && *(ch+1) == '='  && is_boundary_char(ch+2,end)) ? HEADING
      : (*ch == '_'  && is_boundary_char(ch+1,end)) ? UNDERLINE
      : (*ch == '*'  && is_boundary_char(ch+1,end)) ? ITALIC
      : (*ch == '$'  && is_boundary_char(ch+1,end)) ? EQUATION
      : (*ch == '}'  && is_boundary_char(ch+1,end)) ? INCLUDELET
      : NONE;
}

const char *find_first_true(const char *begin, const char *end, 
			    int(*fp)(const char *,const char *)) {

  while (begin != end && !fp(begin,end)) ++begin;
  if (begin != end)
    return begin;
  else
    return end;

}


const char *rfind_str(const char *begin, const char *end, const char *str, size_t n) {
  const char *p = end;
  const char ch = str[n-1];
  bool found_p = false;

  while (p>begin && (p= (const char *) memrchr(begin,ch,p-begin)) && p-begin+1 >= n-1 && !found_p) {
    found_p = true;
    for(size_t i=1; i<n; ++i) {
      if (str[n-1-i] != *(p-i)) {
	found_p = false;
	break;
      }
    }
    if (found_p) return p;
  }
  return NULL;
}



// decorate, font emphasis (bold,italic,highlight)
// paragraph to html, in the future maybe section to html, we'll see...
void structured_text::block_to_html(const char *begin, const char *end, std::string& html) {
  const char *p = begin, *q = NULL, *r = NULL, *temp = NULL, *s = NULL;

  st_md_t md ;
  st_init(&md);

  while (p < end) {

    q = find_first_true(p,end,trailing_markup);
    //html += "X"; // TODO: remove me

    s = NULL;
    switch(trailing_markup(q,end)) {
    case HREF_NOTEXT:
      r = q-4;
      if (r >= p && (s = match_href(r,end))) {
	if ( r > p ) html += std::string(p,r-p);
	std::string href(r,s-r);
	html +=  "<a href=\"" + href + "\">" + href + "</a>"; 
	p = s-1;  // it is incremented by 1 before the end of the loop
	q = s-1;  // it is incremented by 1 before the end of the loop
      }
      break;
    case HREF_TEXT:
      r=q+2;
      if (r <end && (temp = match_href(r,end)) && (s = rfind_char(p,q,'"'))) {
	if ( s > p ) html += std::string(p,s-p);
	std::string href(r,temp-r);
	std::string href_text(s+1,q-(s+1));
	html +=  "<a href=\"" + href + "\">" + href_text + "</a>"; 
	p = temp-1;  // it is incremented by 1 before the end of the loop
	q = temp-1;  // it is incremented by 1 before the end of the loop
      }
      break;
    case ITALIC:
      if (s=rfind_char(p,q,'*')) {
	if ( s > p ) html += std::string(p,s-p);
	html += "<span class=\"italic\">" + std::string(s+1, q-(s+1)) + "</span>";
      }
      break;
    case UNDERLINE:
      if (s=rfind_char(p,q,'_')) {
	if ( s > p ) html += std::string(p,s-p);
	html += "<u>" + std::string(s+1, q-(s+1)) + "</u>";
      }
      break;
    case EQUATION:
      if ((temp=rfind_char(p,q,'$')) && (s=match_equation(temp+1,q)) ) {
	if ( temp > p ) html += std::string(p,temp-p);
	html += "<__math__>" + std::string(temp+1, q-(temp+1)) + "</__math__>";
      }
      break;
    case BOLD:
      // The following in the beginning of the text causes the stars to disappear:
      // ** DISCLAIMER **
      //
      if (s=rfind_str(p,q,"**",2)) {
	if ( s-1 > p ) html += std::string(p,(s-1)-p);
	html += "<span class=\"bold\">" + std::string(s+1, q-(s+1)) + "</span>";
	//q += 1;
      }
      break;
    case HIGHLIGHT:
      if (s=rfind_str(p,q,"''",2)) {
	if ( s-1 > p ) html += std::string(p,(s-1)-p);
	html += "<span class=\"highlight\">" + std::string(s+1, q-(s+1)) + "</span>";
	//q += 1;
      }
      break;
    case HEADING:
      if (s=rfind_str(p,q,"==",2)) {
	if ( s-1 > p ) html += std::string(p,(s-1)-p);
	html += "<h3>" + std::string(s+1, q-(s+1)) + "</h3>";
	//q += 1;
      }
      break;
    case INCLUDELET:
      if (s=rfind_char(p,q,'{')) {
	if ( s > p ) html += std::string(p,s-p);
	if (match_image(s,q,&md)) {
	  transform_image(s,&md,html);
	} else if (match_video(s,q,&md)) {
	  transform_video(s,&md,html);
	}
      }
      break;
    }


    // if none activated, fallback case is here
    if (!s) 
      html += std::string(p,q-p);

    // use two variables, one to keep track the search, and one to show the last processed character
    if (q != end)
      p=q+1;
    else
      break;

  } // while


}



void structured_text::special_to_html(const std::string& marker, std::queue<std::pair<const char*,size_t> >& special_text_queue, std::string& html) {
  if (marker == "::") {

    html += "<div class=\"pre\">";

    std::pair<const char*,size_t> p;
    const char *iter;
    const char * stop;

    bool empty_p = special_text_queue.empty();
    while (!empty_p) {
      p = special_text_queue.front();

      std::string special_html;
      //      printf("%zd\n",p.second);

      special_html.reserve(p.second);
      block_to_html(p.first,p.first+p.second,special_html);

      iter = special_html.data();
      stop = iter + special_html.size();

      for(; iter != stop; ++iter)
	if (*iter == '\n')
	  html += "<br />";
	else if (*iter == '\t')
	  html += "&nbsp; &nbsp; &nbsp; &nbsp; ";
	else
	  html += *iter;

      special_text_queue.pop();
      if (!(empty_p=special_text_queue.empty()))
	html += "<br /><br />";  // new paragraph/block in special text

    }

    html += "</div>\n\n";

  } else if (marker == "%%") {
    html += "<div class=\"code\">";
    std::pair<const char*,size_t> p;
    const char *iter;
    const char * stop;

    bool empty_p = special_text_queue.empty();
    while (!empty_p) {
      p = special_text_queue.front();
      iter = p.first;
      stop = p.first + p.second;

      html += std::string(p.first,p.second);

      special_text_queue.pop();
      if (!(empty_p=special_text_queue.empty()))
	html += "\n\n";  // new paragraph/block in special text

    }

    html += "</div>\n\n";
  }
  /*
    switch -exact -- ${handler} {
    {::} {
    Special_Text_Handler=Preformatted ${edit_p} str
    }
    {%%} {
    Special_Text_Handler=Code str
    }
    {$$} {
    Special_Text_Handler=Math str
    }
    {||} {
    Special_Text_Handler=Table str
    }
    {##} {
    Special_Text_Handler=Data_Source str
    }
    }
  */
}





#include <cstdio>
void structured_text::to_html(std::string& html) {
  //const char *text = text_.data();
  const char *begin = text_.c_str();
  const size_t size = text_.size();
  const char *end = begin + size;

  int indent = 0, prev_indent = 0, pos = 0, tag = NONE;
  bool preformatted_p = false, prev_preformatted_p = false;
  std::string special_text_marker, otag, ctag;
  std::stack<int> indent_stack;
  std::stack<std::string> ctag_stack;
  std::queue<std::pair<const char*,size_t> > special_text_queue;

  const char *curr = begin;
  const char *end_of_curr; // end of current paragraph
  const char *stop_of_curr;  // skip characters after this point, e.g. special text markers,
  const char *next = NULL;

  int count = 0;
  while (curr && curr != end) {
    // DO NOT TOUCH - START
    next = find_next_para(curr,end);
    end_of_curr = next;
    while (curr!=end_of_curr && is_space_or_newline(end_of_curr-1)) --end_of_curr;
    // DO NOT TOUCH - END

    stop_of_curr = end_of_curr;
    indent = compute_para_indent(curr,end_of_curr);

    if (preformatted_p && prev_indent < indent) {
      if (curr < end_of_curr) {
	special_text_queue.push(std::make_pair(curr,end_of_curr-curr));
      }
      prev_preformatted_p = true;
      curr = next;
      continue;
    } else {
      tag = NONE;

      // ^[ \t\n]*([*o\-\#])([ \t\n]+[^\0]*)}
      const char *symbol = NULL;
      if (symbol=find_char_neq(curr,end_of_curr,' ')) {
	//html += "Z";
	if (*symbol == '-' && match_divider(symbol,end_of_curr,&stop_of_curr)) {
	  tag = HR;
	  otag = kHorizontalRuleHTML;
	  ctag = "\n\n";
	  curr = stop_of_curr;
	} else if ((*symbol == '*' || *symbol == '-' || *symbol == 'o') && is_space(symbol+1)) {
	  tag = UL;
	  otag = "<ul>";
	  ctag = "</ul>";
	  curr = symbol+2;
	} else if (*symbol == '#' &&  is_space(symbol+1)) {
	  tag = OL;
	  otag = "<ol>";
	  ctag = "</ol>";
	  curr = symbol+2;
	} else if (*symbol == '=' && match_heading(symbol,end_of_curr,&stop_of_curr)) {
	  tag = HEADING;
	  otag = "<h3>";
	  ctag = "</h3>";
	  curr = symbol+2;
	} else {
	  tag = NONE;
	  otag.clear();
	  ctag.clear();
	}
      } 

      /*
	if (tag != NONE && tag != HR && std::string::npos == text_.find_first_not_of(" \t",index+1,2)) {
	  tag = NONE;
	  otag.clear();
	  ctag.clear();
	}
	*/

      //html += "(";
      //html += char(*symbol);
      //html += ")";
    }


    while (!indent_stack.empty()) {
      if (indent < indent_stack.top() || ctag != ctag_stack.top()) {
	html += ctag_stack.top();
	ctag_stack.pop();
	indent_stack.pop();
      } else {
	break;
      }
    }

    if (prev_preformatted_p) {
      special_to_html(special_text_marker,special_text_queue,html);
      prev_preformatted_p = false;
    }


    const char *marker;
    if ((marker=rfind_str(curr, end_of_curr, "::", 2))
	|| (marker=rfind_str(curr, end_of_curr, "%%", 2))
	|| (marker=rfind_str(curr, end_of_curr, "##", 2))) {

      special_text_marker = std::string(marker-1,2);
      preformatted_p = true;
      stop_of_curr = marker-1;
    } else {
      special_text_marker.clear();
    }

    if ( (indent_stack.empty() && ctag_stack.empty()) 
	 || indent > indent_stack.top() 
	 || ctag != ctag_stack.top() ) {
      html += otag;
      indent_stack.push(indent);
      ctag_stack.push(ctag);
    }

    switch (tag) {
    case UL:
    case OL:
    case DL:
      html += "<li>";
      block_to_html(curr,stop_of_curr,html);
      html += "</li>";
      break;
    case HEADING:
      html += std::string(curr,stop_of_curr-curr);
      break;
    case HR:
      break;
    default:
      html += "<p>";
      if (curr != stop_of_curr) {
	block_to_html(curr,stop_of_curr,html);
      }
      html += "</p>\n\n";  // remove the newlines when done testing
      break;
    }
    prev_indent = indent;


    curr = next;
  }


  if ( prev_preformatted_p ) {
    special_to_html(special_text_marker,special_text_queue,html);
    prev_preformatted_p = 0;
  }

  while(!ctag_stack.empty()) {
    html += ctag_stack.top();
    ctag_stack.pop();
  }


}

std::string structured_text::to_html() {
  std::string result;
  to_html(result);
  return result;
}
